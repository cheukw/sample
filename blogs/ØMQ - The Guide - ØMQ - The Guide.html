<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0033)http://zguide.zeromq.org/page:all -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>ØMQ - The Guide - ØMQ - The Guide</title>
    
    	<script type="text/javascript" src="./ØMQ - The Guide - ØMQ - The Guide_files/login__CustomDomainScript"></script>

    
    <script type="text/javascript" src="./ØMQ - The Guide - ØMQ - The Guide_files/init.combined.js.下载"></script>
    <script type="text/javascript">
        var URL_HOST = 'www.wikidot.com';
        var URL_DOMAIN = 'wikidot.com';
        var USE_SSL =  true ;
        var URL_STATIC = 'http://d3g0gp89917ko0.cloudfront.net/v--edac79f846ba';
        // global request information
        
        var WIKIREQUEST = {};
        WIKIREQUEST.info = {};
        
        WIKIREQUEST.info.domain = "zguide.zeromq.org";
        WIKIREQUEST.info.siteId = 193426;
        WIKIREQUEST.info.siteUnixName = "zguide";
        WIKIREQUEST.info.categoryId = 1068616;
        WIKIREQUEST.info.themeId = 1;
        WIKIREQUEST.info.requestPageName = "page:all";
        OZONE.request.timestamp = 1489197627;
        OZONE.request.date = new Date();
        WIKIREQUEST.info.lang = 'en';
                WIKIREQUEST.info.pageUnixName = "page:all";
        WIKIREQUEST.info.pageId = 5820894;
                        WIKIREQUEST.info.lang = "en";
        OZONE.lang = "en";
        var isUAMobile = !!/Android|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    </script>
    
    


    
        <script type="text/javascript">
    
        require.config({
            baseUrl: URL_STATIC + '/common--javascript',
            paths: {
                'jquery.ui': 'jquery-ui.min',
                'jquery.form': 'jquery.form'
            }
        });
    
    </script>
    
    
            
    
    
    
    
    <meta http-equiv="content-language" content="en">
    <script type="text/javascript" src="./ØMQ - The Guide - ØMQ - The Guide_files/WIKIDOT.combined.js.下载"></script>
        
    
    <style type="text/css" id="internal-style">
        
        /* modules */
        
                
        /* theme */
                    @import url(http://d3g0gp89917ko0.cloudfront.net/v--edac79f846ba/common--theme/base/css/style.css);
                    @import url(http://zguide.wdfiles.com/local--code/admin:css/1);
            </style>
    
        
        
        
    <link rel="shortcut icon" href="http://zguide.zeromq.org/local--favicon/favicon.gif">
    <link rel="icon" type="image/gif" href="http://zguide.zeromq.org/local--favicon/favicon.gif">
    
            <link rel="apple-touch-icon" href="http://zguide.zeromq.org/common--images/apple-touch-icon-57x57.png">
        <link rel="apple-touch-icon" sizes="72x72" href="http://zguide.zeromq.org/common--images/apple-touch-icon-72x72.png">
        <link rel="apple-touch-icon" sizes="114x114" href="http://zguide.zeromq.org/common--images/apple-touch-icon-114x114.png">
        
        
            <link rel="alternate" type="application/wiki" title="Edit this page" href="javascript:WIKIDOT.page.listeners.editClick()">
    
        <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-18234656-1']);
        _gaq.push(['_setDomainName', 'none']);
        _gaq.push(['_setAllowLinker', true]);
        _gaq.push(['_trackPageview']);

        _gaq.push(['old._setAccount', 'UA-68540-5']);
        _gaq.push(['old._setDomainName', 'none']);
        _gaq.push(['old._setAllowLinker', true]);
        _gaq.push(['old._trackPageview']);

                _gaq.push(['userTracker._setAccount', 'UA-3207370-7']);
        _gaq.push(['userTracker._trackPageview']);
            </script>
    
    <script type="text/javascript">
        window.google_analytics_uacct = 'UA-18234656-1';
        window.google_analytics_domain_name = 'none';
    </script>
    
    <style>
.foldedtoc #toc #toc-action-bar { display: none }
.foldedtoc #toc .title { display: none; border: 0px solid black; }
.foldedtoc #toc { border: 0px solid black; margin: 0 0 0 -0,9em; }
.foldedtoc .collapsible-block-link { text-decoration:none }
</style>
<style>
@media print {
    #side-bar  { display: none; }
    #main-content { margin-left: 0; }
    .page-watch-options { display: none; }
    #page-options-bottom { display: none; }
    #login-status { display: none; }
    #search-top-box { display: none; }
    .main-text { width:100%; font-size:9pt; }
    .right-bar { display: none; }
    .foldedtoc { display: none; }
    div.code { overflow: visible; }
    #container-wrap { width: 100%; }
    #main-content { width: 100%; }
    #footer { width: 100%; }
}
</style>
</head>
<body id="html-body">
<div id="skrollr-body">
<a name="page-top"></a>

<div id="container-wrap-wrap">
    <div id="container-wrap">
        <div id="container">
            <div id="header">
              <h1><a href="http://zguide.zeromq.org/"><span>ØMQ - The Guide</span></a></h1>
                
                
                <!-- google_ad_section_start(weight=ignore) -->
                
                <div id="search-top-box" class="form-search">
    <form id="search-top-box-form" action="http://zguide.zeromq.org/dummy" class="input-append">
        <input id="search-top-box-input" class="text empty search-query" type="text" size="15" name="query" value="Search this site" onfocus="if(YAHOO.util.Dom.hasClass(this, &#39;empty&#39;)){YAHOO.util.Dom.removeClass(this,&#39;empty&#39;); this.value=&#39;&#39;;}"><input class="button btn" type="submit" name="search" value="Search">
    </form>
</div>
                
                
                <div id="login-status"><a href="javascript:;" onclick="WIKIDOT.page.listeners.createAccount(event)" class="login-status-create-account btn">Create account</a> <span>or</span> <a href="javascript:;" onclick="WIKIDOT.page.listeners.loginClick(event)" class="login-status-sign-in btn btn-primary">Sign in</a> </div>
                <div id="header-extra-div-1"><span></span></div><div id="header-extra-div-2"><span></span></div><div id="header-extra-div-3"><span></span></div>
            </div>
            
            <div id="content-wrap">
                
                
                <!-- google_ad_section_end -->
                
                <div id="main-content">
                    <div id="action-area-top"></div>
                    
                    
                        <div id="page-title">
                            ØMQ - The Guide
                        </div>
                    

                    

                    



                    <div id="page-content">
                        






<p><a name="top"></a></p>
<div class="foldedtoc" style="border:1px black dashed;float:left;margin:10px">
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">Table&nbsp;of&nbsp;Contents</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">Table&nbsp;of&nbsp;Contents</a></div>
<div class="collapsible-block-content">
<table style="margin:0; padding:0">
<tbody><tr>
<td style="margin:0; padding:0">
<div id="toc">
<div id="toc-action-bar"><a href="javascript:;" onclick="WIKIDOT.page.listeners.foldToc(event)">Fold</a><a style="display: none" href="javascript:;" onclick="WIKIDOT.page.listeners.unfoldToc(event)">Unfold</a></div>
<div class="title">Table of Contents</div>
<div id="toc-list">
<div style="margin-left: 2em;"><a href="http://zguide.zeromq.org/page:all#toc0">Preface</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc1">ZeroMQ in a Hundred Words</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc2">How It Began</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc3">The Zen of Zero</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc4">Audience</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc5">Acknowledgements</a></div>
<div style="margin-left: 2em;"><a href="http://zguide.zeromq.org/page:all#toc6">Chapter 1 - Basics</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc7">Fixing the World</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc8">Starting Assumptions</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc9">Getting the Examples</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc10">Ask and Ye Shall Receive</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc11">A Minor Note on Strings</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc12">Version Reporting</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc13">Getting the Message Out</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc14">Divide and Conquer</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc15">Programming with ZeroMQ</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc16">Getting the Context Right</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc17">Making a Clean Exit</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc18">Why We Needed ZeroMQ</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc19">Socket Scalability</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc20">Upgrading from ZeroMQ v2.2 to ZeroMQ v3.2</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc21">Compatible Changes</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc22">Incompatible Changes</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc23">Suggested Shim Macros</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc24">Warning: Unstable Paradigms!</a></div>
<div style="margin-left: 2em;"><a href="http://zguide.zeromq.org/page:all#toc25">Chapter 2 - Sockets and Patterns</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc26">The Socket API</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc27">Plugging Sockets into the Topology</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc28">Sending and Receiving Messages</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc29">Unicast Transports</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc30">ZeroMQ is Not a Neutral Carrier</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc31">I/O Threads</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc32">Messaging Patterns</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc33">High-Level Messaging Patterns</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc34">Working with Messages</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc35">Handling Multiple Sockets</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc36">Multipart Messages</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc37">Intermediaries and Proxies</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc38">The Dynamic Discovery Problem</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc39">Shared Queue (DEALER and ROUTER sockets)</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc40">ZeroMQ's Built-In Proxy Function</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc41">Transport Bridging</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc42">Handling Errors and ETERM</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc43">Handling Interrupt Signals</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc44">Detecting Memory Leaks</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc45">Multithreading with ZeroMQ</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc46">Signaling Between Threads (PAIR Sockets)</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc47">Node Coordination</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc48">Zero-Copy</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc49">Pub-Sub Message Envelopes</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc50">High-Water Marks</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc51">Missing Message Problem Solver</a></div>
<div style="margin-left: 2em;"><a href="http://zguide.zeromq.org/page:all#toc52">Chapter 3 - Advanced Request-Reply Patterns</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc53">The Request-Reply Mechanisms</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc54">The Simple Reply Envelope</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc55">The Extended Reply Envelope</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc56">What's This Good For?</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc57">Recap of Request-Reply Sockets</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc58">Request-Reply Combinations</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc59">The REQ to REP Combination</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc60">The DEALER to REP Combination</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc61">The REQ to ROUTER Combination</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc62">The DEALER to ROUTER Combination</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc63">The DEALER to DEALER Combination</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc64">The ROUTER to ROUTER Combination</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc65">Invalid Combinations</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc66">Exploring ROUTER Sockets</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc67">Identities and Addresses</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc68">ROUTER Error Handling</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc69">The Load Balancing Pattern</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc70">ROUTER Broker and REQ Workers</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc71">ROUTER Broker and DEALER Workers</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc72">A Load Balancing Message Broker</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc73">A High-Level API for ZeroMQ</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc74">Features of a Higher-Level API</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc75">The CZMQ High-Level API</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc76">The Asynchronous Client/Server Pattern</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc77">Worked Example: Inter-Broker Routing</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc78">Establishing the Details</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc79">Architecture of a Single Cluster</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc80">Scaling to Multiple Clusters</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc81">Federation Versus Peering</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc82">The Naming Ceremony</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc83">Prototyping the State Flow</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc84">Prototyping the Local and Cloud Flows</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc85">Putting it All Together</a></div>
<div style="margin-left: 2em;"><a href="http://zguide.zeromq.org/page:all#toc86">Chapter 4 - Reliable Request-Reply Patterns</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc87">What is "Reliability"?</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc88">Designing Reliability</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc89">Client-Side Reliability (Lazy Pirate Pattern)</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc90">Basic Reliable Queuing (Simple Pirate Pattern)</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc91">Robust Reliable Queuing (Paranoid Pirate Pattern)</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc92">Heartbeating</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc93">Shrugging It Off</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc94">One-Way Heartbeats</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc95">Ping-Pong Heartbeats</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc96">Heartbeating for Paranoid Pirate</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc97">Contracts and Protocols</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc98">Service-Oriented Reliable Queuing (Majordomo Pattern)</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc99">Asynchronous Majordomo Pattern</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc100">Service Discovery</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc101">Idempotent Services</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc102">Disconnected Reliability (Titanic Pattern)</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc103">High-Availability Pair (Binary Star Pattern)</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc104">Detailed Requirements</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc105">Preventing Split-Brain Syndrome</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc106">Binary Star Implementation</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc107">Binary Star Reactor</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc108">Brokerless Reliability (Freelance Pattern)</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc109">Model One: Simple Retry and Failover</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc110">Model Two: Brutal Shotgun Massacre</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc111">Model Three: Complex and Nasty</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc112">Conclusion</a></div>
<div style="margin-left: 2em;"><a href="http://zguide.zeromq.org/page:all#toc113">Chapter 5 - Advanced Pub-Sub Patterns</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc114">Pros and Cons of Pub-Sub</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc115">Pub-Sub Tracing (Espresso Pattern)</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc116">Last Value Caching</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc117">Slow Subscriber Detection (Suicidal Snail Pattern)</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc118">High-Speed Subscribers (Black Box Pattern)</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc119">Reliable Pub-Sub (Clone Pattern)</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc120">Centralized Versus Decentralized</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc121">Representing State as Key-Value Pairs</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc122">Getting an Out-of-Band Snapshot</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc123">Republishing Updates from Clients</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc124">Working with Subtrees</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc125">Ephemeral Values</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc126">Using a Reactor</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc127">Adding the Binary Star Pattern for Reliability</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc128">The Clustered Hashmap Protocol</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc129">Building a Multithreaded Stack and API</a></div>
<div style="margin-left: 2em;"><a href="http://zguide.zeromq.org/page:all#toc130">Chapter 6 - The ZeroMQ Community</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc131">Architecture of the ZeroMQ Community</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc132">How to Make Really Large Architectures</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc133">Psychology of Software Architecture</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc134">The Importance of Contracts</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc135">Eat Me</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc136">The Process</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc137">Crazy, Beautiful, and Easy</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc138">Stranger, Meet Stranger</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc139">Infinite Property</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc140">Care and Feeding</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc141">The ZeroMQ Process: C4</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc142">Language</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc143">Goals</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc144">Preliminaries</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc145">Licensing and Ownership</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc146">Patch Requirements</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc147">Development Process</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc148">Creating Stable Releases</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc149">Evolution of Public Contracts</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc150">Project Administration</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc151">A Real-Life Example</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc152">Git Branches Considered Harmful</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc153">Simplicity Versus Complexity</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc154">Change Latency</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc155">Learning Curve</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc156">Cost of Failure</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc157">Up-front Coordination</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc158">Scalability</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc159">Surprise and Expectations</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc160">Economics of Participation</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc161">Robustness in Conflict</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc162">Guarantees of Isolation</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc163">Visibility</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc164">Conclusions</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc165">Designing for Innovation</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc166">The Tale of Two Bridges</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc167">How ZeroMQ Lost Its Road Map</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc168">Trash-Oriented Design</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc169">Complexity-Oriented Design</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc170">Simplicity Oriented Design</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc171">Burnout</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc172">Patterns for Success</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc173">The Lazy Perfectionist</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc174">The Benevolent Tyrant</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc175">The Earth and Sky</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc176">The Open Door</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc177">The Laughing Clown</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc178">The Mindful General</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc179">The Social Engineer</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc180">The Constant Gardener</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc181">The Rolling Stone</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc182">The Pirate Gang</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc183">The Flash Mob</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc184">The Canary Watcher</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc185">The Hangman</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc186">The Historian</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc187">The Provocateur</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc188">The Mystic</a></div>
<div style="margin-left: 2em;"><a href="http://zguide.zeromq.org/page:all#toc189">Chapter 7 - Advanced Architecture using ZeroMQ</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc190">Message-Oriented Pattern for Elastic Design</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc191">Step 1: Internalize the Semantics</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc192">Step 2: Draw a Rough Architecture</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc193">Step 3: Decide on the Contracts</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc194">Step 4: Write a Minimal End-to-End Solution</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc195">Step 5: Solve One Problem and Repeat</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc196">Unprotocols</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc197">Protocols Without The Goats</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc198">Contracts Are Hard</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc199">How to Write Unprotocols</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc200">Why use the GPLv3 for Public Specifications?</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc201">Using ABNF</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc202">The Cheap or Nasty Pattern</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc203">Error Handling</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc204">Serializing Your Data</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc205">Abstraction Level</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc206">ZeroMQ Framing</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc207">Serialization Languages</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc208">Serialization Libraries</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc209">Handwritten Binary Serialization</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc210">Code Generation</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc211">Transferring Files</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc212">State Machines</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc213">Authentication Using SASL</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc214">Large-Scale File Publishing: FileMQ</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc215">Why make FileMQ?</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc216">Initial Design Cut: the API</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc217">Initial Design Cut: the Protocol</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc218">Building and Trying FileMQ</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc219">Internal Architecture</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc220">Public API</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc221">Design Notes</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc222">Configuration</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc223">File Stability</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc224">Delivery Notifications</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc225">Symbolic Links</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc226">Recovery and Late Joiners</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc227">Test Use Case: The Track Tool</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc228">Getting an Official Port Number</a></div>
<div style="margin-left: 2em;"><a href="http://zguide.zeromq.org/page:all#toc229">Chapter 8 - A Framework for Distributed Computing</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc230">Design for The Real World</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc231">The Secret Life of WiFi</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc232">Why Mesh Isn't Here Yet</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc233">Some Physics</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc234">What's the Current Status?</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc235">Conclusions</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc236">Discovery</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc237">Service Discovery</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc238">Network Discovery</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc239">The Use Case</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc240">Technical Requirements</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc241">A Self-Healing P2P Network in 30 Seconds</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc242">Preemptive Discovery over Raw Sockets</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc243">Cooperative Discovery Using UDP Broadcasts</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc244">Multiple Nodes on One Device</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc245">Designing the API</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc246">More About UDP</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc247">Spinning Off a Library Project</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc248">Point-to-Point Messaging</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc249">UDP Beacon Framing</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc250">True Peer Connectivity (Harmony Pattern)</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc251">Detecting Disappearances</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc252">Group Messaging</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc253">Testing and Simulation</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc254">On Assertions</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc255">On Up-Front Testing</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc256">The Zyre Tester</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc257">Test Results</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc258">Tracing Activity</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc259">Dealing with Blocked Peers</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc260">Distributed Logging and Monitoring</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc261">A Plausible Minimal Implementation</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc262">Protocol Assertions</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc263">Binary Logging Protocol</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc264">Content Distribution</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc265">Writing the Unprotocol</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc266">Example Zyre Application</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc267">Conclusions</a></div>
<div style="margin-left: 2em;"><a href="http://zguide.zeromq.org/page:all#toc268">Postface</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc269">Tales from Out There</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc270">Rob Gagnon's Story</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc271">Tom van Leeuwen's Story</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc272">Michael Jakl's Story</a></div>
<div style="margin-left: 4em;"><a href="http://zguide.zeromq.org/page:all#toc273">Vadim Shalts's Story</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc274">How This Book Happened</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc275">Removing Friction</a></div>
<div style="margin-left: 3em;"><a href="http://zguide.zeromq.org/page:all#toc276">Licensing</a></div>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div style="clear:both; height: 0px; font-size: 1px"></div>
<p><strong>By Pieter Hintjens, CEO of iMatix</strong></p>
<p>Please use the <a href="https://github.com/imatix/zguide/issues">issue tracker</a> for all comments and errata. This version covers the latest stable release of ZeroMQ (3.2). If you are using older versions of ZeroMQ then some of the examples and explanations won't be accurate.</p>
<p>The Guide is originally <a href="http://zguide.zeromq.org/page:all">in C</a>, but also in <a href="http://zguide.zeromq.org/php:all">PHP</a>, <a href="http://zguide.zeromq.org/py:all">Python</a>, <a href="http://zguide.zeromq.org/lua:all">Lua</a>, and <a href="http://zguide.zeromq.org/hx:all">Haxe</a>. We've also translated most of the examples into C++, C#, CL, Delphi, Erlang, F#, Felix, Haskell, Java, Objective-C, Ruby, Ada, Basic, Clojure, Go, Haxe, Node.js, ooc, Perl, and Scala.</p>
<p><a name="Preface"></a><a name="header-1"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h2 id="toc0"><span><a href="http://zguide.zeromq.org/page:all#Preface">Preface</a></span></h2>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-0">prev</a> <a href="http://zguide.zeromq.org/page:all#header-2">next</a></td>
</tr>
</tbody></table>
<p><a name="ZeroMQ-in-a-Hundred-Words"></a><a name="header-2"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc1"><span><a href="http://zguide.zeromq.org/page:all#ZeroMQ-in-a-Hundred-Words">ZeroMQ in a Hundred Words</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-1">prev</a> <a href="http://zguide.zeromq.org/page:all#header-3">next</a></td>
</tr>
</tbody></table>
<p>ZeroMQ (also known as ØMQ, 0MQ, or zmq) looks like an embeddable networking library but acts like a concurrency framework. It gives you sockets that carry atomic messages across various transports like in-process, inter-process, TCP, and multicast. You can connect sockets N-to-N with patterns like fan-out, pub-sub, task distribution, and request-reply. It's fast enough to be the fabric for clustered products. Its asynchronous I/O model gives you scalable multicore applications, built as asynchronous message-processing tasks. It has a score of language APIs and runs on most operating systems. ZeroMQ is from <a href="http://www.imatix.com/">iMatix</a> and is LGPLv3 open source.</p>
<p><a name="How-It-Began"></a><a name="header-3"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc2"><span><a href="http://zguide.zeromq.org/page:all#How-It-Began">How It Began</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-2">prev</a> <a href="http://zguide.zeromq.org/page:all#header-4">next</a></td>
</tr>
</tbody></table>
<p>We took a normal TCP socket, injected it with a mix of radioactive isotopes stolen from a secret Soviet atomic research project, bombarded it with 1950-era cosmic rays, and put it into the hands of a drug-addled comic book author with a badly-disguised fetish for bulging muscles clad in spandex. Yes, ZeroMQ sockets are the world-saving superheroes of the networking world.</p>
<p><strong>Figure 1 - A terrible accident…</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig1.png" alt="fig1.png" class="image"></div>
<p><a name="The-Zen-of-Zero"></a><a name="header-4"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc3"><span><a href="http://zguide.zeromq.org/page:all#The-Zen-of-Zero">The Zen of Zero</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-3">prev</a> <a href="http://zguide.zeromq.org/page:all#header-5">next</a></td>
</tr>
</tbody></table>
<p>The Ø in ZeroMQ is all about tradeoffs. On the one hand this strange name lowers ZeroMQ's visibility on Google and Twitter. On the other hand it annoys the heck out of some Danish folk who write us things like "ØMG røtfl", and "Ø is not a funny looking zero!" and "<em>Rødgrød med fløde!</em>", which is apparently an insult that means "may your neighbours be the direct descendants of Grendel!" Seems like a fair trade.</p>
<p>Originally the zero in ZeroMQ was meant as "zero broker" and (as close to) "zero latency" (as possible). Since then, it has come to encompass different goals: zero administration, zero cost, zero waste. More generally, "zero" refers to the culture of minimalism that permeates the project. We add power by removing complexity rather than by exposing new functionality.</p>
<p><a name="Audience"></a><a name="header-5"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc4"><span><a href="http://zguide.zeromq.org/page:all#Audience">Audience</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-4">prev</a> <a href="http://zguide.zeromq.org/page:all#header-6">next</a></td>
</tr>
</tbody></table>
<p>This book is written for professional programmers who want to learn how to make the massively distributed software that will dominate the future of computing. We assume you can read C code, because most of the examples here are in C even though ZeroMQ is used in many languages. We assume you care about scale, because ZeroMQ solves that problem above all others. We assume you need the best possible results with the least possible cost, because otherwise you won't appreciate the trade-offs that ZeroMQ makes. Other than that basic background, we try to present all the concepts in networking and distributed computing you will need to use ZeroMQ.</p>
<p><a name="Acknowledgements"></a><a name="header-6"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc5"><span><a href="http://zguide.zeromq.org/page:all#Acknowledgements">Acknowledgements</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-5">prev</a> <a href="http://zguide.zeromq.org/page:all#header-7">next</a></td>
</tr>
</tbody></table>
<p>Thanks to Andy Oram for making <a href="http://shop.oreilly.com/product/0636920026136.do">the O'Reilly book</a> happen, and editing this text.</p>
<p>Thanks to Bill Desmarais, Brian Dorsey, Daniel Lin, Eric Desgranges, Gonzalo Diethelm, Guido Goldstein, Hunter Ford, Kamil Shakirov, Martin Sustrik, Mike Castleman, Naveen Chawla, Nicola Peduzzi, Oliver Smith, Olivier Chamoux, Peter Alexander, Pierre Rouleau, Randy Dryburgh, John Unwin, Alex Thomas, Mihail Minkov, Jeremy Avnet, Michael Compton, Kamil Kisiel, Mark Kharitonov, Guillaume Aubert, Ian Barber, Mike Sheridan, Faruk Akgul, Oleg Sidorov, Lev Givon, Allister MacLeod, Alexander D'Archangel, Andreas Hoelzlwimmer, Han Holl, Robert G. Jakabosky, Felipe Cruz, Marcus McCurdy, Mikhail Kulemin, Dr. Gergő Érdi, Pavel Zhukov, Alexander Else, Giovanni Ruggiero, Rick "Technoweenie", Daniel Lundin, Dave Hoover, Simon Jefford, Benjamin Peterson, Justin Case, Devon Weller, Richard Smith, Alexander Morland, Wadim Grasza, Michael Jakl, Uwe Dauernheim, Sebastian Nowicki, Simone Deponti, Aaron Raddon, Dan Colish, Markus Schirp, Benoit Larroque, Jonathan Palardy, Isaiah Peng, Arkadiusz Orzechowski, Umut Aydin, Matthew Horsfall, Jeremy W. Sherman, Eric Pugh, Tyler Sellon, John E. Vincent, Pavel Mitin, Min RK, Igor Wiedler, Olof Åkesson, Patrick Lucas, Heow Goodman, Senthil Palanisami, John Gallagher, Tomas Roos, Stephen McQuay, Erik Allik, Arnaud Cogoluègnes, Rob Gagnon, Dan Williams, Edward Smith, James Tucker, Kristian Kristensen, Vadim Shalts, Martin Trojer, Tom van Leeuwen, Hiten Pandya, Harm Aarts, Marc Harter, Iskren Ivov Chernev, Jay Han, Sonia Hamilton, Nathan Stocks, Naveen Palli, and Zed Shaw for their contributions to this work.</p>
<p><a name="basics"></a><br>
<a name="Chapter-Basics"></a><a name="header-7"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h2 id="toc6"><span><a href="http://zguide.zeromq.org/page:all#Chapter-Basics">Chapter 1 - Basics</a></span></h2>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-6">prev</a> <a href="http://zguide.zeromq.org/page:all#header-8">next</a></td>
</tr>
</tbody></table>
<p><a name="Fixing-the-World"></a><a name="header-8"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc7"><span><a href="http://zguide.zeromq.org/page:all#Fixing-the-World">Fixing the World</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-7">prev</a> <a href="http://zguide.zeromq.org/page:all#header-9">next</a></td>
</tr>
</tbody></table>
<p>How to explain ZeroMQ? Some of us start by saying all the wonderful things it does. <em>It's sockets on steroids. It's like mailboxes with routing. It's fast!</em> Others try to share their moment of enlightenment, that zap-pow-kaboom satori paradigm-shift moment when it all became obvious. <em>Things just become simpler. Complexity goes away. It opens the mind.</em> Others try to explain by comparison. <em>It's smaller, simpler, but still looks familiar.</em> Personally, I like to remember why we made ZeroMQ at all, because that's most likely where you, the reader, still are today.</p>
<p>Programming is science dressed up as art because most of us don't understand the physics of software and it's rarely, if ever, taught. The physics of software is not algorithms, data structures, languages and abstractions. These are just tools we make, use, throw away. The real physics of software is the physics of people—specifically, our limitations when it comes to complexity, and our desire to work together to solve large problems in pieces. This is the science of programming: make building blocks that people can understand and use <em>easily</em>, and people will work together to solve the very largest problems.</p>
<p>We live in a connected world, and modern software has to navigate this world. So the building blocks for tomorrow's very largest solutions are connected and massively parallel. It's not enough for code to be "strong and silent" any more. Code has to talk to code. Code has to be chatty, sociable, well-connected. Code has to run like the human brain, trillions of individual neurons firing off messages to each other, a massively parallel network with no central control, no single point of failure, yet able to solve immensely difficult problems. And it's no accident that the future of code looks like the human brain, because the endpoints of every network are, at some level, human brains.</p>
<p>If you've done any work with threads, protocols, or networks, you'll realize this is pretty much impossible. It's a dream. Even connecting a few programs across a few sockets is plain nasty when you start to handle real life situations. Trillions? The cost would be unimaginable. Connecting computers is so difficult that software and services to do this is a multi-billion dollar business.</p>
<p>So we live in a world where the wiring is years ahead of our ability to use it. We had a software crisis in the 1980s, when leading software engineers like Fred Brooks believed <a href="http://en.wikipedia.org/wiki/No_Silver_Bullet">there was no "Silver Bullet"</a> to "promise even one order of magnitude of improvement in productivity, reliability, or simplicity".</p>
<p>Brooks missed free and open source software, which solved that crisis, enabling us to share knowledge efficiently. Today we face another software crisis, but it's one we don't talk about much. Only the largest, richest firms can afford to create connected applications. There is a cloud, but it's proprietary. Our data and our knowledge is disappearing from our personal computers into clouds that we cannot access and with which we cannot compete. Who owns our social networks? It is like the mainframe-PC revolution in reverse.</p>
<p>We can leave the political philosophy <a href="http://cultureandempire.com/">for another book</a>. The point is that while the Internet offers the potential of massively connected code, the reality is that this is out of reach for most of us, and so large interesting problems (in health, education, economics, transport, and so on) remain unsolved because there is no way to connect the code, and thus no way to connect the brains that could work together to solve these problems.</p>
<p>There have been many attempts to solve the challenge of connected code. There are thousands of IETF specifications, each solving part of the puzzle. For application developers, HTTP is perhaps the one solution to have been simple enough to work, but it arguably makes the problem worse by encouraging developers and architects to think in terms of big servers and thin, stupid clients.</p>
<p>So today people are still connecting applications using raw UDP and TCP, proprietary protocols, HTTP, and Websockets. It remains painful, slow, hard to scale, and essentially centralized. Distributed P2P architectures are mostly for play, not work. How many applications use Skype or Bittorrent to exchange data?</p>
<p>Which brings us back to the science of programming. To fix the world, we needed to do two things. One, to solve the general problem of "how to connect any code to any code, anywhere". Two, to wrap that up in the simplest possible building blocks that people could understand and use <em>easily</em>.</p>
<p>It sounds ridiculously simple. And maybe it is. That's kind of the whole point.</p>
<p><a name="Starting-Assumptions"></a><a name="header-9"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc8"><span><a href="http://zguide.zeromq.org/page:all#Starting-Assumptions">Starting Assumptions</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-8">prev</a> <a href="http://zguide.zeromq.org/page:all#header-10">next</a></td>
</tr>
</tbody></table>
<p>We assume you are using at least version 3.2 of ZeroMQ. We assume you are using a Linux box or something similar. We assume you can read C code, more or less, as that's the default language for the examples. We assume that when we write constants like PUSH or SUBSCRIBE, you can imagine they are really called <tt>ZMQ_PUSH</tt> or <tt>ZMQ_SUBSCRIBE</tt> if the programming language needs it.</p>
<p><a name="Getting-the-Examples"></a><a name="header-10"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc9"><span><a href="http://zguide.zeromq.org/page:all#Getting-the-Examples">Getting the Examples</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-9">prev</a> <a href="http://zguide.zeromq.org/page:all#header-11">next</a></td>
</tr>
</tbody></table>
<p>The examples live in a public <a href="https://github.com/imatix/zguide">GitHub repository</a>. The simplest way to get all the examples is to clone this repository:</p>
<div class="code">
<pre><code>git clone --depth=1 https://github.com/imatix/zguide.git</code>
</pre></div>
<p>Next, browse the examples subdirectory. You'll find examples by language. If there are examples missing in a language you use, you're encouraged to <a href="http://zguide.zeromq.org/main:translate">submit a translation</a>. This is how this text became so useful, thanks to the work of many people. All examples are licensed under MIT/X11.</p>
<p><a name="Ask-and-Ye-Shall-Receive"></a><a name="header-11"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc10"><span><a href="http://zguide.zeromq.org/page:all#Ask-and-Ye-Shall-Receive">Ask and Ye Shall Receive</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-10">prev</a> <a href="http://zguide.zeromq.org/page:all#header-12">next</a></td>
</tr>
</tbody></table>
<p>So let's start with some code. We start of course with a Hello World example. We'll make a client and a server. The client sends "Hello" to the server, which replies with "World". Here's the server in C, which opens a ZeroMQ socket on port 5555, reads requests on it, and replies with "World" to each request:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">hwserver:&nbsp;Hello&nbsp;World&nbsp;server&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">hwserver:&nbsp;Hello&nbsp;World&nbsp;server&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Hello World server</span></p>
<p>#include &lt;zmq.h&gt;<br>
#include &lt;stdio.h&gt;<br>
#include &lt;unistd.h&gt;<br>
#include &lt;string.h&gt;<br>
#include &lt;assert.h&gt;</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Socket to talk to clients</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zmq_ctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>responder <span style="color:#666666">=</span> zmq_socket (context, ZMQ_REP);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> rc <span style="color:#666666">=</span> zmq_bind (responder, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5555"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (rc <span style="color:#666666">==</span> <span style="color:#666666">0</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> buffer <span style="white-space: pre-wrap;">[</span><span style="color:#666666">10</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_recv (responder, buffer, <span style="color:#666666">10</span>, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"Received Hello</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>sleep (<span style="color:#666666">1</span>);<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Do some 'work'</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_send (responder, <span style="color:#BA2121">"World"</span>, <span style="color:#666666">5</span>, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:hwserver" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:hwserver" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/clj:hwserver" target="_blank">Clojure</a> | <a href="http://zguide.zeromq.org/lisp:hwserver" target="_blank">CL</a> | <a href="http://zguide.zeromq.org/dpr:hwserver" target="_blank">Delphi</a> | <a href="http://zguide.zeromq.org/es:hwserver" target="_blank">Erlang</a> | <a href="http://zguide.zeromq.org/fsx:hwserver" target="_blank">F#</a> | <a href="http://zguide.zeromq.org/flx:hwserver" target="_blank">Felix</a> | <a href="http://zguide.zeromq.org/go:hwserver" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:hwserver" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:hwserver" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:hwserver" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:hwserver" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/js:hwserver" target="_blank">Node.js</a> | <a href="http://zguide.zeromq.org/m:hwserver" target="_blank">Objective-C</a> | <a href="http://zguide.zeromq.org/pl:hwserver" target="_blank">Perl</a> | <a href="http://zguide.zeromq.org/php:hwserver" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:hwserver" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/q:hwserver" target="_blank">Q</a> | <a href="http://zguide.zeromq.org/rkt:hwserver" target="_blank">Racket</a> | <a href="http://zguide.zeromq.org/rb:hwserver" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/scala:hwserver" target="_blank">Scala</a> | <a href="http://zguide.zeromq.org/tcl:hwserver" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | ooc</a></span>
<p><strong>Figure 2 - Request-Reply</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig2.png" alt="fig2.png" class="image"></div>
<p>The REQ-REP socket pair is in lockstep. The client issues <tt><a href="http://api.zeromq.org/3-2:zmq_send">zmq_send()</a></tt> and then <tt><a href="http://api.zeromq.org/3-2:zmq_recv">zmq_recv()</a></tt>, in a loop (or once if that's all it needs). Doing any other sequence (e.g., sending two messages in a row) will result in a return code of -1 from the <tt>send</tt> or <tt>recv</tt> call. Similarly, the service issues <tt><a href="http://api.zeromq.org/3-2:zmq_recv">zmq_recv()</a></tt> and then <tt><a href="http://api.zeromq.org/3-2:zmq_send">zmq_send()</a></tt> in that order, as often as it needs to.</p>
<p>ZeroMQ uses C as its reference language and this is the main language we'll use for examples. If you're reading this online, the link below the example takes you to translations into other programming languages. Let's compare the same server in C++:</p>
<div class="code">
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Hello World server in C++<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Binds REP socket to tcp:<span style="white-space: pre-wrap;">//</span>*:5555<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Expects "Hello" from client, replies with "World"<br>
<span style="white-space: pre-wrap;">//</span></span></span><br>
<span style="color:#BC7A00">#include &lt;zmq.hpp&gt;<br>
#include &lt;string&gt;<br>
#include &lt;iostream&gt;<br>
#ifndef _WIN32<br>
#include &lt;unistd.h&gt;<br>
#else<br>
#include &lt;windows.h&gt;</span></p>
<p><span style="color:#BC7A00">#define sleep(n)<tt><span style="white-space: pre-wrap;">    </span></tt>Sleep(n)<br>
#endif</span></p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> () {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Prepare our context and socket</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq<span style="color:#666666">::</span><span style="color:#B00040">context_t</span> context (<span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq<span style="color:#666666">::</span><span style="color:#B00040">socket_t</span> socket (context, ZMQ_REP);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>socket.bind (<span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5555"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq<span style="color:#666666">::</span><span style="color:#B00040">message_t</span> request;</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Wait for next request from client</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>socket.recv (<span style="color:#666666">&amp;</span>request);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>std<span style="color:#666666">::</span>cout <span style="color:#666666"><span style="white-space: pre-wrap;">&lt;&lt;</span></span> <span style="color:#BA2121">"Received Hello"</span> <span style="color:#666666"><span style="white-space: pre-wrap;">&lt;&lt;</span></span> std<span style="color:#666666">::</span>endl;</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Do some 'work'</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>sleep(<span style="color:#666666">1</span>);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send reply back to client</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq<span style="color:#666666">::</span><span style="color:#B00040">message_t</span> reply (<span style="color:#666666">5</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>memcpy (reply.data (), <span style="color:#BA2121">"World"</span>, <span style="color:#666666">5</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>socket.send (reply);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
<div style="text-align: right;">
<p><em>hwserver.cpp: Hello World server</em></p>
</div>
<p>You can see that the ZeroMQ API is similar in C and C++. In a language like PHP or Java, we can hide even more and the code becomes even easier to read:</p>
<div class="code">
<p><span style="color:#BC7A00">&lt;?php</span><br>
<span style="color:#408080"><span style="font-style:italic">/*<br>
*<tt><span style="white-space: pre-wrap;">  </span></tt>Hello World server<br>
*<tt><span style="white-space: pre-wrap;">  </span></tt>Binds REP socket to tcp:<span style="white-space: pre-wrap;">//</span>*:5555<br>
*<tt><span style="white-space: pre-wrap;">  </span></tt>Expects "Hello" from client, replies with "World"<br>
* @author Ian Barber &lt;ian(dot)barber(at)gmail(dot)com&gt;<br>
*/</span></span></p>
<p><span style="color:#19177C">$context</span> <span style="color:#666666">=</span> <span style="color:#008000"><strong>new</strong></span> ZMQContext(<span style="color:#666666">1</span>);</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Socket to talk to clients</em></span><br>
<span style="color:#19177C">$responder</span> <span style="color:#666666">=</span> <span style="color:#008000"><strong>new</strong></span> ZMQSocket(<span style="color:#19177C">$context</span>, ZMQ<span style="color:#666666">::</span><span style="color:#7D9029">SOCKET_REP</span>);<br>
<span style="color:#19177C">$responder</span><span style="color:#666666">-&gt;</span><span style="color:#7D9029">bind</span>(<span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5555"</span>);</p>
<p><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000"><strong>true</strong></span>) {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Wait for next request from client</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#19177C">$request</span> <span style="color:#666666">=</span> <span style="color:#19177C">$responder</span><span style="color:#666666">-&gt;</span><span style="color:#7D9029">recv</span>();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000">printf</span> (<span style="color:#BA2121">"Received request: <span style="white-space: pre-wrap;">[</span>%s<span style="white-space: pre-wrap;">]</span></span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, <span style="color:#19177C">$request</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Do some 'work'</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000">sleep</span> (<span style="color:#666666">1</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send reply back to client</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#19177C">$responder</span><span style="color:#666666">-&gt;</span><span style="color:#7D9029">send</span>(<span style="color:#BA2121">"World"</span>);<br>
}</p>
</div>
<div style="text-align: right;">
<p><em>hwserver.php: Hello World server</em></p>
</div>
<div class="code">
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Hello World server in Java<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Binds REP socket to tcp:<span style="white-space: pre-wrap;">//</span>*:5555<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Expects "Hello" from client, replies with "World"<br>
<span style="white-space: pre-wrap;">//</span></span></span></p>
<p><span style="color:#008000"><strong>import</strong></span> <span style="color:#0000FF"><strong>org.zeromq.ZMQ</strong></span><span style="color:#666666">;</span></p>
<p><span style="color:#008000"><strong>public</strong></span> <span style="color:#008000"><strong>class</strong></span> <span style="color:#0000FF"><strong>hwserver</strong></span> <span style="color:#666666">{</span></p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>public</strong></span> <span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span> <span style="color:#0000FF">main</span><span style="color:#666666">(</span>String<span style="color:#666666"><span style="white-space: pre-wrap;">[]</span></span> args<span style="color:#666666">)</span> <span style="color:#008000"><strong>throws</strong></span> Exception <span style="color:#666666">{</span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>ZMQ<span style="color:#666666">.</span><span style="color:#7D9029">Context</span> context <span style="color:#666666">=</span> ZMQ<span style="color:#666666">.</span><span style="color:#7D9029">context</span><span style="color:#666666">(</span><span style="color:#666666">1</span><span style="color:#666666">);</span></p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Socket to talk to clients</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>ZMQ<span style="color:#666666">.</span><span style="color:#7D9029">Socket</span> responder <span style="color:#666666">=</span> context<span style="color:#666666">.</span><span style="color:#7D9029">socket</span><span style="color:#666666">(</span>ZMQ<span style="color:#666666">.</span><span style="color:#7D9029">REP</span><span style="color:#666666">);</span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>responder<span style="color:#666666">.</span><span style="color:#7D9029">bind</span><span style="color:#666666">(</span><span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5555"</span><span style="color:#666666">);</span></p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>while</strong></span> <span style="color:#666666">(!</span>Thread<span style="color:#666666">.</span><span style="color:#7D9029">currentThread</span><span style="color:#666666">().</span><span style="color:#7D9029">isInterrupted</span><span style="color:#666666">())</span> <span style="color:#666666">{</span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span> Wait for next request from the client</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">byte</span><span style="color:#666666"><span style="white-space: pre-wrap;">[]</span></span> request <span style="color:#666666">=</span> responder<span style="color:#666666">.</span><span style="color:#7D9029">recv</span><span style="color:#666666">(</span><span style="color:#666666">0</span><span style="color:#666666">);</span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>System<span style="color:#666666">.</span><span style="color:#7D9029">out</span><span style="color:#666666">.</span><span style="color:#7D9029">println</span><span style="color:#666666">(</span><span style="color:#BA2121">"Received Hello"</span><span style="color:#666666">);</span></p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span> Do some 'work'</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>Thread<span style="color:#666666">.</span><span style="color:#7D9029">sleep</span><span style="color:#666666">(</span><span style="color:#666666">1000</span><span style="color:#666666">);</span></p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span> Send reply back to client</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>String reply <span style="color:#666666">=</span> <span style="color:#BA2121">"World"</span><span style="color:#666666">;</span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>responder<span style="color:#666666">.</span><span style="color:#7D9029">send</span><span style="color:#666666">(</span>reply<span style="color:#666666">.</span><span style="color:#7D9029">getBytes</span><span style="color:#666666">(),</span> <span style="color:#666666">0</span><span style="color:#666666">);</span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#666666">}</span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>responder<span style="color:#666666">.</span><span style="color:#7D9029">close</span><span style="color:#666666">();</span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>context<span style="color:#666666">.</span><span style="color:#7D9029">term</span><span style="color:#666666">();</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#666666">}</span><br>
<span style="color:#666666">}</span></p>
</div>
<div style="text-align: right;">
<p><em>hwserver.java: Hello World server</em></p>
</div>
<p>The server in other languages:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">hwserver:&nbsp;Hello&nbsp;World&nbsp;server&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">hwserver:&nbsp;Hello&nbsp;World&nbsp;server&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Hello World server</span></p>
<p>#include &lt;zmq.h&gt;<br>
#include &lt;stdio.h&gt;<br>
#include &lt;unistd.h&gt;<br>
#include &lt;string.h&gt;<br>
#include &lt;assert.h&gt;</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Socket to talk to clients</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zmq_ctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>responder <span style="color:#666666">=</span> zmq_socket (context, ZMQ_REP);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> rc <span style="color:#666666">=</span> zmq_bind (responder, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5555"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (rc <span style="color:#666666">==</span> <span style="color:#666666">0</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> buffer <span style="white-space: pre-wrap;">[</span><span style="color:#666666">10</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_recv (responder, buffer, <span style="color:#666666">10</span>, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"Received Hello</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>sleep (<span style="color:#666666">1</span>);<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Do some 'work'</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_send (responder, <span style="color:#BA2121">"World"</span>, <span style="color:#666666">5</span>, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:hwserver" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:hwserver" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/clj:hwserver" target="_blank">Clojure</a> | <a href="http://zguide.zeromq.org/lisp:hwserver" target="_blank">CL</a> | <a href="http://zguide.zeromq.org/dpr:hwserver" target="_blank">Delphi</a> | <a href="http://zguide.zeromq.org/es:hwserver" target="_blank">Erlang</a> | <a href="http://zguide.zeromq.org/fsx:hwserver" target="_blank">F#</a> | <a href="http://zguide.zeromq.org/flx:hwserver" target="_blank">Felix</a> | <a href="http://zguide.zeromq.org/go:hwserver" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:hwserver" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:hwserver" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:hwserver" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:hwserver" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/js:hwserver" target="_blank">Node.js</a> | <a href="http://zguide.zeromq.org/m:hwserver" target="_blank">Objective-C</a> | <a href="http://zguide.zeromq.org/pl:hwserver" target="_blank">Perl</a> | <a href="http://zguide.zeromq.org/php:hwserver" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:hwserver" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/q:hwserver" target="_blank">Q</a> | <a href="http://zguide.zeromq.org/rkt:hwserver" target="_blank">Racket</a> | <a href="http://zguide.zeromq.org/rb:hwserver" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/scala:hwserver" target="_blank">Scala</a> | <a href="http://zguide.zeromq.org/tcl:hwserver" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | ooc</a></span>
<p>Here's the client code:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">hwclient:&nbsp;Hello&nbsp;World&nbsp;client&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">hwclient:&nbsp;Hello&nbsp;World&nbsp;client&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Hello World client<br>
#include &lt;zmq.h&gt;<br>
#include &lt;string.h&gt;<br>
#include &lt;stdio.h&gt;<br>
#include &lt;unistd.h&gt;</span></p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"Connecting to hello world server…</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zmq_ctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>requester <span style="color:#666666">=</span> zmq_socket (context, ZMQ_REQ);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_connect (requester, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5555"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> request_nbr;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (request_nbr <span style="color:#666666">=</span> <span style="color:#666666">0</span>; request_nbr <span style="color:#666666">!=</span> <span style="color:#666666">10</span>; request_nbr<span style="color:#666666">++</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> buffer <span style="white-space: pre-wrap;">[</span><span style="color:#666666">10</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"Sending Hello %d…</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, request_nbr);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_send (requester, <span style="color:#BA2121">"Hello"</span>, <span style="color:#666666">5</span>, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_recv (requester, buffer, <span style="color:#666666">10</span>, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"Received World %d</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, request_nbr);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (requester);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_ctx_destroy (context);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:hwclient" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:hwclient" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/clj:hwclient" target="_blank">Clojure</a> | <a href="http://zguide.zeromq.org/lisp:hwclient" target="_blank">CL</a> | <a href="http://zguide.zeromq.org/dpr:hwclient" target="_blank">Delphi</a> | <a href="http://zguide.zeromq.org/es:hwclient" target="_blank">Erlang</a> | <a href="http://zguide.zeromq.org/fsx:hwclient" target="_blank">F#</a> | <a href="http://zguide.zeromq.org/flx:hwclient" target="_blank">Felix</a> | <a href="http://zguide.zeromq.org/go:hwclient" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:hwclient" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:hwclient" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:hwclient" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:hwclient" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/js:hwclient" target="_blank">Node.js</a> | <a href="http://zguide.zeromq.org/m:hwclient" target="_blank">Objective-C</a> | <a href="http://zguide.zeromq.org/pl:hwclient" target="_blank">Perl</a> | <a href="http://zguide.zeromq.org/php:hwclient" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:hwclient" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/q:hwclient" target="_blank">Q</a> | <a href="http://zguide.zeromq.org/rkt:hwclient" target="_blank">Racket</a> | <a href="http://zguide.zeromq.org/rb:hwclient" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/scala:hwclient" target="_blank">Scala</a> | <a href="http://zguide.zeromq.org/tcl:hwclient" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | ooc</a></span>
<p>Now this looks too simple to be realistic, but ZeroMQ sockets have, as we already learned, superpowers. You could throw thousands of clients at this server, all at once, and it would continue to work happily and quickly. For fun, try starting the client and <em>then</em> starting the server, see how it all still works, then think for a second what this means.</p>
<p>Let us explain briefly what these two programs are actually doing. They create a ZeroMQ context to work with, and a socket. Don't worry what the words mean. You'll pick it up. The server binds its REP (reply) socket to port 5555. The server waits for a request in a loop, and responds each time with a reply. The client sends a request and reads the reply back from the server.</p>
<p>If you kill the server (Ctrl-C) and restart it, the client won't recover properly. Recovering from crashing processes isn't quite that easy. Making a reliable request-reply flow is complex enough that we won't cover it until <a href="http://zguide.zeromq.org/page:all#reliable-request-reply">Chapter 4 - Reliable Request-Reply Patterns</a>.</p>
<p>There is a lot happening behind the scenes but what matters to us programmers is how short and sweet the code is, and how often it doesn't crash, even under a heavy load. This is the request-reply pattern, probably the simplest way to use ZeroMQ. It maps to RPC and the classic client/server model.</p>
<p><a name="A-Minor-Note-on-Strings"></a><a name="header-12"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc11"><span><a href="http://zguide.zeromq.org/page:all#A-Minor-Note-on-Strings">A Minor Note on Strings</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-11">prev</a> <a href="http://zguide.zeromq.org/page:all#header-13">next</a></td>
</tr>
</tbody></table>
<p>ZeroMQ doesn't know anything about the data you send except its size in bytes. That means you are responsible for formatting it safely so that applications can read it back. Doing this for objects and complex data types is a job for specialized libraries like Protocol Buffers. But even for strings, you need to take care.</p>
<p>In C and some other languages, strings are terminated with a null byte. We could send a string like "HELLO" with that extra null byte:</p>
<div class="code">
<p>zmq_send (requester, <span style="color:#BA2121">"Hello"</span>, <span style="color:#666666">6</span>, <span style="color:#666666">0</span>);</p>
</div>
<p>However, if you send a string from another language, it probably will not include that null byte. For example, when we send that same string in Python, we do this:</p>
<div class="code">
<p>socket<span style="color:#666666">.</span>send (<span style="color:#BA2121">"Hello"</span>)</p>
</div>
<p>Then what goes onto the wire is a length (one byte for shorter strings) and the string contents as individual characters.</p>
<p><strong>Figure 3 - A ZeroMQ string</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig3.png" alt="fig3.png" class="image"></div>
<p>And if you read this from a C program, you will get something that looks like a string, and might by accident act like a string (if by luck the five bytes find themselves followed by an innocently lurking null), but isn't a proper string. When your client and server don't agree on the string format, you will get weird results.</p>
<p>When you receive string data from ZeroMQ in C, you simply cannot trust that it's safely terminated. Every single time you read a string, you should allocate a new buffer with space for an extra byte, copy the string, and terminate it properly with a null.</p>
<p>So let's establish the rule that <strong>ZeroMQ strings are length-specified and are sent on the wire <em>without</em> a trailing null</strong>. In the simplest case (and we'll do this in our examples), a ZeroMQ string maps neatly to a ZeroMQ message frame, which looks like the above figure—a length and some bytes.</p>
<p>Here is what we need to do, in C, to receive a ZeroMQ string and deliver it to the application as a valid C string:</p>
<div class="code">
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Receive ZeroMQ string from socket and convert into C string<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Chops string at 255 chars, if it's longer</span></span><br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">char</span> <span style="color:#666666">*</span><br>
<span style="color:#0000FF">s_recv</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>socket) {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> buffer <span style="white-space: pre-wrap;">[</span><span style="color:#666666">256</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> size <span style="color:#666666">=</span> zmq_recv (socket, buffer, <span style="color:#666666">255</span>, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (size <span style="color:#666666">==</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#008000">NULL</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (size <span style="color:#666666">&gt;</span> <span style="color:#666666">255</span>)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>size <span style="color:#666666">=</span> <span style="color:#666666">255</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>buffer <span style="white-space: pre-wrap;">[</span>size<span style="white-space: pre-wrap;">]</span> <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> strdup (buffer);<br>
}</p>
</div>
<p>This makes a handy helper function and in the spirit of making things we can reuse profitably, let's write a similar <tt>s_send</tt> function that sends strings in the correct ZeroMQ format, and package this into a header file we can reuse.</p>
<p>The result is <tt>zhelpers.h</tt>, which lets us write sweeter and shorter ZeroMQ applications in C. It is a fairly long source, and only fun for C developers, so <a href="https://github.com/imatix/zguide/blob/master/examples/C/zhelpers.h">read it at leisure</a>.</p>
<p><a name="Version-Reporting"></a><a name="header-13"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc12"><span><a href="http://zguide.zeromq.org/page:all#Version-Reporting">Version Reporting</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-12">prev</a> <a href="http://zguide.zeromq.org/page:all#header-14">next</a></td>
</tr>
</tbody></table>
<p>ZeroMQ does come in several versions and quite often, if you hit a problem, it'll be something that's been fixed in a later version. So it's a useful trick to know <em>exactly</em> what version of ZeroMQ you're actually linking with.</p>
<p>Here is a tiny program that does that:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">version:&nbsp;ZeroMQ&nbsp;version&nbsp;reporting&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">version:&nbsp;ZeroMQ&nbsp;version&nbsp;reporting&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Report 0MQ version</span></p>
<p>#include &lt;zmq.h&gt;</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> major, minor, patch;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_version (<span style="color:#666666">&amp;</span>major, <span style="color:#666666">&amp;</span>minor, <span style="color:#666666">&amp;</span>patch);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"Current 0MQ version is %d.%d.%d</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, major, minor, patch);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:version" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:version" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/clj:version" target="_blank">Clojure</a> | <a href="http://zguide.zeromq.org/lisp:version" target="_blank">CL</a> | <a href="http://zguide.zeromq.org/dpr:version" target="_blank">Delphi</a> | <a href="http://zguide.zeromq.org/es:version" target="_blank">Erlang</a> | <a href="http://zguide.zeromq.org/fsx:version" target="_blank">F#</a> | <a href="http://zguide.zeromq.org/flx:version" target="_blank">Felix</a> | <a href="http://zguide.zeromq.org/go:version" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:version" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/java:version" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:version" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/js:version" target="_blank">Node.js</a> | <a href="http://zguide.zeromq.org/m:version" target="_blank">Objective-C</a> | <a href="http://zguide.zeromq.org/pl:version" target="_blank">Perl</a> | <a href="http://zguide.zeromq.org/php:version" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:version" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/q:version" target="_blank">Q</a> | <a href="http://zguide.zeromq.org/rb:version" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/scala:version" target="_blank">Scala</a> | <a href="http://zguide.zeromq.org/tcl:version" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | Haxe | ooc | Racket</a></span>
<p><a name="Getting-the-Message-Out"></a><a name="header-14"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc13"><span><a href="http://zguide.zeromq.org/page:all#Getting-the-Message-Out">Getting the Message Out</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-13">prev</a> <a href="http://zguide.zeromq.org/page:all#header-15">next</a></td>
</tr>
</tbody></table>
<p>The second classic pattern is one-way data distribution, in which a server pushes updates to a set of clients. Let's see an example that pushes out weather updates consisting of a zip code, temperature, and relative humidity. We'll generate random values, just like the real weather stations do.</p>
<p>Here's the server. We'll use port 5556 for this application:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">wuserver:&nbsp;Weather&nbsp;update&nbsp;server&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">wuserver:&nbsp;Weather&nbsp;update&nbsp;server&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Weather update server<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Binds PUB socket to tcp:<span style="white-space: pre-wrap;">//</span>*:5556<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Publishes random weather updates</span></p>
<p>#include "zhelpers.h"</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Prepare our context and publisher</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zmq_ctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>publisher <span style="color:#666666">=</span> zmq_socket (context, ZMQ_PUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> rc <span style="color:#666666">=</span> zmq_bind (publisher, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5556"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (rc <span style="color:#666666">==</span> <span style="color:#666666">0</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Initialize random number generator</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>srandom ((<span style="color:#B00040">unsigned</span>) time (<span style="color:#008000">NULL</span>));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Get values that will fool the boss</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> zipcode, temperature, relhumidity;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zipcode<tt><span style="white-space: pre-wrap;">     </span></tt><span style="color:#666666">=</span> randof (<span style="color:#666666">100000</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>temperature <span style="color:#666666">=</span> randof (<span style="color:#666666">215</span>) <span style="color:#666666">-</span> <span style="color:#666666">80</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>relhumidity <span style="color:#666666">=</span> randof (<span style="color:#666666">50</span>) <span style="color:#666666">+</span> <span style="color:#666666">10</span>;</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send message to all subscribers</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> update <span style="white-space: pre-wrap;">[</span><span style="color:#666666">20</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>sprintf (update, <span style="color:#BA2121">"%05d %d %d"</span>, zipcode, temperature, relhumidity);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>s_send (publisher, update);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (publisher);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_ctx_destroy (context);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:wuserver" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:wuserver" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/clj:wuserver" target="_blank">Clojure</a> | <a href="http://zguide.zeromq.org/lisp:wuserver" target="_blank">CL</a> | <a href="http://zguide.zeromq.org/dpr:wuserver" target="_blank">Delphi</a> | <a href="http://zguide.zeromq.org/es:wuserver" target="_blank">Erlang</a> | <a href="http://zguide.zeromq.org/fsx:wuserver" target="_blank">F#</a> | <a href="http://zguide.zeromq.org/flx:wuserver" target="_blank">Felix</a> | <a href="http://zguide.zeromq.org/go:wuserver" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:wuserver" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:wuserver" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:wuserver" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:wuserver" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/js:wuserver" target="_blank">Node.js</a> | <a href="http://zguide.zeromq.org/m:wuserver" target="_blank">Objective-C</a> | <a href="http://zguide.zeromq.org/pl:wuserver" target="_blank">Perl</a> | <a href="http://zguide.zeromq.org/php:wuserver" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:wuserver" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rkt:wuserver" target="_blank">Racket</a> | <a href="http://zguide.zeromq.org/rb:wuserver" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/scala:wuserver" target="_blank">Scala</a> | <a href="http://zguide.zeromq.org/tcl:wuserver" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | ooc | Q</a></span>
<p>There's no start and no end to this stream of updates, it's like a never ending broadcast.</p>
<p>Here is the client application, which listens to the stream of updates and grabs anything to do with a specified zip code, by default New York City because that's a great place to start any adventure:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">wuclient:&nbsp;Weather&nbsp;update&nbsp;client&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">wuclient:&nbsp;Weather&nbsp;update&nbsp;client&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Weather update client<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Connects SUB socket to tcp:<span style="white-space: pre-wrap;">//</span>localhost:5556<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Collects weather updates and finds avg temp in zipcode</span></p>
<p>#include "zhelpers.h"</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">int</span> argc, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>argv <span style="white-space: pre-wrap;">[]</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Socket to talk to server</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"Collecting updates from weather server…</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zmq_ctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>subscriber <span style="color:#666666">=</span> zmq_socket (context, ZMQ_SUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> rc <span style="color:#666666">=</span> zmq_connect (subscriber, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5556"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (rc <span style="color:#666666">==</span> <span style="color:#666666">0</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Subscribe to zipcode, default is NYC, 10001</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>filter <span style="color:#666666">=</span> (argc <span style="color:#666666">&gt;</span> <span style="color:#666666">1</span>)<span style="color:#666666">?</span> argv <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span><span style="color:#666666">:</span> <span style="color:#BA2121">"10001 "</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>rc <span style="color:#666666">=</span> zmq_setsockopt (subscriber, ZMQ_SUBSCRIBE,<br>
<tt><span style="white-space: pre-wrap;">                         </span></tt>filter, strlen (filter));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (rc <span style="color:#666666">==</span> <span style="color:#666666">0</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Process 100 updates</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> update_nbr;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">long</span> total_temp <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (update_nbr <span style="color:#666666">=</span> <span style="color:#666666">0</span>; update_nbr <span style="color:#666666">&lt;</span> <span style="color:#666666">100</span>; update_nbr<span style="color:#666666">++</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>string <span style="color:#666666">=</span> s_recv (subscriber);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> zipcode, temperature, relhumidity;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>sscanf (string, <span style="color:#BA2121">"%d %d %d"</span>,<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#666666">&amp;</span>zipcode, <span style="color:#666666">&amp;</span>temperature, <span style="color:#666666">&amp;</span>relhumidity);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>total_temp <span style="color:#666666">+=</span> temperature;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (string);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"Average temperature for zipcode '%s' was %dF</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>,<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>filter, (<span style="color:#B00040">int</span>) (total_temp <span style="color:#666666">/</span> update_nbr));</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (subscriber);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_ctx_destroy (context);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:wuclient" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:wuclient" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/clj:wuclient" target="_blank">Clojure</a> | <a href="http://zguide.zeromq.org/lisp:wuclient" target="_blank">CL</a> | <a href="http://zguide.zeromq.org/dpr:wuclient" target="_blank">Delphi</a> | <a href="http://zguide.zeromq.org/es:wuclient" target="_blank">Erlang</a> | <a href="http://zguide.zeromq.org/fsx:wuclient" target="_blank">F#</a> | <a href="http://zguide.zeromq.org/flx:wuclient" target="_blank">Felix</a> | <a href="http://zguide.zeromq.org/go:wuclient" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:wuclient" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:wuclient" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:wuclient" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:wuclient" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/js:wuclient" target="_blank">Node.js</a> | <a href="http://zguide.zeromq.org/m:wuclient" target="_blank">Objective-C</a> | <a href="http://zguide.zeromq.org/pl:wuclient" target="_blank">Perl</a> | <a href="http://zguide.zeromq.org/php:wuclient" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:wuclient" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rkt:wuclient" target="_blank">Racket</a> | <a href="http://zguide.zeromq.org/rb:wuclient" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/scala:wuclient" target="_blank">Scala</a> | <a href="http://zguide.zeromq.org/tcl:wuclient" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | ooc | Q</a></span>
<p><strong>Figure 4 - Publish-Subscribe</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig4.png" alt="fig4.png" class="image"></div>
<p>Note that when you use a SUB socket you <strong>must</strong> set a subscription using <tt><a href="http://api.zeromq.org/3-2:zmq_setsockopt">zmq_setsockopt()</a></tt> and SUBSCRIBE, as in this code. If you don't set any subscription, you won't get any messages. It's a common mistake for beginners. The subscriber can set many subscriptions, which are added together. That is, if an update matches ANY subscription, the subscriber receives it. The subscriber can also cancel specific subscriptions. A subscription is often, but not necessarily a printable string. See <tt><a href="http://api.zeromq.org/3-2:zmq_setsockopt">zmq_setsockopt()</a></tt> for how this works.</p>
<p>The PUB-SUB socket pair is asynchronous. The client does <tt><a href="http://api.zeromq.org/3-2:zmq_recv">zmq_recv()</a></tt>, in a loop (or once if that's all it needs). Trying to send a message to a SUB socket will cause an error. Similarly, the service does <tt><a href="http://api.zeromq.org/3-2:zmq_send">zmq_send()</a></tt> as often as it needs to, but must not do <tt><a href="http://api.zeromq.org/3-2:zmq_recv">zmq_recv()</a></tt> on a PUB socket.</p>
<p>In theory with ZeroMQ sockets, it does not matter which end connects and which end binds. However, in practice there are undocumented differences that I'll come to later. For now, bind the PUB and connect the SUB, unless your network design makes that impossible.</p>
<p>There is one more important thing to know about PUB-SUB sockets: you do not know precisely when a subscriber starts to get messages. Even if you start a subscriber, wait a while, and then start the publisher, <strong>the subscriber will always miss the first messages that the publisher sends</strong>. This is because as the subscriber connects to the publisher (something that takes a small but non-zero time), the publisher may already be sending messages out.</p>
<p>This "slow joiner" symptom hits enough people often enough that we're going to explain it in detail. Remember that ZeroMQ does asynchronous I/O, i.e., in the background. Say you have two nodes doing this, in this order:</p>
<ul>
<li>Subscriber connects to an endpoint and receives and counts messages.</li>
<li>Publisher binds to an endpoint and immediately sends 1,000 messages.</li>
</ul>
<p>Then the subscriber will most likely not receive anything. You'll blink, check that you set a correct filter and try again, and the subscriber will still not receive anything.</p>
<p>Making a TCP connection involves to and from handshaking that takes several milliseconds depending on your network and the number of hops between peers. In that time, ZeroMQ can send many messages. For sake of argument assume it takes 5 msecs to establish a connection, and that same link can handle 1M messages per second. During the 5 msecs that the subscriber is connecting to the publisher, it takes the publisher only 1 msec to send out those 1K messages.</p>
<p>In <a href="http://zguide.zeromq.org/page:all#sockets-and-patterns">Chapter 2 - Sockets and Patterns</a> we'll explain how to synchronize a publisher and subscribers so that you don't start to publish data until the subscribers really are connected and ready. There is a simple and stupid way to delay the publisher, which is to sleep. Don't do this in a real application, though, because it is extremely fragile as well as inelegant and slow. Use sleeps to prove to yourself what's happening, and then wait for <a href="http://zguide.zeromq.org/page:all#sockets-and-patterns">Chapter 2 - Sockets and Patterns</a> to see how to do this right.</p>
<p>The alternative to synchronization is to simply assume that the published data stream is infinite and has no start and no end. One also assumes that the subscriber doesn't care what transpired before it started up. This is how we built our weather client example.</p>
<p>So the client subscribes to its chosen zip code and collects 100 updates for that zip code. That means about ten million updates from the server, if zip codes are randomly distributed. You can start the client, and then the server, and the client will keep working. You can stop and restart the server as often as you like, and the client will keep working. When the client has collected its hundred updates, it calculates the average, prints it, and exits.</p>
<p>Some points about the publish-subscribe (pub-sub) pattern:</p>
<ul>
<li>A subscriber can connect to more than one publisher, using one connect call each time. Data will then arrive and be interleaved ("fair-queued") so that no single publisher drowns out the others.</li>
</ul>
<ul>
<li>If a publisher has no connected subscribers, then it will simply drop all messages.</li>
</ul>
<ul>
<li>If you're using TCP and a subscriber is slow, messages will queue up on the publisher. We'll look at how to protect publishers against this using the "high-water mark" later.</li>
</ul>
<ul>
<li>From ZeroMQ v3.x, filtering happens at the publisher side when using a connected protocol (<tt>tcp:<span style="white-space: pre-wrap;">//</span></tt> or <tt>ipc:<span style="white-space: pre-wrap;">//</span></tt>). Using the <tt>epgm:<span style="white-space: pre-wrap;">//</span></tt> protocol, filtering happens at the subscriber side. In ZeroMQ v2.x, all filtering happened at the subscriber side.</li>
</ul>
<p>This is how long it takes to receive and filter 10M messages on my laptop, which is an 2011-era Intel i5, decent but nothing special:</p>
<div class="code">
<pre><code>$ time wuclient
Collecting updates from weather server...
Average temperature for zipcode '10001 ' was 28F

real    0m4.470s
user    0m0.000s
sys     0m0.008s</code>
</pre></div>
<p><a name="Divide-and-Conquer"></a><a name="header-15"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc14"><span><a href="http://zguide.zeromq.org/page:all#Divide-and-Conquer">Divide and Conquer</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-14">prev</a> <a href="http://zguide.zeromq.org/page:all#header-16">next</a></td>
</tr>
</tbody></table>
<p><strong>Figure 5 - Parallel Pipeline</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig5.png" alt="fig5.png" class="image"></div>
<p>As a final example (you are surely getting tired of juicy code and want to delve back into philological discussions about comparative abstractive norms), let's do a little supercomputing. Then coffee. Our supercomputing application is a fairly typical parallel processing model. We have:</p>
<ul>
<li>A ventilator that produces tasks that can be done in parallel</li>
<li>A set of workers that process tasks</li>
<li>A sink that collects results back from the worker processes</li>
</ul>
<p>In reality, workers run on superfast boxes, perhaps using GPUs (graphic processing units) to do the hard math. Here is the ventilator. It generates 100 tasks, each a message telling the worker to sleep for some number of milliseconds:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">taskvent:&nbsp;Parallel&nbsp;task&nbsp;ventilator&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">taskvent:&nbsp;Parallel&nbsp;task&nbsp;ventilator&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Task ventilator<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Binds PUSH socket to tcp:<span style="white-space: pre-wrap;">//</span>localhost:5557<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Sends batch of tasks to workers via that socket</span></p>
<p>#include "zhelpers.h"</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zmq_ctx_new ();</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Socket to send messages on</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>sender <span style="color:#666666">=</span> zmq_socket (context, ZMQ_PUSH);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_bind (sender, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5557"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Socket to send start of batch message on</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>sink <span style="color:#666666">=</span> zmq_socket (context, ZMQ_PUSH);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_connect (sink, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5558"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"Press Enter when the workers are ready: "</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>getchar ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"Sending tasks to workers…</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The first message is "0" and signals start of batch</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_send (sink, <span style="color:#BA2121">"0"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Initialize random number generator</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>srandom ((<span style="color:#B00040">unsigned</span>) time (<span style="color:#008000">NULL</span>));</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send 100 tasks</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> task_nbr;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> total_msec <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<tt><span style="white-space: pre-wrap;">     </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Total expected cost in msecs</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (task_nbr <span style="color:#666666">=</span> <span style="color:#666666">0</span>; task_nbr <span style="color:#666666">&lt;</span> <span style="color:#666666">100</span>; task_nbr<span style="color:#666666">++</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> workload;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Random workload from 1 to 100msecs</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>workload <span style="color:#666666">=</span> randof (<span style="color:#666666">100</span>) <span style="color:#666666">+</span> <span style="color:#666666">1</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>total_msec <span style="color:#666666">+=</span> workload;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> string <span style="white-space: pre-wrap;">[</span><span style="color:#666666">10</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>sprintf (string, <span style="color:#BA2121">"%d"</span>, workload);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>s_send (sender, string);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"Total expected cost: %d msec</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, total_msec);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (sink);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (sender);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_ctx_destroy (context);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:taskvent" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:taskvent" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/clj:taskvent" target="_blank">Clojure</a> | <a href="http://zguide.zeromq.org/lisp:taskvent" target="_blank">CL</a> | <a href="http://zguide.zeromq.org/dpr:taskvent" target="_blank">Delphi</a> | <a href="http://zguide.zeromq.org/es:taskvent" target="_blank">Erlang</a> | <a href="http://zguide.zeromq.org/fsx:taskvent" target="_blank">F#</a> | <a href="http://zguide.zeromq.org/flx:taskvent" target="_blank">Felix</a> | <a href="http://zguide.zeromq.org/go:taskvent" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:taskvent" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:taskvent" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:taskvent" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:taskvent" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/js:taskvent" target="_blank">Node.js</a> | <a href="http://zguide.zeromq.org/m:taskvent" target="_blank">Objective-C</a> | <a href="http://zguide.zeromq.org/pl:taskvent" target="_blank">Perl</a> | <a href="http://zguide.zeromq.org/php:taskvent" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:taskvent" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rb:taskvent" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/scala:taskvent" target="_blank">Scala</a> | <a href="http://zguide.zeromq.org/tcl:taskvent" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | ooc | Q | Racket</a></span>
<p>Here is the worker application. It receives a message, sleeps for that number of seconds, and then signals that it's finished:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">taskwork:&nbsp;Parallel&nbsp;task&nbsp;worker&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">taskwork:&nbsp;Parallel&nbsp;task&nbsp;worker&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Task worker<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Connects PULL socket to tcp:<span style="white-space: pre-wrap;">//</span>localhost:5557<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Collects workloads from ventilator via that socket<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Connects PUSH socket to tcp:<span style="white-space: pre-wrap;">//</span>localhost:5558<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Sends results to sink via that socket</span></p>
<p>#include "zhelpers.h"</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Socket to receive messages on</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zmq_ctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>receiver <span style="color:#666666">=</span> zmq_socket (context, ZMQ_PULL);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_connect (receiver, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5557"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Socket to send messages to</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>sender <span style="color:#666666">=</span> zmq_socket (context, ZMQ_PUSH);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_connect (sender, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5558"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Process tasks forever</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>string <span style="color:#666666">=</span> s_recv (receiver);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"%s."</span>, string);<tt><span style="white-space: pre-wrap;">     </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Show progress</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>fflush (stdout);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>s_sleep (atoi (string));<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Do the work</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (string);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>s_send (sender, <span style="color:#BA2121">""</span>);<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send results to sink</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (receiver);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (sender);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_ctx_destroy (context);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:taskwork" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:taskwork" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/clj:taskwork" target="_blank">Clojure</a> | <a href="http://zguide.zeromq.org/lisp:taskwork" target="_blank">CL</a> | <a href="http://zguide.zeromq.org/dpr:taskwork" target="_blank">Delphi</a> | <a href="http://zguide.zeromq.org/es:taskwork" target="_blank">Erlang</a> | <a href="http://zguide.zeromq.org/fsx:taskwork" target="_blank">F#</a> | <a href="http://zguide.zeromq.org/flx:taskwork" target="_blank">Felix</a> | <a href="http://zguide.zeromq.org/go:taskwork" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:taskwork" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:taskwork" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:taskwork" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:taskwork" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/js:taskwork" target="_blank">Node.js</a> | <a href="http://zguide.zeromq.org/m:taskwork" target="_blank">Objective-C</a> | <a href="http://zguide.zeromq.org/pl:taskwork" target="_blank">Perl</a> | <a href="http://zguide.zeromq.org/php:taskwork" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:taskwork" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rb:taskwork" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/scala:taskwork" target="_blank">Scala</a> | <a href="http://zguide.zeromq.org/tcl:taskwork" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | ooc | Q | Racket</a></span>
<p>Here is the sink application. It collects the 100 tasks, then calculates how long the overall processing took, so we can confirm that the workers really were running in parallel if there are more than one of them:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">tasksink:&nbsp;Parallel&nbsp;task&nbsp;sink&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">tasksink:&nbsp;Parallel&nbsp;task&nbsp;sink&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Task sink<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Binds PULL socket to tcp:<span style="white-space: pre-wrap;">//</span>localhost:5558<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Collects results from workers via that socket</span></p>
<p>#include "zhelpers.h"</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Prepare our context and socket</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zmq_ctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>receiver <span style="color:#666666">=</span> zmq_socket (context, ZMQ_PULL);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_bind (receiver, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5558"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Wait for start of batch</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>string <span style="color:#666666">=</span> s_recv (receiver);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>free (string);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Start our clock now</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int64_t</span> start_time <span style="color:#666666">=</span> s_clock ();</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Process 100 confirmations</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> task_nbr;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (task_nbr <span style="color:#666666">=</span> <span style="color:#666666">0</span>; task_nbr <span style="color:#666666">&lt;</span> <span style="color:#666666">100</span>; task_nbr<span style="color:#666666">++</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>string <span style="color:#666666">=</span> s_recv (receiver);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (string);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> ((task_nbr <span style="color:#666666">/</span> <span style="color:#666666">10</span>) <span style="color:#666666">*</span> <span style="color:#666666">10</span> <span style="color:#666666">==</span> task_nbr)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">":"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"."</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>fflush (stdout);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Calculate and report duration of batch</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"Total elapsed time: %d msec</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>,<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>(<span style="color:#B00040">int</span>) (s_clock () <span style="color:#666666">-</span> start_time));</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (receiver);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_ctx_destroy (context);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:tasksink" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:tasksink" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/clj:tasksink" target="_blank">Clojure</a> | <a href="http://zguide.zeromq.org/lisp:tasksink" target="_blank">CL</a> | <a href="http://zguide.zeromq.org/dpr:tasksink" target="_blank">Delphi</a> | <a href="http://zguide.zeromq.org/es:tasksink" target="_blank">Erlang</a> | <a href="http://zguide.zeromq.org/fsx:tasksink" target="_blank">F#</a> | <a href="http://zguide.zeromq.org/flx:tasksink" target="_blank">Felix</a> | <a href="http://zguide.zeromq.org/go:tasksink" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:tasksink" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:tasksink" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:tasksink" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:tasksink" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/js:tasksink" target="_blank">Node.js</a> | <a href="http://zguide.zeromq.org/m:tasksink" target="_blank">Objective-C</a> | <a href="http://zguide.zeromq.org/pl:tasksink" target="_blank">Perl</a> | <a href="http://zguide.zeromq.org/php:tasksink" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:tasksink" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rb:tasksink" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/scala:tasksink" target="_blank">Scala</a> | <a href="http://zguide.zeromq.org/tcl:tasksink" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | ooc | Q | Racket</a></span>
<p>The average cost of a batch is 5 seconds. When we start 1, 2, or 4 workers we get results like this from the sink:</p>
<ul>
<li>1 worker: total elapsed time: 5034 msecs.</li>
<li>2 workers: total elapsed time: 2421 msecs.</li>
<li>4 workers: total elapsed time: 1018 msecs.</li>
</ul>
<p>Let's look at some aspects of this code in more detail:</p>
<ul>
<li>The workers connect upstream to the ventilator, and downstream to the sink. This means you can add workers arbitrarily. If the workers bound to their endpoints, you would need (a) more endpoints and (b) to modify the ventilator and/or the sink each time you added a worker. We say that the ventilator and sink are <em>stable</em> parts of our architecture and the workers are <em>dynamic</em> parts of it.</li>
</ul>
<ul>
<li>We have to synchronize the start of the batch with all workers being up and running. This is a fairly common gotcha in ZeroMQ and there is no easy solution. The <tt>zmq_connect</tt> method takes a certain time. So when a set of workers connect to the ventilator, the first one to successfully connect will get a whole load of messages in that short time while the others are also connecting. If you don't synchronize the start of the batch somehow, the system won't run in parallel at all. Try removing the wait in the ventilator, and see what happens.</li>
</ul>
<ul>
<li>The ventilator's PUSH socket distributes tasks to workers (assuming they are all connected <em>before</em> the batch starts going out) evenly. This is called <em>load balancing</em> and it's something we'll look at again in more detail.</li>
</ul>
<ul>
<li>The sink's PULL socket collects results from workers evenly. This is called <em>fair-queuing</em>.</li>
</ul>
<p><strong>Figure 6 - Fair Queuing</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig6.png" alt="fig6.png" class="image"></div>
<p>The pipeline pattern also exhibits the "slow joiner" syndrome, leading to accusations that PUSH sockets don't load balance properly. If you are using PUSH and PULL, and one of your workers gets way more messages than the others, it's because that PULL socket has joined faster than the others, and grabs a lot of messages before the others manage to connect. If you want proper load balancing, you probably want to look at the load balancing pattern in <a href="http://zguide.zeromq.org/page:all#advanced-request-reply">Chapter 3 - Advanced Request-Reply Patterns</a>.</p>
<p><a name="Programming-with-ZeroMQ"></a><a name="header-16"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc15"><span><a href="http://zguide.zeromq.org/page:all#Programming-with-ZeroMQ">Programming with ZeroMQ</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-15">prev</a> <a href="http://zguide.zeromq.org/page:all#header-17">next</a></td>
</tr>
</tbody></table>
<p>Having seen some examples, you must be eager to start using ZeroMQ in some apps. Before you start that, take a deep breath, chillax, and reflect on some basic advice that will save you much stress and confusion.</p>
<ul>
<li>Learn ZeroMQ step-by-step. It's just one simple API, but it hides a world of possibilities. Take the possibilities slowly and master each one.</li>
</ul>
<ul>
<li>Write nice code. Ugly code hides problems and makes it hard for others to help you. You might get used to meaningless variable names, but people reading your code won't. Use names that are real words, that say something other than "I'm too careless to tell you what this variable is really for". Use consistent indentation and clean layout. Write nice code and your world will be more comfortable.</li>
</ul>
<ul>
<li>Test what you make as you make it. When your program doesn't work, you should know what five lines are to blame. This is especially true when you do ZeroMQ magic, which just <em>won't</em> work the first few times you try it.</li>
</ul>
<ul>
<li>When you find that things don't work as expected, break your code into pieces, test each one, see which one is not working. ZeroMQ lets you make essentially modular code; use that to your advantage.</li>
</ul>
<ul>
<li>Make abstractions (classes, methods, whatever) as you need them. If you copy/paste a lot of code, you're going to copy/paste errors, too.</li>
</ul>
<p><a name="Getting-the-Context-Right"></a><a name="header-17"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc16"><span><a href="http://zguide.zeromq.org/page:all#Getting-the-Context-Right">Getting the Context Right</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-16">prev</a> <a href="http://zguide.zeromq.org/page:all#header-18">next</a></td>
</tr>
</tbody></table>
<p>ZeroMQ applications always start by creating a <em>context</em>, and then using that for creating sockets. In C, it's the <tt><a href="http://api.zeromq.org/3-2:zmq_ctx_new">zmq_ctx_new()</a></tt> call. You should create and use exactly one context in your process. Technically, the context is the container for all sockets in a single process, and acts as the transport for <tt>inproc</tt> sockets, which are the fastest way to connect threads in one process. If at runtime a process has two contexts, these are like separate ZeroMQ instances. If that's explicitly what you want, OK, but otherwise remember:</p>
<p><strong>Call <tt><a href="http://api.zeromq.org/3-2:zmq_ctx_new">zmq_ctx_new()</a></tt> once at the start of a process, and <tt><a href="http://api.zeromq.org/3-2:zmq_ctx_destroy">zmq_ctx_destroy()</a></tt> once at the end.</strong></p>
<p>If you're using the <tt>fork()</tt> system call, do <tt><a href="http://api.zeromq.org/3-2:zmq_ctx_new">zmq_ctx_new()</a></tt> <em>after</em> the fork and at the beginning of the child process code. In general, you want to do interesting (ZeroMQ) stuff in the children, and boring process management in the parent.</p>
<p><a name="Making-a-Clean-Exit"></a><a name="header-18"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc17"><span><a href="http://zguide.zeromq.org/page:all#Making-a-Clean-Exit">Making a Clean Exit</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-17">prev</a> <a href="http://zguide.zeromq.org/page:all#header-19">next</a></td>
</tr>
</tbody></table>
<p>Classy programmers share the same motto as classy hit men: always clean-up when you finish the job. When you use ZeroMQ in a language like Python, stuff gets automatically freed for you. But when using C, you have to carefully free objects when you're finished with them or else you get memory leaks, unstable applications, and generally bad karma.</p>
<p>Memory leaks are one thing, but ZeroMQ is quite finicky about how you exit an application. The reasons are technical and painful, but the upshot is that if you leave any sockets open, the <tt><a href="http://api.zeromq.org/3-2:zmq_ctx_destroy">zmq_ctx_destroy()</a></tt> function will hang forever. And even if you close all sockets, <tt><a href="http://api.zeromq.org/3-2:zmq_ctx_destroy">zmq_ctx_destroy()</a></tt> will by default wait forever if there are pending connects or sends unless you set the LINGER to zero on those sockets before closing them.</p>
<p>The ZeroMQ objects we need to worry about are messages, sockets, and contexts. Luckily it's quite simple, at least in simple programs:</p>
<ul>
<li>Use <tt><a href="http://api.zeromq.org/3-2:zmq_send">zmq_send()</a></tt> and <tt><a href="http://api.zeromq.org/3-2:zmq_recv">zmq_recv()</a></tt> when you can, as it avoids the need to work with zmq_msg_t objects.</li>
</ul>
<ul>
<li>If you do use <tt><a href="http://api.zeromq.org/3-2:zmq_msg_recv">zmq_msg_recv()</a></tt>, always release the received message as soon as you're done with it, by calling <tt><a href="http://api.zeromq.org/3-2:zmq_msg_close">zmq_msg_close()</a></tt>.</li>
</ul>
<ul>
<li>If you are opening and closing a lot of sockets, that's probably a sign that you need to redesign your application. In some cases socket handles won't be freed until you destroy the context.</li>
</ul>
<ul>
<li>When you exit the program, close your sockets and then call <tt><a href="http://api.zeromq.org/3-2:zmq_ctx_destroy">zmq_ctx_destroy()</a></tt>. This destroys the context.</li>
</ul>
<p>This is at least the case for C development. In a language with automatic object destruction, sockets and contexts will be destroyed as you leave the scope. If you use exceptions you'll have to do the clean-up in something like a "final" block, the same as for any resource.</p>
<p>If you're doing multithreaded work, it gets rather more complex than this. We'll get to multithreading in the next chapter, but because some of you will, despite warnings, try to run before you can safely walk, below is the quick and dirty guide to making a clean exit in a <em>multithreaded</em> ZeroMQ application.</p>
<p>First, do not try to use the same socket from multiple threads. Please don't explain why you think this would be excellent fun, just please don't do it. Next, you need to shut down each socket that has ongoing requests. The proper way is to set a low LINGER value (1 second), and then close the socket. If your language binding doesn't do this for you automatically when you destroy a context, I'd suggest sending a patch.</p>
<p>Finally, destroy the context. This will cause any blocking receives or polls or sends in attached threads (i.e., which share the same context) to return with an error. Catch that error, and then set linger on, and close sockets in <em>that</em> thread, and exit. Do not destroy the same context twice. The <tt>zmq_ctx_destroy</tt> in the main thread will block until all sockets it knows about are safely closed.</p>
<p>Voila! It's complex and painful enough that any language binding author worth his or her salt will do this automatically and make the socket closing dance unnecessary.</p>
<p><a name="Why-We-Needed-ZeroMQ"></a><a name="header-19"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc18"><span><a href="http://zguide.zeromq.org/page:all#Why-We-Needed-ZeroMQ">Why We Needed ZeroMQ</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-18">prev</a> <a href="http://zguide.zeromq.org/page:all#header-20">next</a></td>
</tr>
</tbody></table>
<p>Now that you've seen ZeroMQ in action, let's go back to the "why".</p>
<p>Many applications these days consist of components that stretch across some kind of network, either a LAN or the Internet. So many application developers end up doing some kind of messaging. Some developers use message queuing products, but most of the time they do it themselves, using TCP or UDP. These protocols are not hard to use, but there is a great difference between sending a few bytes from A to B, and doing messaging in any kind of reliable way.</p>
<p>Let's look at the typical problems we face when we start to connect pieces using raw TCP. Any reusable messaging layer would need to solve all or most of these:</p>
<ul>
<li>How do we handle I/O? Does our application block, or do we handle I/O in the background? This is a key design decision. Blocking I/O creates architectures that do not scale well. But background I/O can be very hard to do right.</li>
</ul>
<ul>
<li>How do we handle dynamic components, i.e., pieces that go away temporarily? Do we formally split components into "clients" and "servers" and mandate that servers cannot disappear? What then if we want to connect servers to servers? Do we try to reconnect every few seconds?</li>
</ul>
<ul>
<li>How do we represent a message on the wire? How do we frame data so it's easy to write and read, safe from buffer overflows, efficient for small messages, yet adequate for the very largest videos of dancing cats wearing party hats?</li>
</ul>
<ul>
<li>How do we handle messages that we can't deliver immediately? Particularly, if we're waiting for a component to come back online? Do we discard messages, put them into a database, or into a memory queue?</li>
</ul>
<ul>
<li>Where do we store message queues? What happens if the component reading from a queue is very slow and causes our queues to build up? What's our strategy then?</li>
</ul>
<ul>
<li>How do we handle lost messages? Do we wait for fresh data, request a resend, or do we build some kind of reliability layer that ensures messages cannot be lost? What if that layer itself crashes?</li>
</ul>
<ul>
<li>What if we need to use a different network transport. Say, multicast instead of TCP unicast? Or IPv6? Do we need to rewrite the applications, or is the transport abstracted in some layer?</li>
</ul>
<ul>
<li>How do we route messages? Can we send the same message to multiple peers? Can we send replies back to an original requester?</li>
</ul>
<ul>
<li>How do we write an API for another language? Do we re-implement a wire-level protocol or do we repackage a library? If the former, how can we guarantee efficient and stable stacks? If the latter, how can we guarantee interoperability?</li>
</ul>
<ul>
<li>How do we represent data so that it can be read between different architectures? Do we enforce a particular encoding for data types? How far is this the job of the messaging system rather than a higher layer?</li>
</ul>
<ul>
<li>How do we handle network errors? Do we wait and retry, ignore them silently, or abort?</li>
</ul>
<p>Take a typical open source project like <a href="http://hadoop.apache.org/zookeeper/">Hadoop Zookeeper</a> and read the C API code in <tt><a href="http://github.com/apache/zookeeper/blob/trunk/src/c/src/zookeeper.c">src/c/src/zookeeper.c</a></tt>. When I read this code, in January 2013, it was 4,200 lines of mystery and in there is an undocumented, client/server network communication protocol. I see it's efficient because it uses <tt>poll</tt> instead of <tt>select</tt>. But really, Zookeeper should be using a generic messaging layer and an explicitly documented wire level protocol. It is incredibly wasteful for teams to be building this particular wheel over and over.</p>
<p>But how to make a reusable messaging layer? Why, when so many projects need this technology, are people still doing it the hard way by driving TCP sockets in their code, and solving the problems in that long list over and over?</p>
<p>It turns out that building reusable messaging systems is really difficult, which is why few FOSS projects ever tried, and why commercial messaging products are complex, expensive, inflexible, and brittle. In 2006, iMatix designed <a href="http://www.amqp.org/">AMQP</a> which started to give FOSS developers perhaps the first reusable recipe for a messaging system. AMQP works better than many other designs, <a href="http://www.imatix.com/articles:whats-wrong-with-amqp">but remains relatively complex, expensive, and brittle</a>. It takes weeks to learn to use, and months to create stable architectures that don't crash when things get hairy.</p>
<p><strong>Figure 7 - Messaging as it Starts</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig7.png" alt="fig7.png" class="image"></div>
<p>Most messaging projects, like AMQP, that try to solve this long list of problems in a reusable way do so by inventing a new concept, the "broker", that does addressing, routing, and queuing. This results in a client/server protocol or a set of APIs on top of some undocumented protocol that allows applications to speak to this broker. Brokers are an excellent thing in reducing the complexity of large networks. But adding broker-based messaging to a product like Zookeeper would make it worse, not better. It would mean adding an additional big box, and a new single point of failure. A broker rapidly becomes a bottleneck and a new risk to manage. If the software supports it, we can add a second, third, and fourth broker and make some failover scheme. People do this. It creates more moving pieces, more complexity, and more things to break.</p>
<p>And a broker-centric setup needs its own operations team. You literally need to watch the brokers day and night, and beat them with a stick when they start misbehaving. You need boxes, and you need backup boxes, and you need people to manage those boxes. It is only worth doing for large applications with many moving pieces, built by several teams of people over several years.</p>
<p><strong>Figure 8 - Messaging as it Becomes</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig8.png" alt="fig8.png" class="image"></div>
<p>So small to medium application developers are trapped. Either they avoid network programming and make monolithic applications that do not scale. Or they jump into network programming and make brittle, complex applications that are hard to maintain. Or they bet on a messaging product, and end up with scalable applications that depend on expensive, easily broken technology. There has been no really good choice, which is maybe why messaging is largely stuck in the last century and stirs strong emotions: negative ones for users, gleeful joy for those selling support and licenses.</p>
<p>What we need is something that does the job of messaging, but does it in such a simple and cheap way that it can work in any application, with close to zero cost. It should be a library which you just link, without any other dependencies. No additional moving pieces, so no additional risk. It should run on any OS and work with any programming language.</p>
<p>And this is ZeroMQ: an efficient, embeddable library that solves most of the problems an application needs to become nicely elastic across a network, without much cost.</p>
<p>Specifically:</p>
<ul>
<li>It handles I/O asynchronously, in background threads. These communicate with application threads using lock-free data structures, so concurrent ZeroMQ applications need no locks, semaphores, or other wait states.</li>
</ul>
<ul>
<li>Components can come and go dynamically and ZeroMQ will automatically reconnect. This means you can start components in any order. You can create "service-oriented architectures" (SOAs) where services can join and leave the network at any time.</li>
</ul>
<ul>
<li>It queues messages automatically when needed. It does this intelligently, pushing messages as close as possible to the receiver before queuing them.</li>
</ul>
<ul>
<li>It has ways of dealing with over-full queues (called "high water mark"). When a queue is full, ZeroMQ automatically blocks senders, or throws away messages, depending on the kind of messaging you are doing (the so-called "pattern").</li>
</ul>
<ul>
<li>It lets your applications talk to each other over arbitrary transports: TCP, multicast, in-process, inter-process. You don't need to change your code to use a different transport.</li>
</ul>
<ul>
<li>It handles slow/blocked readers safely, using different strategies that depend on the messaging pattern.</li>
</ul>
<ul>
<li>It lets you route messages using a variety of patterns such as request-reply and pub-sub. These patterns are how you create the topology, the structure of your network.</li>
</ul>
<ul>
<li>It lets you create proxies to queue, forward, or capture messages with a single call. Proxies can reduce the interconnection complexity of a network.</li>
</ul>
<ul>
<li>It delivers whole messages exactly as they were sent, using a simple framing on the wire. If you write a 10k message, you will receive a 10k message.</li>
</ul>
<ul>
<li>It does not impose any format on messages. They are blobs from zero to gigabytes large. When you want to represent data you choose some other product on top, such as msgpack, Google's protocol buffers, and others.</li>
</ul>
<ul>
<li>It handles network errors intelligently, by retrying automatically in cases where it makes sense.</li>
</ul>
<ul>
<li>It reduces your carbon footprint. Doing more with less CPU means your boxes use less power, and you can keep your old boxes in use for longer. Al Gore would love ZeroMQ.</li>
</ul>
<p>Actually ZeroMQ does rather more than this. It has a subversive effect on how you develop network-capable applications. Superficially, it's a socket-inspired API on which you do <tt><a href="http://api.zeromq.org/3-2:zmq_recv">zmq_recv()</a></tt> and <tt><a href="http://api.zeromq.org/3-2:zmq_send">zmq_send()</a></tt>. But message processing rapidly becomes the central loop, and your application soon breaks down into a set of message processing tasks. It is elegant and natural. And it scales: each of these tasks maps to a node, and the nodes talk to each other across arbitrary transports. Two nodes in one process (node is a thread), two nodes on one box (node is a process), or two nodes on one network (node is a box)—it's all the same, with no application code changes.</p>
<p><a name="Socket-Scalability"></a><a name="header-20"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc19"><span><a href="http://zguide.zeromq.org/page:all#Socket-Scalability">Socket Scalability</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-19">prev</a> <a href="http://zguide.zeromq.org/page:all#header-21">next</a></td>
</tr>
</tbody></table>
<p>Let's see ZeroMQ's scalability in action. Here is a shell script that starts the weather server and then a bunch of clients in parallel:</p>
<div class="code">
<pre><code>wuserver &amp;
wuclient 12345 &amp;
wuclient 23456 &amp;
wuclient 34567 &amp;
wuclient 45678 &amp;
wuclient 56789 &amp;</code>
</pre></div>
<p>As the clients run, we take a look at the active processes using the <tt>top</tt> command', and we see something like (on a 4-core box):</p>
<div class="code">
<pre><code>PID  USER  PR  NI  VIRT  RES  SHR S %CPU %MEM   TIME+  COMMAND
7136  ph   20   0 1040m 959m 1156 R  157 12.0 16:25.47 wuserver
7966  ph   20   0 98608 1804 1372 S   33  0.0  0:03.94 wuclient
7963  ph   20   0 33116 1748 1372 S   14  0.0  0:00.76 wuclient
7965  ph   20   0 33116 1784 1372 S    6  0.0  0:00.47 wuclient
7964  ph   20   0 33116 1788 1372 S    5  0.0  0:00.25 wuclient
7967  ph   20   0 33072 1740 1372 S    5  0.0  0:00.35 wuclient</code>
</pre></div>
<p>Let's think for a second about what is happening here. The weather server has a single socket, and yet here we have it sending data to five clients in parallel. We could have thousands of concurrent clients. The server application doesn't see them, doesn't talk to them directly. So the ZeroMQ socket is acting like a little server, silently accepting client requests and shoving data out to them as fast as the network can handle it. And it's a multithreaded server, squeezing more juice out of your CPU.</p>
<p><a name="Upgrading-from-ZeroMQ-v-to-ZeroMQ-v"></a><a name="header-21"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc20"><span><a href="http://zguide.zeromq.org/page:all#Upgrading-from-ZeroMQ-v-to-ZeroMQ-v">Upgrading from ZeroMQ v2.2 to ZeroMQ v3.2</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-20">prev</a> <a href="http://zguide.zeromq.org/page:all#header-22">next</a></td>
</tr>
</tbody></table>
<p><a name="Compatible-Changes"></a><a name="header-22"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc21"><span><a href="http://zguide.zeromq.org/page:all#Compatible-Changes">Compatible Changes</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-21">prev</a> <a href="http://zguide.zeromq.org/page:all#header-23">next</a></td>
</tr>
</tbody></table>
<p>These changes don't impact existing application code directly:</p>
<ul>
<li>Pub-sub filtering is now done at the publisher side instead of subscriber side. This improves performance significantly in many pub-sub use cases. You can mix v3.2 and v2.1/v2.2 publishers and subscribers safely.</li>
</ul>
<ul>
<li>ZeroMQ v3.2 has many new API methods (<tt><a href="http://api.zeromq.org/3-2:zmq_disconnect">zmq_disconnect()</a></tt>, <tt><a href="http://api.zeromq.org/3-2:zmq_unbind">zmq_unbind()</a></tt>, <tt><a href="http://api.zeromq.org/3-2:zmq_monitor">zmq_monitor()</a></tt>, <tt><a href="http://api.zeromq.org/3-2:zmq_ctx_set">zmq_ctx_set()</a></tt>, etc.)</li>
</ul>
<p><a name="Incompatible-Changes"></a><a name="header-23"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc22"><span><a href="http://zguide.zeromq.org/page:all#Incompatible-Changes">Incompatible Changes</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-22">prev</a> <a href="http://zguide.zeromq.org/page:all#header-24">next</a></td>
</tr>
</tbody></table>
<p>These are the main areas of impact on applications and language bindings:</p>
<ul>
<li>Changed send/recv methods: <tt><a href="http://api.zeromq.org/3-2:zmq_send">zmq_send()</a></tt> and <tt><a href="http://api.zeromq.org/3-2:zmq_recv">zmq_recv()</a></tt> have a different, simpler interface, and the old functionality is now provided by <tt><a href="http://api.zeromq.org/3-2:zmq_msg_send">zmq_msg_send()</a></tt> and <tt><a href="http://api.zeromq.org/3-2:zmq_msg_recv">zmq_msg_recv()</a></tt>. Symptom: compile errors. Solution: fix up your code.</li>
</ul>
<ul>
<li>These two methods return positive values on success, and -1 on error. In v2.x they always returned zero on success. Symptom: apparent errors when things actually work fine. Solution: test strictly for return code = -1, not non-zero.</li>
</ul>
<ul>
<li><tt><a href="http://api.zeromq.org/3-2:zmq_poll">zmq_poll()</a></tt> now waits for milliseconds, not microseconds. Symptom: application stops responding (in fact responds 1000 times slower). Solution: use the <tt>ZMQ_POLL_MSEC</tt> macro defined below, in all <tt>zmq_poll</tt> calls.</li>
</ul>
<ul>
<li><tt>ZMQ_NOBLOCK</tt> is now called <tt>ZMQ_DONTWAIT</tt>. Symptom: compile failures on the <tt>ZMQ_NOBLOCK</tt> macro.</li>
</ul>
<ul>
<li>The <tt>ZMQ_HWM</tt> socket option is now broken into <tt>ZMQ_SNDHWM</tt> and <tt>ZMQ_RCVHWM</tt>. Symptom: compile failures on the <tt>ZMQ_HWM</tt> macro.</li>
</ul>
<ul>
<li>Most but not all <tt><a href="http://api.zeromq.org/3-2:zmq_getsockopt">zmq_getsockopt()</a></tt> options are now integer values. Symptom: runtime error returns on <tt>zmq_setsockopt</tt> and <tt>zmq_getsockopt</tt>.</li>
</ul>
<ul>
<li>The <tt>ZMQ_SWAP</tt> option has been removed. Symptom: compile failures on <tt>ZMQ_SWAP</tt>. Solution: redesign any code that uses this functionality.</li>
</ul>
<p><a name="Suggested-Shim-Macros"></a><a name="header-24"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc23"><span><a href="http://zguide.zeromq.org/page:all#Suggested-Shim-Macros">Suggested Shim Macros</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-23">prev</a> <a href="http://zguide.zeromq.org/page:all#header-25">next</a></td>
</tr>
</tbody></table>
<p>For applications that want to run on both v2.x and v3.2, such as language bindings, our advice is to emulate v3.2 as far as possible. Here are C macro definitions that help your C/C++ code to work across both versions (taken from <a href="http://czmq.zeromq.org/">CZMQ</a>):</p>
<div class="code">
<p><span style="color:#BC7A00">#ifndef ZMQ_DONTWAIT<br>
#<tt><span style="white-space: pre-wrap;">   </span></tt>define ZMQ_DONTWAIT<tt><span style="white-space: pre-wrap;">     </span></tt>ZMQ_NOBLOCK<br>
#endif<br>
#if ZMQ_VERSION_MAJOR == 2<br>
#<tt><span style="white-space: pre-wrap;">   </span></tt>define zmq_msg_send(msg,sock,opt) zmq_send (sock, msg, opt)<br>
#<tt><span style="white-space: pre-wrap;">   </span></tt>define zmq_msg_recv(msg,sock,opt) zmq_recv (sock, msg, opt)<br>
#<tt><span style="white-space: pre-wrap;">   </span></tt>define zmq_ctx_destroy(context) zmq_term(context)<br>
#<tt><span style="white-space: pre-wrap;">   </span></tt>define ZMQ_POLL_MSEC<tt><span style="white-space: pre-wrap;">    </span></tt>1000<tt><span style="white-space: pre-wrap;">        </span></tt></span><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>zmq_poll is usec</em></span><br>
<span style="color:#BC7A00">#<tt><span style="white-space: pre-wrap;">   </span></tt>define ZMQ_SNDHWM ZMQ_HWM<br>
#<tt><span style="white-space: pre-wrap;">   </span></tt>define ZMQ_RCVHWM ZMQ_HWM<br>
#elif ZMQ_VERSION_MAJOR == 3<br>
#<tt><span style="white-space: pre-wrap;">   </span></tt>define ZMQ_POLL_MSEC<tt><span style="white-space: pre-wrap;">    </span></tt>1<tt><span style="white-space: pre-wrap;">           </span></tt></span><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>zmq_poll is msec</em></span><br>
<span style="color:#BC7A00">#endif</span></p>
</div>
<p><a name="Warning-Unstable-Paradigms"></a><a name="header-25"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc24"><span><a href="http://zguide.zeromq.org/page:all#Warning-Unstable-Paradigms">Warning: Unstable Paradigms!</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-24">prev</a> <a href="http://zguide.zeromq.org/page:all#header-26">next</a></td>
</tr>
</tbody></table>
<p>Traditional network programming is built on the general assumption that one socket talks to one connection, one peer. There are multicast protocols, but these are exotic. When we assume "one socket = one connection", we scale our architectures in certain ways. We create threads of logic where each thread work with one socket, one peer. We place intelligence and state in these threads.</p>
<p>In the ZeroMQ universe, sockets are doorways to fast little background communications engines that manage a whole set of connections automagically for you. You can't see, work with, open, close, or attach state to these connections. Whether you use blocking send or receive, or poll, all you can talk to is the socket, not the connections it manages for you. The connections are private and invisible, and this is the key to ZeroMQ's scalability.</p>
<p>This is because your code, talking to a socket, can then handle any number of connections across whatever network protocols are around, without change. A messaging pattern sitting in ZeroMQ scales more cheaply than a messaging pattern sitting in your application code.</p>
<p>So the general assumption no longer applies. As you read the code examples, your brain will try to map them to what you know. You will read "socket" and think "ah, that represents a connection to another node". That is wrong. You will read "thread" and your brain will again think, "ah, a thread represents a connection to another node", and again your brain will be wrong.</p>
<p>If you're reading this Guide for the first time, realize that until you actually write ZeroMQ code for a day or two (and maybe three or four days), you may feel confused, especially by how simple ZeroMQ makes things for you, and you may try to impose that general assumption on ZeroMQ, and it won't work. And then you will experience your moment of enlightenment and trust, that <em>zap-pow-kaboom</em> satori paradigm-shift moment when it all becomes clear.</p>
<p><a name="sockets-and-patterns"></a><br>
<a name="Chapter-Sockets-and-Patterns"></a><a name="header-26"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h2 id="toc25"><span><a href="http://zguide.zeromq.org/page:all#Chapter-Sockets-and-Patterns">Chapter 2 - Sockets and Patterns</a></span></h2>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-25">prev</a> <a href="http://zguide.zeromq.org/page:all#header-27">next</a></td>
</tr>
</tbody></table>
<p>In <a href="http://zguide.zeromq.org/page:all#basics">Chapter 1 - Basics</a> we took ZeroMQ for a drive, with some basic examples of the main ZeroMQ patterns: request-reply, pub-sub, and pipeline. In this chapter, we're going to get our hands dirty and start to learn how to use these tools in real programs.</p>
<p>We'll cover:</p>
<ul>
<li>How to create and work with ZeroMQ sockets.</li>
<li>How to send and receive messages on sockets.</li>
<li>How to build your apps around ZeroMQ's asynchronous I/O model.</li>
<li>How to handle multiple sockets in one thread.</li>
<li>How to handle fatal and nonfatal errors properly.</li>
<li>How to handle interrupt signals like Ctrl-C.</li>
<li>How to shut down a ZeroMQ application cleanly.</li>
<li>How to check a ZeroMQ application for memory leaks.</li>
<li>How to send and receive multipart messages.</li>
<li>How to forward messages across networks.</li>
<li>How to build a simple message queuing broker.</li>
<li>How to write multithreaded applications with ZeroMQ.</li>
<li>How to use ZeroMQ to signal between threads.</li>
<li>How to use ZeroMQ to coordinate a network of nodes.</li>
<li>How to create and use message envelopes for pub-sub.</li>
<li>Using the HWM (high-water mark) to protect against memory overflows.</li>
</ul>
<p><a name="The-Socket-API"></a><a name="header-27"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc26"><span><a href="http://zguide.zeromq.org/page:all#The-Socket-API">The Socket API</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-26">prev</a> <a href="http://zguide.zeromq.org/page:all#header-28">next</a></td>
</tr>
</tbody></table>
<p>To be perfectly honest, ZeroMQ does a kind of switch-and-bait on you, for which we don't apologize. It's for your own good and it hurts us more than it hurts you. ZeroMQ presents a familiar socket-based API, which requires great effort for us to hide a bunch of message-processing engines. However, the result will slowly fix your world view about how to design and write distributed software.</p>
<p>Sockets are the de facto standard API for network programming, as well as being useful for stopping your eyes from falling onto your cheeks. One thing that makes ZeroMQ especially tasty to developers is that it uses sockets and messages instead of some other arbitrary set of concepts. Kudos to Martin Sustrik for pulling this off. It turns "Message Oriented Middleware", a phrase guaranteed to send the whole room off to Catatonia, into "Extra Spicy Sockets!", which leaves us with a strange craving for pizza and a desire to know more.</p>
<p>Like a favorite dish, ZeroMQ sockets are easy to digest. Sockets have a life in four parts, just like BSD sockets:</p>
<ul>
<li>Creating and destroying sockets, which go together to form a karmic circle of socket life (see <tt><a href="http://api.zeromq.org/3-2:zmq_socket">zmq_socket()</a></tt>, <tt><a href="http://api.zeromq.org/3-2:zmq_close">zmq_close()</a></tt>).</li>
</ul>
<ul>
<li>Configuring sockets by setting options on them and checking them if necessary (see <tt><a href="http://api.zeromq.org/3-2:zmq_setsockopt">zmq_setsockopt()</a></tt>, <tt><a href="http://api.zeromq.org/3-2:zmq_getsockopt">zmq_getsockopt()</a></tt>).</li>
</ul>
<ul>
<li>Plugging sockets into the network topology by creating ZeroMQ connections to and from them (see <tt><a href="http://api.zeromq.org/3-2:zmq_bind">zmq_bind()</a></tt>, <tt><a href="http://api.zeromq.org/3-2:zmq_connect">zmq_connect()</a></tt>).</li>
</ul>
<ul>
<li>Using the sockets to carry data by writing and receiving messages on them (see <tt><a href="http://api.zeromq.org/3-2:zmq_msg_send">zmq_msg_send()</a></tt>, <tt><a href="http://api.zeromq.org/3-2:zmq_msg_recv">zmq_msg_recv()</a></tt>).</li>
</ul>
<p>Note that sockets are always void pointers, and messages (which we'll come to very soon) are structures. So in C you pass sockets as-such, but you pass addresses of messages in all functions that work with messages, like <tt><a href="http://api.zeromq.org/3-2:zmq_msg_send">zmq_msg_send()</a></tt> and <tt><a href="http://api.zeromq.org/3-2:zmq_msg_recv">zmq_msg_recv()</a></tt>. As a mnemonic, realize that "in ZeroMQ, all your sockets are belong to us", but messages are things you actually own in your code.</p>
<p>Creating, destroying, and configuring sockets works as you'd expect for any object. But remember that ZeroMQ is an asynchronous, elastic fabric. This has some impact on how we plug sockets into the network topology and how we use the sockets after that.</p>
<p><a name="Plugging-Sockets-into-the-Topology"></a><a name="header-28"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc27"><span><a href="http://zguide.zeromq.org/page:all#Plugging-Sockets-into-the-Topology">Plugging Sockets into the Topology</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-27">prev</a> <a href="http://zguide.zeromq.org/page:all#header-29">next</a></td>
</tr>
</tbody></table>
<p>To create a connection between two nodes, you use <tt><a href="http://api.zeromq.org/3-2:zmq_bind">zmq_bind()</a></tt> in one node and <tt><a href="http://api.zeromq.org/3-2:zmq_connect">zmq_connect()</a></tt> in the other. As a general rule of thumb, the node that does <tt><a href="http://api.zeromq.org/3-2:zmq_bind">zmq_bind()</a></tt> is a "server", sitting on a well-known network address, and the node which does <tt><a href="http://api.zeromq.org/3-2:zmq_connect">zmq_connect()</a></tt> is a "client", with unknown or arbitrary network addresses. Thus we say that we "bind a socket to an endpoint" and "connect a socket to an endpoint", the endpoint being that well-known network address.</p>
<p>ZeroMQ connections are somewhat different from classic TCP connections. The main notable differences are:</p>
<ul>
<li>They go across an arbitrary transport (<tt>inproc</tt>, <tt>ipc</tt>, <tt>tcp</tt>, <tt>pgm</tt>, or <tt>epgm</tt>). See <tt><a href="http://api.zeromq.org/3-2:zmq_inproc">zmq_inproc()</a></tt>, <tt><a href="http://api.zeromq.org/3-2:zmq_ipc">zmq_ipc()</a></tt>, <tt><a href="http://api.zeromq.org/3-2:zmq_tcp">zmq_tcp()</a></tt>, <tt><a href="http://api.zeromq.org/3-2:zmq_pgm">zmq_pgm()</a></tt>, and <tt><a href="http://api.zeromq.org/3-2:zmq_epgm">zmq_epgm()</a></tt>.</li>
</ul>
<ul>
<li>One socket may have many outgoing and many incoming connections.</li>
</ul>
<ul>
<li>There is no <tt>zmq_accept</tt>() method. When a socket is bound to an endpoint it automatically starts accepting connections.</li>
</ul>
<ul>
<li>The network connection itself happens in the background, and ZeroMQ will automatically reconnect if the network connection is broken (e.g., if the peer disappears and then comes back).</li>
</ul>
<ul>
<li>Your application code cannot work with these connections directly; they are encapsulated under the socket.</li>
</ul>
<p>Many architectures follow some kind of client/server model, where the server is the component that is most static, and the clients are the components that are most dynamic, i.e., they come and go the most. There are sometimes issues of addressing: servers will be visible to clients, but not necessarily vice versa. So mostly it's obvious which node should be doing <tt><a href="http://api.zeromq.org/3-2:zmq_bind">zmq_bind()</a></tt> (the server) and which should be doing <tt><a href="http://api.zeromq.org/3-2:zmq_connect">zmq_connect()</a></tt> (the client). It also depends on the kind of sockets you're using, with some exceptions for unusual network architectures. We'll look at socket types later.</p>
<p>Now, imagine we start the client <em>before</em> we start the server. In traditional networking, we get a big red Fail flag. But ZeroMQ lets us start and stop pieces arbitrarily. As soon as the client node does <tt><a href="http://api.zeromq.org/3-2:zmq_connect">zmq_connect()</a></tt>, the connection exists and that node can start to write messages to the socket. At some stage (hopefully before messages queue up so much that they start to get discarded, or the client blocks), the server comes alive, does a <tt><a href="http://api.zeromq.org/3-2:zmq_bind">zmq_bind()</a></tt>, and ZeroMQ starts to deliver messages.</p>
<p>A server node can bind to many endpoints (that is, a combination of protocol and address) and it can do this using a single socket. This means it will accept connections across different transports:</p>
<div class="code">
<p>zmq_bind (socket, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5555"</span>);<br>
zmq_bind (socket, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:9999"</span>);<br>
zmq_bind (socket, <span style="color:#BA2121">"inproc:<span style="white-space: pre-wrap;">//</span>somename"</span>);</p>
</div>
<p>With most transports, you cannot bind to the same endpoint twice, unlike for example in UDP. The <tt>ipc</tt> transport does, however, let one process bind to an endpoint already used by a first process. It's meant to allow a process to recover after a crash.</p>
<p>Although ZeroMQ tries to be neutral about which side binds and which side connects, there are differences. We'll see these in more detail later. The upshot is that you should usually think in terms of "servers" as static parts of your topology that bind to more or less fixed endpoints, and "clients" as dynamic parts that come and go and connect to these endpoints. Then, design your application around this model. The chances that it will "just work" are much better like that.</p>
<p>Sockets have types. The socket type defines the semantics of the socket, its policies for routing messages inwards and outwards, queuing, etc. You can connect certain types of socket together, e.g., a publisher socket and a subscriber socket. Sockets work together in "messaging patterns". We'll look at this in more detail later.</p>
<p>It's the ability to connect sockets in these different ways that gives ZeroMQ its basic power as a message queuing system. There are layers on top of this, such as proxies, which we'll get to later. But essentially, with ZeroMQ you define your network architecture by plugging pieces together like a child's construction toy.</p>
<p><a name="Sending-and-Receiving-Messages"></a><a name="header-29"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc28"><span><a href="http://zguide.zeromq.org/page:all#Sending-and-Receiving-Messages">Sending and Receiving Messages</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-28">prev</a> <a href="http://zguide.zeromq.org/page:all#header-30">next</a></td>
</tr>
</tbody></table>
<p>To send and receive messages you use the <tt><a href="http://api.zeromq.org/3-2:zmq_msg_send">zmq_msg_send()</a></tt> and <tt><a href="http://api.zeromq.org/3-2:zmq_msg_recv">zmq_msg_recv()</a></tt> methods. The names are conventional, but ZeroMQ's I/O model is different enough from the classic TCP model that you will need time to get your head around it.</p>
<p><strong>Figure 9 - TCP sockets are 1 to 1</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig9.png" alt="fig9.png" class="image"></div>
<p>Let's look at the main differences between TCP sockets and ZeroMQ sockets when it comes to working with data:</p>
<ul>
<li>ZeroMQ sockets carry messages, like UDP, rather than a stream of bytes as TCP does. A ZeroMQ message is length-specified binary data. We'll come to messages shortly; their design is optimized for performance and so a little tricky.</li>
</ul>
<ul>
<li>ZeroMQ sockets do their I/O in a background thread. This means that messages arrive in local input queues and are sent from local output queues, no matter what your application is busy doing.</li>
</ul>
<ul>
<li>ZeroMQ sockets have one-to-N routing behavior built-in, according to the socket type.</li>
</ul>
<p>The <tt><a href="http://api.zeromq.org/3-2:zmq_send">zmq_send()</a></tt> method does not actually send the message to the socket connection(s). It queues the message so that the I/O thread can send it asynchronously. It does not block except in some exception cases. So the message is not necessarily sent when <tt><a href="http://api.zeromq.org/3-2:zmq_send">zmq_send()</a></tt> returns to your application.</p>
<p><a name="Unicast-Transports"></a><a name="header-30"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc29"><span><a href="http://zguide.zeromq.org/page:all#Unicast-Transports">Unicast Transports</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-29">prev</a> <a href="http://zguide.zeromq.org/page:all#header-31">next</a></td>
</tr>
</tbody></table>
<p>ZeroMQ provides a set of unicast transports (<tt>inproc</tt>, <tt>ipc</tt>, and <tt>tcp</tt>) and multicast transports (epgm, pgm). Multicast is an advanced technique that we'll come to later. Don't even start using it unless you know that your fan-out ratios will make 1-to-N unicast impossible.</p>
<p>For most common cases, use <strong><tt>tcp</tt></strong>, which is a <em>disconnected TCP</em> transport. It is elastic, portable, and fast enough for most cases. We call this disconnected because ZeroMQ's <tt>tcp</tt> transport doesn't require that the endpoint exists before you connect to it. Clients and servers can connect and bind at any time, can go and come back, and it remains transparent to applications.</p>
<p>The inter-process <tt>ipc</tt> transport is disconnected, like <tt>tcp</tt>. It has one limitation: it does not yet work on Windows. By convention we use endpoint names with an ".ipc" extension to avoid potential conflict with other file names. On UNIX systems, if you use <tt>ipc</tt> endpoints you need to create these with appropriate permissions otherwise they may not be shareable between processes running under different user IDs. You must also make sure all processes can access the files, e.g., by running in the same working directory.</p>
<p>The inter-thread transport, <strong><tt>inproc</tt></strong>, is a connected signaling transport. It is much faster than <tt>tcp</tt> or <tt>ipc</tt>. This transport has a specific limitation compared to <tt>tcp</tt> and <tt>ipc</tt>: <strong>the server must issue a bind before any client issues a connect</strong>. This is something future versions of ZeroMQ may fix, but at present this defines how you use <tt>inproc</tt> sockets. We create and bind one socket and start the child threads, which create and connect the other sockets.</p>
<p><a name="ZeroMQ-is-Not-a-Neutral-Carrier"></a><a name="header-31"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc30"><span><a href="http://zguide.zeromq.org/page:all#ZeroMQ-is-Not-a-Neutral-Carrier">ZeroMQ is Not a Neutral Carrier</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-30">prev</a> <a href="http://zguide.zeromq.org/page:all#header-32">next</a></td>
</tr>
</tbody></table>
<p>A common question that newcomers to ZeroMQ ask (it's one I've asked myself) is, "how do I write an XYZ server in ZeroMQ?" For example, "how do I write an HTTP server in ZeroMQ?" The implication is that if we use normal sockets to carry HTTP requests and responses, we should be able to use ZeroMQ sockets to do the same, only much faster and better.</p>
<p>The answer used to be "this is not how it works". ZeroMQ is not a neutral carrier: it imposes a framing on the transport protocols it uses. This framing is not compatible with existing protocols, which tend to use their own framing. For example, compare an HTTP request and a ZeroMQ request, both over TCP/IP.</p>
<p><strong>Figure 10 - HTTP on the Wire</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig10.png" alt="fig10.png" class="image"></div>
<p>The HTTP request uses CR-LF as its simplest framing delimiter, whereas ZeroMQ uses a length-specified frame. So you could write an HTTP-like protocol using ZeroMQ, using for example the request-reply socket pattern. But it would not be HTTP.</p>
<p><strong>Figure 11 - ZeroMQ on the Wire</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig11.png" alt="fig11.png" class="image"></div>
<p>Since v3.3, however, ZeroMQ has a socket option called <tt>ZMQ_ROUTER_RAW</tt> that lets you read and write data without the ZeroMQ framing. You could use this to read and write proper HTTP requests and responses. Hardeep Singh contributed this change so that he could connect to Telnet servers from his ZeroMQ application. At time of writing this is still somewhat experimental, but it shows how ZeroMQ keeps evolving to solve new problems. Maybe the next patch will be yours.</p>
<p><a name="I-O-Threads"></a><a name="header-32"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc31"><span><a href="http://zguide.zeromq.org/page:all#I-O-Threads">I/O Threads</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-31">prev</a> <a href="http://zguide.zeromq.org/page:all#header-33">next</a></td>
</tr>
</tbody></table>
<p>We said that ZeroMQ does I/O in a background thread. One I/O thread (for all sockets) is sufficient for all but the most extreme applications. When you create a new context, it starts with one I/O thread. The general rule of thumb is to allow one I/O thread per gigabyte of data in or out per second. To raise the number of I/O threads, use the <tt><a href="http://api.zeromq.org/3-2:zmq_ctx_set">zmq_ctx_set()</a></tt> call <em>before</em> creating any sockets:</p>
<div class="code">
<p><span style="color:#B00040">int</span> io_threads <span style="color:#666666">=</span> <span style="color:#666666">4</span>;<br>
<span style="color:#B00040">void</span> <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zmq_ctx_new ();<br>
zmq_ctx_set (context, ZMQ_IO_THREADS, io_threads);<br>
assert (zmq_ctx_get (context, ZMQ_IO_THREADS) <span style="color:#666666">==</span> io_threads);</p>
</div>
<p>We've seen that one socket can handle dozens, even thousands of connections at once. This has a fundamental impact on how you write applications. A traditional networked application has one process or one thread per remote connection, and that process or thread handles one socket. ZeroMQ lets you collapse this entire structure into a single process and then break it up as necessary for scaling.</p>
<p>If you are using ZeroMQ for inter-thread communications only (i.e., a multithreaded application that does no external socket I/O) you can set the I/O threads to zero. It's not a significant optimization though, more of a curiosity.</p>
<p><a name="Messaging-Patterns"></a><a name="header-33"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc32"><span><a href="http://zguide.zeromq.org/page:all#Messaging-Patterns">Messaging Patterns</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-32">prev</a> <a href="http://zguide.zeromq.org/page:all#header-34">next</a></td>
</tr>
</tbody></table>
<p>Underneath the brown paper wrapping of ZeroMQ's socket API lies the world of messaging patterns. If you have a background in enterprise messaging, or know UDP well, these will be vaguely familiar. But to most ZeroMQ newcomers, they are a surprise. We're so used to the TCP paradigm where a socket maps one-to-one to another node.</p>
<p>Let's recap briefly what ZeroMQ does for you. It delivers blobs of data (messages) to nodes, quickly and efficiently. You can map nodes to threads, processes, or nodes. ZeroMQ gives your applications a single socket API to work with, no matter what the actual transport (like in-process, inter-process, TCP, or multicast). It automatically reconnects to peers as they come and go. It queues messages at both sender and receiver, as needed. It limits these queues to guard processes against running out of memory. It handles socket errors. It does all I/O in background threads. It uses lock-free techniques for talking between nodes, so there are never locks, waits, semaphores, or deadlocks.</p>
<p>But cutting through that, it routes and queues messages according to precise recipes called <em>patterns</em>. It is these patterns that provide ZeroMQ's intelligence. They encapsulate our hard-earned experience of the best ways to distribute data and work. ZeroMQ's patterns are hard-coded but future versions may allow user-definable patterns.</p>
<p>ZeroMQ patterns are implemented by pairs of sockets with matching types. In other words, to understand ZeroMQ patterns you need to understand socket types and how they work together. Mostly, this just takes study; there is little that is obvious at this level.</p>
<p>The built-in core ZeroMQ patterns are:</p>
<ul>
<li><strong>Request-reply</strong>, which connects a set of clients to a set of services. This is a remote procedure call and task distribution pattern.</li>
</ul>
<ul>
<li><strong>Pub-sub</strong>, which connects a set of publishers to a set of subscribers. This is a data distribution pattern.</li>
</ul>
<ul>
<li><strong>Pipeline</strong>, which connects nodes in a fan-out/fan-in pattern that can have multiple steps and loops. This is a parallel task distribution and collection pattern.</li>
</ul>
<ul>
<li><strong>Exclusive pair</strong>, which connects two sockets exclusively. This is a pattern for connecting two threads in a process, not to be confused with "normal" pairs of sockets.</li>
</ul>
<p>We looked at the first three of these in <a href="http://zguide.zeromq.org/page:all#basics">Chapter 1 - Basics</a>, and we'll see the exclusive pair pattern later in this chapter. The <tt><a href="http://api.zeromq.org/3-2:zmq_socket">zmq_socket()</a></tt> man page is fairly clear about the patterns — it's worth reading several times until it starts to make sense. These are the socket combinations that are valid for a connect-bind pair (either side can bind):</p>
<ul>
<li>PUB and SUB</li>
<li>REQ and REP</li>
<li>REQ and ROUTER (take care, REQ inserts an extra null frame)</li>
<li>DEALER and REP (take care, REP assumes a null frame)</li>
<li>DEALER and ROUTER</li>
<li>DEALER and DEALER</li>
<li>ROUTER and ROUTER</li>
<li>PUSH and PULL</li>
<li>PAIR and PAIR</li>
</ul>
<p>You'll also see references to XPUB and XSUB sockets, which we'll come to later (they're like raw versions of PUB and SUB). Any other combination will produce undocumented and unreliable results, and future versions of ZeroMQ will probably return errors if you try them. You can and will, of course, bridge other socket types via code, i.e., read from one socket type and write to another.</p>
<p><a name="High-Level-Messaging-Patterns"></a><a name="header-34"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc33"><span><a href="http://zguide.zeromq.org/page:all#High-Level-Messaging-Patterns">High-Level Messaging Patterns</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-33">prev</a> <a href="http://zguide.zeromq.org/page:all#header-35">next</a></td>
</tr>
</tbody></table>
<p>These four core patterns are cooked into ZeroMQ. They are part of the ZeroMQ API, implemented in the core C++ library, and are guaranteed to be available in all fine retail stores.</p>
<p>On top of those, we add <em>high-level messaging patterns</em>. We build these high-level patterns on top of ZeroMQ and implement them in whatever language we're using for our application. They are not part of the core library, do not come with the ZeroMQ package, and exist in their own space as part of the ZeroMQ community. For example the Majordomo pattern, which we explore in <a href="http://zguide.zeromq.org/page:all#reliable-request-reply">Chapter 4 - Reliable Request-Reply Patterns</a>, sits in the GitHub Majordomo project in the ZeroMQ organization.</p>
<p>One of the things we aim to provide you with in this book are a set of such high-level patterns, both small (how to handle messages sanely) and large (how to make a reliable pub-sub architecture).</p>
<p><a name="Working-with-Messages"></a><a name="header-35"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc34"><span><a href="http://zguide.zeromq.org/page:all#Working-with-Messages">Working with Messages</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-34">prev</a> <a href="http://zguide.zeromq.org/page:all#header-36">next</a></td>
</tr>
</tbody></table>
<p>The <tt>libzmq</tt> core library has in fact two APIs to send and receive messages. The <tt><a href="http://api.zeromq.org/3-2:zmq_send">zmq_send()</a></tt> and <tt><a href="http://api.zeromq.org/3-2:zmq_recv">zmq_recv()</a></tt> methods that we've already seen and used are simple one-liners. We will use these often, but <tt><a href="http://api.zeromq.org/3-2:zmq_recv">zmq_recv()</a></tt> is bad at dealing with arbitrary message sizes: it truncates messages to whatever buffer size you provide. So there's a second API that works with zmq_msg_t structures, with a richer but more difficult API:</p>
<ul>
<li>Initialise a message: <tt><a href="http://api.zeromq.org/3-2:zmq_msg_init">zmq_msg_init()</a></tt>, <tt><a href="http://api.zeromq.org/3-2:zmq_msg_init_size">zmq_msg_init_size()</a></tt>, <tt><a href="http://api.zeromq.org/3-2:zmq_msg_init_data">zmq_msg_init_data()</a></tt>.</li>
<li>Sending and receiving a message: <tt><a href="http://api.zeromq.org/3-2:zmq_msg_send">zmq_msg_send()</a></tt>, <tt><a href="http://api.zeromq.org/3-2:zmq_msg_recv">zmq_msg_recv()</a></tt>.</li>
<li>Release a message: <tt><a href="http://api.zeromq.org/3-2:zmq_msg_close">zmq_msg_close()</a></tt>.</li>
<li>Access message content: <tt><a href="http://api.zeromq.org/3-2:zmq_msg_data">zmq_msg_data()</a></tt>, <tt><a href="http://api.zeromq.org/3-2:zmq_msg_size">zmq_msg_size()</a></tt>, <tt><a href="http://api.zeromq.org/3-2:zmq_msg_more">zmq_msg_more()</a></tt>.</li>
<li>Work with message properties: <tt><a href="http://api.zeromq.org/3-2:zmq_msg_get">zmq_msg_get()</a></tt>, <tt><a href="http://api.zeromq.org/3-2:zmq_msg_set">zmq_msg_set()</a></tt>.</li>
<li>Message manipulation: <tt><a href="http://api.zeromq.org/3-2:zmq_msg_copy">zmq_msg_copy()</a></tt>, <tt><a href="http://api.zeromq.org/3-2:zmq_msg_move">zmq_msg_move()</a></tt>.</li>
</ul>
<p>On the wire, ZeroMQ messages are blobs of any size from zero upwards that fit in memory. You do your own serialization using protocol buffers, msgpack, JSON, or whatever else your applications need to speak. It's wise to choose a data representation that is portable, but you can make your own decisions about trade-offs.</p>
<p>In memory, ZeroMQ messages are <tt>zmq_msg_t</tt> structures (or classes depending on your language). Here are the basic ground rules for using ZeroMQ messages in C:</p>
<ul>
<li>You create and pass around <tt>zmq_msg_t</tt> objects, not blocks of data.</li>
</ul>
<ul>
<li>To read a message, you use <tt><a href="http://api.zeromq.org/3-2:zmq_msg_init">zmq_msg_init()</a></tt> to create an empty message, and then you pass that to <tt><a href="http://api.zeromq.org/3-2:zmq_msg_recv">zmq_msg_recv()</a></tt>.</li>
</ul>
<ul>
<li>To write a message from new data, you use <tt><a href="http://api.zeromq.org/3-2:zmq_msg_init_size">zmq_msg_init_size()</a></tt> to create a message and at the same time allocate a block of data of some size. You then fill that data using <tt>memcpy</tt>, and pass the message to <tt><a href="http://api.zeromq.org/3-2:zmq_msg_send">zmq_msg_send()</a></tt>.</li>
</ul>
<ul>
<li>To release (not destroy) a message, you call <tt><a href="http://api.zeromq.org/3-2:zmq_msg_close">zmq_msg_close()</a></tt>. This drops a reference, and eventually ZeroMQ will destroy the message.</li>
</ul>
<ul>
<li>To access the message content, you use <tt><a href="http://api.zeromq.org/3-2:zmq_msg_data">zmq_msg_data()</a></tt>. To know how much data the message contains, use <tt><a href="http://api.zeromq.org/3-2:zmq_msg_size">zmq_msg_size()</a></tt>.</li>
</ul>
<ul>
<li>Do not use <tt><a href="http://api.zeromq.org/3-2:zmq_msg_move">zmq_msg_move()</a></tt>, <tt><a href="http://api.zeromq.org/3-2:zmq_msg_copy">zmq_msg_copy()</a></tt>, or <tt><a href="http://api.zeromq.org/3-2:zmq_msg_init_data">zmq_msg_init_data()</a></tt> unless you read the man pages and know precisely why you need these.</li>
</ul>
<ul>
<li>After you pass a message to <tt><a href="http://api.zeromq.org/3-2:zmq_msg_send">zmq_msg_send()</a></tt>, ØMQ will clear the message, i.e., set the size to zero. You cannot send the same message twice, and you cannot access the message data after sending it.</li>
</ul>
<ul>
<li>These rules don't apply if you use <tt><a href="http://api.zeromq.org/3-2:zmq_send">zmq_send()</a></tt> and <tt><a href="http://api.zeromq.org/3-2:zmq_recv">zmq_recv()</a></tt>, to which you pass byte arrays, not message structures.</li>
</ul>
<p>If you want to send the same message more than once, and it's sizable, create a second message, initialize it using <tt><a href="http://api.zeromq.org/3-2:zmq_msg_init">zmq_msg_init()</a></tt>, and then use <tt><a href="http://api.zeromq.org/3-2:zmq_msg_copy">zmq_msg_copy()</a></tt> to create a copy of the first message. This does not copy the data but copies a reference. You can then send the message twice (or more, if you create more copies) and the message will only be finally destroyed when the last copy is sent or closed.</p>
<p>ZeroMQ also supports <em>multipart</em> messages, which let you send or receive a list of frames as a single on-the-wire message. This is widely used in real applications and we'll look at that later in this chapter and in <a href="http://zguide.zeromq.org/page:all#advanced-request-reply">Chapter 3 - Advanced Request-Reply Patterns</a>.</p>
<p>Frames (also called "message parts" in the ZeroMQ reference manual pages) are the basic wire format for ZeroMQ messages. A frame is a length-specified block of data. The length can be zero upwards. If you've done any TCP programming you'll appreciate why frames are a useful answer to the question "how much data am I supposed to read of this network socket now?"</p>
<p>There is a wire-level <a href="http://rfc.zeromq.org/spec:15">protocol called ZMTP</a> that defines how ZeroMQ reads and writes frames on a TCP connection. If you're interested in how this works, the spec is quite short.</p>
<p>Originally, a ZeroMQ message was one frame, like UDP. We later extended this with multipart messages, which are quite simply series of frames with a "more" bit set to one, followed by one with that bit set to zero. The ZeroMQ API then lets you write messages with a "more" flag and when you read messages, it lets you check if there's "more".</p>
<p>In the low-level ZeroMQ API and the reference manual, therefore, there's some fuzziness about messages versus frames. So here's a useful lexicon:</p>
<ul>
<li>A message can be one or more parts.</li>
<li>These parts are also called "frames".</li>
<li>Each part is a <tt>zmq_msg_t</tt> object.</li>
<li>You send and receive each part separately, in the low-level API.</li>
<li>Higher-level APIs provide wrappers to send entire multipart messages.</li>
</ul>
<p>Some other things that are worth knowing about messages:</p>
<ul>
<li>You may send zero-length messages, e.g., for sending a signal from one thread to another.</li>
</ul>
<ul>
<li>ZeroMQ guarantees to deliver all the parts (one or more) for a message, or none of them.</li>
</ul>
<ul>
<li>ZeroMQ does not send the message (single or multipart) right away, but at some indeterminate later time. A multipart message must therefore fit in memory.</li>
</ul>
<ul>
<li>A message (single or multipart) must fit in memory. If you want to send files of arbitrary sizes, you should break them into pieces and send each piece as separate single-part messages. <em>Using multipart data will not reduce memory consumption.</em></li>
</ul>
<ul>
<li>You must call <tt><a href="http://api.zeromq.org/3-2:zmq_msg_close">zmq_msg_close()</a></tt> when finished with a received message, in languages that don't automatically destroy objects when a scope closes. You don't call this method after sending a message.</li>
</ul>
<p>And to be repetitive, do not use <tt><a href="http://api.zeromq.org/3-2:zmq_msg_init_data">zmq_msg_init_data()</a></tt> yet. This is a zero-copy method and is guaranteed to create trouble for you. There are far more important things to learn about ZeroMQ before you start to worry about shaving off microseconds.</p>
<p>This rich API can be tiresome to work with. The methods are optimized for performance, not simplicity. If you start using these you will almost definitely get them wrong until you've read the man pages with some care. So one of the main jobs of a good language binding is to wrap this API up in classes that are easier to use.</p>
<p><a name="Handling-Multiple-Sockets"></a><a name="header-36"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc35"><span><a href="http://zguide.zeromq.org/page:all#Handling-Multiple-Sockets">Handling Multiple Sockets</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-35">prev</a> <a href="http://zguide.zeromq.org/page:all#header-37">next</a></td>
</tr>
</tbody></table>
<p>In all the examples so far, the main loop of most examples has been:</p>
<ol>
<li>Wait for message on socket.</li>
<li>Process message.</li>
<li>Repeat.</li>
</ol>
<p>What if we want to read from multiple endpoints at the same time? The simplest way is to connect one socket to all the endpoints and get ZeroMQ to do the fan-in for us. This is legal if the remote endpoints are in the same pattern, but it would be wrong to connect a PULL socket to a PUB endpoint.</p>
<p>To actually read from multiple sockets all at once, use <tt><a href="http://api.zeromq.org/3-2:zmq_poll">zmq_poll()</a></tt>. An even better way might be to wrap <tt><a href="http://api.zeromq.org/3-2:zmq_poll">zmq_poll()</a></tt> in a framework that turns it into a nice event-driven <em>reactor</em>, but it's significantly more work than we want to cover here.</p>
<p>Let's start with a dirty hack, partly for the fun of not doing it right, but mainly because it lets me show you how to do nonblocking socket reads. Here is a simple example of reading from two sockets using nonblocking reads. This rather confused program acts both as a subscriber to weather updates, and a worker for parallel tasks:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">msreader:&nbsp;Multiple&nbsp;socket&nbsp;reader&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">msreader:&nbsp;Multiple&nbsp;socket&nbsp;reader&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Reading from multiple sockets<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This version uses a simple recv loop</span></p>
<p>#include "zhelpers.h"</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Connect to task ventilator</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zmq_ctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>receiver <span style="color:#666666">=</span> zmq_socket (context, ZMQ_PULL);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_connect (receiver, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5557"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Connect to weather server</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>subscriber <span style="color:#666666">=</span> zmq_socket (context, ZMQ_SUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_connect (subscriber, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5556"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_setsockopt (subscriber, ZMQ_SUBSCRIBE, <span style="color:#BA2121">"10001 "</span>, <span style="color:#666666">6</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Process messages from both sockets</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We prioritize traffic from the task ventilator</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> msg <span style="white-space: pre-wrap;">[</span><span style="color:#666666">256</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">int</span> size <span style="color:#666666">=</span> zmq_recv (receiver, msg, <span style="color:#666666">255</span>, ZMQ_DONTWAIT);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (size <span style="color:#666666">!=</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Process task</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">int</span> size <span style="color:#666666">=</span> zmq_recv (subscriber, msg, <span style="color:#666666">255</span>, ZMQ_DONTWAIT);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (size <span style="color:#666666">!=</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Process weather update</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>No activity, so sleep for 1 msec</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>s_sleep (<span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (receiver);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (subscriber);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_ctx_destroy (context);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:msreader" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:msreader" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/clj:msreader" target="_blank">Clojure</a> | <a href="http://zguide.zeromq.org/lisp:msreader" target="_blank">CL</a> | <a href="http://zguide.zeromq.org/dpr:msreader" target="_blank">Delphi</a> | <a href="http://zguide.zeromq.org/es:msreader" target="_blank">Erlang</a> | <a href="http://zguide.zeromq.org/fsx:msreader" target="_blank">F#</a> | <a href="http://zguide.zeromq.org/flx:msreader" target="_blank">Felix</a> | <a href="http://zguide.zeromq.org/go:msreader" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/java:msreader" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:msreader" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/m:msreader" target="_blank">Objective-C</a> | <a href="http://zguide.zeromq.org/pl:msreader" target="_blank">Perl</a> | <a href="http://zguide.zeromq.org/php:msreader" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:msreader" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rb:msreader" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/scala:msreader" target="_blank">Scala</a> | <a href="http://zguide.zeromq.org/tcl:msreader" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | Haskell | Haxe | Node.js | ooc | Q | Racket</a></span>
<p>The cost of this approach is some additional latency on the first message (the sleep at the end of the loop, when there are no waiting messages to process). This would be a problem in applications where submillisecond latency was vital. Also, you need to check the documentation for nanosleep() or whatever function you use to make sure it does not busy-loop.</p>
<p>You can treat the sockets fairly by reading first from one, then the second rather than prioritizing them as we did in this example.</p>
<p>Now let's see the same senseless little application done right, using <tt><a href="http://api.zeromq.org/3-2:zmq_poll">zmq_poll()</a></tt>:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">mspoller:&nbsp;Multiple&nbsp;socket&nbsp;poller&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">mspoller:&nbsp;Multiple&nbsp;socket&nbsp;poller&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Reading from multiple sockets<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This version uses zmq_poll()</span></p>
<p>#include "zhelpers.h"</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Connect to task ventilator</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zmq_ctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>receiver <span style="color:#666666">=</span> zmq_socket (context, ZMQ_PULL);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_connect (receiver, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5557"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Connect to weather server</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>subscriber <span style="color:#666666">=</span> zmq_socket (context, ZMQ_SUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_connect (subscriber, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5556"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_setsockopt (subscriber, ZMQ_SUBSCRIBE, <span style="color:#BA2121">"10001 "</span>, <span style="color:#666666">6</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Process messages from both sockets</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> msg <span style="white-space: pre-wrap;">[</span><span style="color:#666666">256</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_pollitem_t items <span style="white-space: pre-wrap;">[]</span> <span style="color:#666666">=</span> {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>{ receiver,<tt><span style="white-space: pre-wrap;">   </span></tt><span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> },<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>{ subscriber, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> }<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_poll (items, <span style="color:#666666">2</span>, <span style="color:#666666">-</span><span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">int</span> size <span style="color:#666666">=</span> zmq_recv (receiver, msg, <span style="color:#666666">255</span>, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (size <span style="color:#666666">!=</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Process task</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">int</span> size <span style="color:#666666">=</span> zmq_recv (subscriber, msg, <span style="color:#666666">255</span>, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (size <span style="color:#666666">!=</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Process weather update</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (subscriber);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_ctx_destroy (context);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:mspoller" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:mspoller" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/clj:mspoller" target="_blank">Clojure</a> | <a href="http://zguide.zeromq.org/lisp:mspoller" target="_blank">CL</a> | <a href="http://zguide.zeromq.org/dpr:mspoller" target="_blank">Delphi</a> | <a href="http://zguide.zeromq.org/es:mspoller" target="_blank">Erlang</a> | <a href="http://zguide.zeromq.org/fsx:mspoller" target="_blank">F#</a> | <a href="http://zguide.zeromq.org/flx:mspoller" target="_blank">Felix</a> | <a href="http://zguide.zeromq.org/go:mspoller" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:mspoller" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/java:mspoller" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:mspoller" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/js:mspoller" target="_blank">Node.js</a> | <a href="http://zguide.zeromq.org/m:mspoller" target="_blank">Objective-C</a> | <a href="http://zguide.zeromq.org/pl:mspoller" target="_blank">Perl</a> | <a href="http://zguide.zeromq.org/php:mspoller" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:mspoller" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rb:mspoller" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/scala:mspoller" target="_blank">Scala</a> | <a href="http://zguide.zeromq.org/tcl:mspoller" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | Haxe | ooc | Q | Racket</a></span>
<p>The items structure has these four members:</p>
<div class="code">
<p><span style="color:#008000"><strong>typedef</strong></span> <span style="color:#008000"><strong>struct</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>socket;<tt><span style="white-space: pre-wrap;">       </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>ZeroMQ socket to poll on</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> fd;<tt><span style="white-space: pre-wrap;">             </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>OR, native file handle to poll on</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">short</span> events;<tt><span style="white-space: pre-wrap;">       </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Events to poll on</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">short</span> revents;<tt><span style="white-space: pre-wrap;">      </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Events returned after poll</em></span><br>
} zmq_pollitem_t;</p>
</div>
<p><a name="Multipart-Messages"></a><a name="header-37"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc36"><span><a href="http://zguide.zeromq.org/page:all#Multipart-Messages">Multipart Messages</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-36">prev</a> <a href="http://zguide.zeromq.org/page:all#header-38">next</a></td>
</tr>
</tbody></table>
<p>ZeroMQ lets us compose a message out of several frames, giving us a "multipart message". Realistic applications use multipart messages heavily, both for wrapping messages with address information and for simple serialization. We'll look at reply envelopes later.</p>
<p>What we'll learn now is simply how to blindly and safely read and write multipart messages in any application (such as a proxy) that needs to forward messages without inspecting them.</p>
<p>When you work with multipart messages, each part is a <tt>zmq_msg</tt> item. E.g., if you are sending a message with five parts, you must construct, send, and destroy five <tt>zmq_msg</tt> items. You can do this in advance (and store the <tt>zmq_msg</tt> items in an array or other structure), or as you send them, one-by-one.</p>
<p>Here is how we send the frames in a multipart message (we receive each frame into a message object):</p>
<div class="code">
<p>zmq_msg_send (<span style="color:#666666">&amp;</span>message, socket, ZMQ_SNDMORE);<br>
…<br>
zmq_msg_send (<span style="color:#666666">&amp;</span>message, socket, ZMQ_SNDMORE);<br>
…<br>
zmq_msg_send (<span style="color:#666666">&amp;</span>message, socket, <span style="color:#666666">0</span>);</p>
</div>
<p>Here is how we receive and process all the parts in a message, be it single part or multipart:</p>
<div class="code">
<p><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_msg_t message;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_msg_init (<span style="color:#666666">&amp;</span>message);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_msg_recv (<span style="color:#666666">&amp;</span>message, socket, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Process the message frame</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>…<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_msg_close (<span style="color:#666666">&amp;</span>message);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>zmq_msg_more (<span style="color:#666666">&amp;</span>message))<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">      </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Last message frame</em></span><br>
}</p>
</div>
<p>Some things to know about multipart messages:</p>
<ul>
<li>When you send a multipart message, the first part (and all following parts) are only actually sent on the wire when you send the final part.</li>
<li>If you are using <tt><a href="http://api.zeromq.org/3-2:zmq_poll">zmq_poll()</a></tt>, when you receive the first part of a message, all the rest has also arrived.</li>
<li>You will receive all parts of a message, or none at all.</li>
<li>Each part of a message is a separate <tt>zmq_msg</tt> item.</li>
<li>You will receive all parts of a message whether or not you check the more property.</li>
<li>On sending, ZeroMQ queues message frames in memory until the last is received, then sends them all.</li>
<li>There is no way to cancel a partially sent message, except by closing the socket.</li>
</ul>
<p><a name="Intermediaries-and-Proxies"></a><a name="header-38"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc37"><span><a href="http://zguide.zeromq.org/page:all#Intermediaries-and-Proxies">Intermediaries and Proxies</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-37">prev</a> <a href="http://zguide.zeromq.org/page:all#header-39">next</a></td>
</tr>
</tbody></table>
<p>ZeroMQ aims for decentralized intelligence, but that doesn't mean your network is empty space in the middle. It's filled with message-aware infrastructure and quite often, we build that infrastructure with ZeroMQ. The ZeroMQ plumbing can range from tiny pipes to full-blown service-oriented brokers. The messaging industry calls this <em>intermediation</em>, meaning that the stuff in the middle deals with either side. In ZeroMQ, we call these proxies, queues, forwarders, device, or brokers, depending on the context.</p>
<p>This pattern is extremely common in the real world and is why our societies and economies are filled with intermediaries who have no other real function than to reduce the complexity and scaling costs of larger networks. Real-world intermediaries are typically called wholesalers, distributors, managers, and so on.</p>
<p><a name="The-Dynamic-Discovery-Problem"></a><a name="header-39"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc38"><span><a href="http://zguide.zeromq.org/page:all#The-Dynamic-Discovery-Problem">The Dynamic Discovery Problem</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-38">prev</a> <a href="http://zguide.zeromq.org/page:all#header-40">next</a></td>
</tr>
</tbody></table>
<p>One of the problems you will hit as you design larger distributed architectures is discovery. That is, how do pieces know about each other? It's especially difficult if pieces come and go, so we call this the "dynamic discovery problem".</p>
<p>There are several solutions to dynamic discovery. The simplest is to entirely avoid it by hard-coding (or configuring) the network architecture so discovery is done by hand. That is, when you add a new piece, you reconfigure the network to know about it.</p>
<p><strong>Figure 12 - Small-Scale Pub-Sub Network</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig12.png" alt="fig12.png" class="image"></div>
<p>In practice, this leads to increasingly fragile and unwieldy architectures. Let's say you have one publisher and a hundred subscribers. You connect each subscriber to the publisher by configuring a publisher endpoint in each subscriber. That's easy. Subscribers are dynamic; the publisher is static. Now say you add more publishers. Suddenly, it's not so easy any more. If you continue to connect each subscriber to each publisher, the cost of avoiding dynamic discovery gets higher and higher.</p>
<p><strong>Figure 13 - Pub-Sub Network with a Proxy</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig13.png" alt="fig13.png" class="image"></div>
<p>There are quite a few answers to this, but the very simplest answer is to add an intermediary; that is, a static point in the network to which all other nodes connect. In classic messaging, this is the job of the message broker. ZeroMQ doesn't come with a message broker as such, but it lets us build intermediaries quite easily.</p>
<p>You might wonder, if all networks eventually get large enough to need intermediaries, why don't we simply have a message broker in place for all applications? For beginners, it's a fair compromise. Just always use a star topology, forget about performance, and things will usually work. However, message brokers are greedy things; in their role as central intermediaries, they become too complex, too stateful, and eventually a problem.</p>
<p>It's better to think of intermediaries as simple stateless message switches. A good analogy is an HTTP proxy; it's there, but doesn't have any special role. Adding a pub-sub proxy solves the dynamic discovery problem in our example. We set the proxy in the "middle" of the network. The proxy opens an XSUB socket, an XPUB socket, and binds each to well-known IP addresses and ports. Then, all other processes connect to the proxy, instead of to each other. It becomes trivial to add more subscribers or publishers.</p>
<p><strong>Figure 14 - Extended Pub-Sub</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig14.png" alt="fig14.png" class="image"></div>
<p>We need XPUB and XSUB sockets because ZeroMQ does subscription forwarding from subscribers to publishers. XSUB and XPUB are exactly like SUB and PUB except they expose subscriptions as special messages. The proxy has to forward these subscription messages from subscriber side to publisher side, by reading them from the XPUB socket and writing them to the XSUB socket. This is the main use case for XSUB and XPUB.</p>
<p><a name="Shared-Queue-DEALER-and-ROUTER-sockets"></a><a name="header-40"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc39"><span><a href="http://zguide.zeromq.org/page:all#Shared-Queue-DEALER-and-ROUTER-sockets">Shared Queue (DEALER and ROUTER sockets)</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-39">prev</a> <a href="http://zguide.zeromq.org/page:all#header-41">next</a></td>
</tr>
</tbody></table>
<p>In the Hello World client/server application, we have one client that talks to one service. However, in real cases we usually need to allow multiple services as well as multiple clients. This lets us scale up the power of the service (many threads or processes or nodes rather than just one). The only constraint is that services must be stateless, all state being in the request or in some shared storage such as a database.</p>
<p><strong>Figure 15 - Request Distribution</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig15.png" alt="fig15.png" class="image"></div>
<p>There are two ways to connect multiple clients to multiple servers. The brute force way is to connect each client socket to multiple service endpoints. One client socket can connect to multiple service sockets, and the REQ socket will then distribute requests among these services. Let's say you connect a client socket to three service endpoints; A, B, and C. The client makes requests R1, R2, R3, R4. R1 and R4 go to service A, R2 goes to B, and R3 goes to service C.</p>
<p>This design lets you add more clients cheaply. You can also add more services. Each client will distribute its requests to the services. But each client has to know the service topology. If you have 100 clients and then you decide to add three more services, you need to reconfigure and restart 100 clients in order for the clients to know about the three new services.</p>
<p>That's clearly not the kind of thing we want to be doing at 3 a.m. when our supercomputing cluster has run out of resources and we desperately need to add a couple of hundred of new service nodes. Too many static pieces are like liquid concrete: knowledge is distributed and the more static pieces you have, the more effort it is to change the topology. What we want is something sitting in between clients and services that centralizes all knowledge of the topology. Ideally, we should be able to add and remove services or clients at any time without touching any other part of the topology.</p>
<p>So we'll write a little message queuing broker that gives us this flexibility. The broker binds to two endpoints, a frontend for clients and a backend for services. It then uses <tt><a href="http://api.zeromq.org/3-2:zmq_poll">zmq_poll()</a></tt> to monitor these two sockets for activity and when it has some, it shuttles messages between its two sockets. It doesn't actually manage any queues explicitly—ZeroMQ does that automatically on each socket.</p>
<p>When you use REQ to talk to REP, you get a strictly synchronous request-reply dialog. The client sends a request. The service reads the request and sends a reply. The client then reads the reply. If either the client or the service try to do anything else (e.g., sending two requests in a row without waiting for a response), they will get an error.</p>
<p>But our broker has to be nonblocking. Obviously, we can use <tt><a href="http://api.zeromq.org/3-2:zmq_poll">zmq_poll()</a></tt> to wait for activity on either socket, but we can't use REP and REQ.</p>
<p><strong>Figure 16 - Extended Request-Reply</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig16.png" alt="fig16.png" class="image"></div>
<p>Luckily, there are two sockets called DEALER and ROUTER that let you do nonblocking request-response. You'll see in <a href="http://zguide.zeromq.org/page:all#advanced-request-reply">Chapter 3 - Advanced Request-Reply Patterns</a> how DEALER and ROUTER sockets let you build all kinds of asynchronous request-reply flows. For now, we're just going to see how DEALER and ROUTER let us extend REQ-REP across an intermediary, that is, our little broker.</p>
<p>In this simple extended request-reply pattern, REQ talks to ROUTER and DEALER talks to REP. In between the DEALER and ROUTER, we have to have code (like our broker) that pulls messages off the one socket and shoves them onto the other.</p>
<p>The request-reply broker binds to two endpoints, one for clients to connect to (the frontend socket) and one for workers to connect to (the backend). To test this broker, you will want to change your workers so they connect to the backend socket. Here is a client that shows what I mean:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">rrclient:&nbsp;Request-reply&nbsp;client&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">rrclient:&nbsp;Request-reply&nbsp;client&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Hello World client<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Connects REQ socket to tcp:<span style="white-space: pre-wrap;">//</span>localhost:5559<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Sends "Hello" to server, expects "World" back</span></p>
<p>#include "zhelpers.h"</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zmq_ctx_new ();</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Socket to talk to server</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>requester <span style="color:#666666">=</span> zmq_socket (context, ZMQ_REQ);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_connect (requester, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5559"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> request_nbr;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (request_nbr <span style="color:#666666">=</span> <span style="color:#666666">0</span>; request_nbr <span style="color:#666666">!=</span> <span style="color:#666666">10</span>; request_nbr<span style="color:#666666">++</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>s_send (requester, <span style="color:#BA2121">"Hello"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>string <span style="color:#666666">=</span> s_recv (requester);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"Received reply %d <span style="white-space: pre-wrap;">[</span>%s<span style="white-space: pre-wrap;">]</span></span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, request_nbr, string);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (string);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (requester);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_ctx_destroy (context);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:rrclient" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:rrclient" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/clj:rrclient" target="_blank">Clojure</a> | <a href="http://zguide.zeromq.org/lisp:rrclient" target="_blank">CL</a> | <a href="http://zguide.zeromq.org/dpr:rrclient" target="_blank">Delphi</a> | <a href="http://zguide.zeromq.org/es:rrclient" target="_blank">Erlang</a> | <a href="http://zguide.zeromq.org/fsx:rrclient" target="_blank">F#</a> | <a href="http://zguide.zeromq.org/go:rrclient" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:rrclient" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:rrclient" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:rrclient" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:rrclient" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/js:rrclient" target="_blank">Node.js</a> | <a href="http://zguide.zeromq.org/pl:rrclient" target="_blank">Perl</a> | <a href="http://zguide.zeromq.org/php:rrclient" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:rrclient" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rkt:rrclient" target="_blank">Racket</a> | <a href="http://zguide.zeromq.org/rb:rrclient" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/scala:rrclient" target="_blank">Scala</a> | <a href="http://zguide.zeromq.org/tcl:rrclient" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | Felix | Objective-C | ooc | Q</a></span>
<p>Here is the worker:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">rrworker:&nbsp;Request-reply&nbsp;worker&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">rrworker:&nbsp;Request-reply&nbsp;worker&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Hello World worker<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Connects REP socket to tcp:<span style="white-space: pre-wrap;">//</span>localhost:5560<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Expects "Hello" from client, replies with "World"</span></span></p>
<p><span style="color:#BC7A00">#include "zhelpers.h"<br>
#include &lt;unistd.h&gt;</span></p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zmq_ctx_new ();</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Socket to talk to clients</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>responder <span style="color:#666666">=</span> zmq_socket (context, ZMQ_REP);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_connect (responder, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5560"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Wait for next request from client</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>string <span style="color:#666666">=</span> s_recv (responder);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"Received request: <span style="white-space: pre-wrap;">[</span>%s<span style="white-space: pre-wrap;">]</span></span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, string);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (string);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Do some 'work'</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>sleep (<span style="color:#666666">1</span>);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send reply back to client</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>s_send (responder, <span style="color:#BA2121">"World"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We never get here, but clean up anyhow</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (responder);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_ctx_destroy (context);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:rrworker" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:rrworker" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/clj:rrworker" target="_blank">Clojure</a> | <a href="http://zguide.zeromq.org/lisp:rrworker" target="_blank">CL</a> | <a href="http://zguide.zeromq.org/dpr:rrworker" target="_blank">Delphi</a> | <a href="http://zguide.zeromq.org/es:rrworker" target="_blank">Erlang</a> | <a href="http://zguide.zeromq.org/fsx:rrworker" target="_blank">F#</a> | <a href="http://zguide.zeromq.org/go:rrworker" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:rrworker" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:rrworker" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:rrworker" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:rrworker" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/js:rrworker" target="_blank">Node.js</a> | <a href="http://zguide.zeromq.org/pl:rrworker" target="_blank">Perl</a> | <a href="http://zguide.zeromq.org/php:rrworker" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:rrworker" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rkt:rrworker" target="_blank">Racket</a> | <a href="http://zguide.zeromq.org/rb:rrworker" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/scala:rrworker" target="_blank">Scala</a> | <a href="http://zguide.zeromq.org/tcl:rrworker" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | Felix | Objective-C | ooc | Q</a></span>
<p>And here is the broker, which properly handles multipart messages:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">rrbroker:&nbsp;Request-reply&nbsp;broker&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">rrbroker:&nbsp;Request-reply&nbsp;broker&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Simple request-reply broker</span></p>
<p>#include "zhelpers.h"</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Prepare our context and sockets</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zmq_ctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>frontend <span style="color:#666666">=</span> zmq_socket (context, ZMQ_ROUTER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>backend<tt><span style="white-space: pre-wrap;">  </span></tt><span style="color:#666666">=</span> zmq_socket (context, ZMQ_DEALER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_bind (frontend, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5559"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_bind (backend,<tt><span style="white-space: pre-wrap;">  </span></tt><span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5560"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Initialize poll set</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_pollitem_t items <span style="white-space: pre-wrap;">[]</span> <span style="color:#666666">=</span> {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>{ frontend, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> },<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>{ backend,<tt><span style="white-space: pre-wrap;">  </span></tt><span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> }<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Switch messages between sockets</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_msg_t message;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_poll (items, <span style="color:#666666">2</span>, <span style="color:#666666">-</span><span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Process all parts of the message</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmq_msg_init (<span style="color:#666666">&amp;</span>message);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmq_msg_recv (<span style="color:#666666">&amp;</span>message, frontend, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#B00040">int</span> more <span style="color:#666666">=</span> zmq_msg_more (<span style="color:#666666">&amp;</span>message);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmq_msg_send (<span style="color:#666666">&amp;</span>message, backend, more<span style="color:#666666">?</span> ZMQ_SNDMORE<span style="color:#666666">:</span> <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmq_msg_close (<span style="color:#666666">&amp;</span>message);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>more)<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">      </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Last message part</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Process all parts of the message</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmq_msg_init (<span style="color:#666666">&amp;</span>message);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmq_msg_recv (<span style="color:#666666">&amp;</span>message, backend, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#B00040">int</span> more <span style="color:#666666">=</span> zmq_msg_more (<span style="color:#666666">&amp;</span>message);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmq_msg_send (<span style="color:#666666">&amp;</span>message, frontend, more<span style="color:#666666">?</span> ZMQ_SNDMORE<span style="color:#666666">:</span> <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmq_msg_close (<span style="color:#666666">&amp;</span>message);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>more)<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">      </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Last message part</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We never get here, but clean up anyhow</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (frontend);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (backend);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_ctx_destroy (context);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:rrbroker" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:rrbroker" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/clj:rrbroker" target="_blank">Clojure</a> | <a href="http://zguide.zeromq.org/lisp:rrbroker" target="_blank">CL</a> | <a href="http://zguide.zeromq.org/dpr:rrbroker" target="_blank">Delphi</a> | <a href="http://zguide.zeromq.org/es:rrbroker" target="_blank">Erlang</a> | <a href="http://zguide.zeromq.org/fsx:rrbroker" target="_blank">F#</a> | <a href="http://zguide.zeromq.org/go:rrbroker" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:rrbroker" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:rrbroker" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:rrbroker" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:rrbroker" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/js:rrbroker" target="_blank">Node.js</a> | <a href="http://zguide.zeromq.org/pl:rrbroker" target="_blank">Perl</a> | <a href="http://zguide.zeromq.org/php:rrbroker" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:rrbroker" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rb:rrbroker" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/scala:rrbroker" target="_blank">Scala</a> | <a href="http://zguide.zeromq.org/tcl:rrbroker" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | Felix | Objective-C | ooc | Q | Racket</a></span>
<p><strong>Figure 17 - Request-Reply Broker</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig17.png" alt="fig17.png" class="image"></div>
<p>Using a request-reply broker makes your client/server architectures easier to scale because clients don't see workers, and workers don't see clients. The only static node is the broker in the middle.</p>
<p><a name="ZeroMQ-s-Built-In-Proxy-Function"></a><a name="header-41"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc40"><span><a href="http://zguide.zeromq.org/page:all#ZeroMQ-s-Built-In-Proxy-Function">ZeroMQ's Built-In Proxy Function</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-40">prev</a> <a href="http://zguide.zeromq.org/page:all#header-42">next</a></td>
</tr>
</tbody></table>
<p>It turns out that the core loop in the previous section's <tt>rrbroker</tt> is very useful, and reusable. It lets us build pub-sub forwarders and shared queues and other little intermediaries with very little effort. ZeroMQ wraps this up in a single method, <tt><a href="http://api.zeromq.org/3-2:zmq_proxy">zmq_proxy()</a></tt>:</p>
<div class="code">
<p>zmq_proxy (frontend, backend, capture);</p>
</div>
<p>The two (or three sockets, if we want to capture data) must be properly connected, bound, and configured. When we call the <tt>zmq_proxy</tt> method, it's exactly like starting the main loop of <tt>rrbroker</tt>. Let's rewrite the request-reply broker to call <tt>zmq_proxy</tt>, and re-badge this as an expensive-sounding "message queue" (people have charged houses for code that did less):</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">msgqueue:&nbsp;Message&nbsp;queue&nbsp;broker&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">msgqueue:&nbsp;Message&nbsp;queue&nbsp;broker&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Simple message queuing broker<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Same as request-reply broker but using shared queue proxy</span></p>
<p>#include "zhelpers.h"</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zmq_ctx_new ();</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Socket facing clients</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>frontend <span style="color:#666666">=</span> zmq_socket (context, ZMQ_ROUTER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> rc <span style="color:#666666">=</span> zmq_bind (frontend, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5559"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (rc <span style="color:#666666">==</span> <span style="color:#666666">0</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Socket facing services</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>backend <span style="color:#666666">=</span> zmq_socket (context, ZMQ_DEALER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>rc <span style="color:#666666">=</span> zmq_bind (backend, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5560"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (rc <span style="color:#666666">==</span> <span style="color:#666666">0</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Start the proxy</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_proxy (frontend, backend, <span style="color:#008000">NULL</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We never get here…</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (frontend);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (backend);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_ctx_destroy (context);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:msgqueue" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:msgqueue" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/clj:msgqueue" target="_blank">Clojure</a> | <a href="http://zguide.zeromq.org/lisp:msgqueue" target="_blank">CL</a> | <a href="http://zguide.zeromq.org/dpr:msgqueue" target="_blank">Delphi</a> | <a href="http://zguide.zeromq.org/es:msgqueue" target="_blank">Erlang</a> | <a href="http://zguide.zeromq.org/fsx:msgqueue" target="_blank">F#</a> | <a href="http://zguide.zeromq.org/go:msgqueue" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:msgqueue" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:msgqueue" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:msgqueue" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:msgqueue" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/js:msgqueue" target="_blank">Node.js</a> | <a href="http://zguide.zeromq.org/pl:msgqueue" target="_blank">Perl</a> | <a href="http://zguide.zeromq.org/php:msgqueue" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:msgqueue" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/q:msgqueue" target="_blank">Q</a> | <a href="http://zguide.zeromq.org/rb:msgqueue" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/tcl:msgqueue" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | Felix | Objective-C | ooc | Racket | Scala</a></span>
<p>If you're like most ZeroMQ users, at this stage your mind is starting to think, "What kind of evil stuff can I do if I plug random socket types into the proxy?" The short answer is: try it and work out what is happening. In practice, you would usually stick to ROUTER/DEALER, XSUB/XPUB, or PULL/PUSH.</p>
<p><a name="Transport-Bridging"></a><a name="header-42"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc41"><span><a href="http://zguide.zeromq.org/page:all#Transport-Bridging">Transport Bridging</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-41">prev</a> <a href="http://zguide.zeromq.org/page:all#header-43">next</a></td>
</tr>
</tbody></table>
<p>A frequent request from ZeroMQ users is, "How do I connect my ZeroMQ network with technology X?" where X is some other networking or messaging technology.</p>
<p><strong>Figure 18 - Pub-Sub Forwarder Proxy</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig18.png" alt="fig18.png" class="image"></div>
<p>The simple answer is to build a <em>bridge</em>. A bridge is a small application that speaks one protocol at one socket, and converts to/from a second protocol at another socket. A protocol interpreter, if you like. A common bridging problem in ZeroMQ is to bridge two transports or networks.</p>
<p>As an example, we're going to write a little proxy that sits in between a publisher and a set of subscribers, bridging two networks. The frontend socket (SUB) faces the internal network where the weather server is sitting, and the backend (PUB) faces subscribers on the external network. It subscribes to the weather service on the frontend socket, and republishes its data on the backend socket.</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">wuproxy:&nbsp;Weather&nbsp;update&nbsp;proxy&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">wuproxy:&nbsp;Weather&nbsp;update&nbsp;proxy&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Weather proxy device</span></p>
<p>#include "zhelpers.h"</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zmq_ctx_new ();</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This is where the weather server sits</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>frontend <span style="color:#666666">=</span> zmq_socket (context, ZMQ_XSUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_connect (frontend, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>192.168.55.210:5556"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This is our public endpoint for subscribers</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>backend <span style="color:#666666">=</span> zmq_socket (context, ZMQ_XPUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_bind (backend, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>10.1.1.0:8100"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Run the proxy until the user interrupts us</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_proxy (frontend, backend, <span style="color:#008000">NULL</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (frontend);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (backend);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_ctx_destroy (context);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:wuproxy" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:wuproxy" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/clj:wuproxy" target="_blank">Clojure</a> | <a href="http://zguide.zeromq.org/lisp:wuproxy" target="_blank">CL</a> | <a href="http://zguide.zeromq.org/dpr:wuproxy" target="_blank">Delphi</a> | <a href="http://zguide.zeromq.org/es:wuproxy" target="_blank">Erlang</a> | <a href="http://zguide.zeromq.org/fsx:wuproxy" target="_blank">F#</a> | <a href="http://zguide.zeromq.org/go:wuproxy" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:wuproxy" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:wuproxy" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:wuproxy" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:wuproxy" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/js:wuproxy" target="_blank">Node.js</a> | <a href="http://zguide.zeromq.org/pl:wuproxy" target="_blank">Perl</a> | <a href="http://zguide.zeromq.org/php:wuproxy" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:wuproxy" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rb:wuproxy" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/scala:wuproxy" target="_blank">Scala</a> | <a href="http://zguide.zeromq.org/tcl:wuproxy" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | Felix | Objective-C | ooc | Q | Racket</a></span>
<p>It looks very similar to the earlier proxy example, but the key part is that the frontend and backend sockets are on two different networks. We can use this model for example to connect a multicast network (<tt>pgm</tt> transport) to a <tt>tcp</tt> publisher.</p>
<p><a name="Handling-Errors-and-ETERM"></a><a name="header-43"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc42"><span><a href="http://zguide.zeromq.org/page:all#Handling-Errors-and-ETERM">Handling Errors and ETERM</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-42">prev</a> <a href="http://zguide.zeromq.org/page:all#header-44">next</a></td>
</tr>
</tbody></table>
<p>ZeroMQ's error handling philosophy is a mix of fail-fast and resilience. Processes, we believe, should be as vulnerable as possible to internal errors, and as robust as possible against external attacks and errors. To give an analogy, a living cell will self-destruct if it detects a single internal error, yet it will resist attack from the outside by all means possible.</p>
<p>Assertions, which pepper the ZeroMQ code, are absolutely vital to robust code; they just have to be on the right side of the cellular wall. And there should be such a wall. If it is unclear whether a fault is internal or external, that is a design flaw to be fixed. In C/C++, assertions stop the application immediately with an error. In other languages, you may get exceptions or halts.</p>
<p>When ZeroMQ detects an external fault it returns an error to the calling code. In some rare cases, it drops messages silently if there is no obvious strategy for recovering from the error.</p>
<p>In most of the C examples we've seen so far there's been no error handling. <strong>Real code should do error handling on every single ZeroMQ call</strong>. If you're using a language binding other than C, the binding may handle errors for you. In C, you do need to do this yourself. There are some simple rules, starting with POSIX conventions:</p>
<ul>
<li>Methods that create objects return NULL if they fail.</li>
<li>Methods that process data may return the number of bytes processed, or -1 on an error or failure.</li>
<li>Other methods return 0 on success and -1 on an error or failure.</li>
<li>The error code is provided in <tt>errno</tt> or <tt><a href="http://api.zeromq.org/3-2:zmq_errno">zmq_errno()</a></tt>.</li>
<li>A descriptive error text for logging is provided by <tt><a href="http://api.zeromq.org/3-2:zmq_strerror">zmq_strerror()</a></tt>.</li>
</ul>
<p>For example:</p>
<div class="code">
<p><span style="color:#B00040">void</span> <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zmq_ctx_new ();<br>
assert (context);<br>
<span style="color:#B00040">void</span> <span style="color:#666666">*</span>socket <span style="color:#666666">=</span> zmq_socket (context, ZMQ_REP);<br>
assert (socket);<br>
<span style="color:#B00040">int</span> rc <span style="color:#666666">=</span> zmq_bind (socket, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5555"</span>);<br>
<span style="color:#008000"><strong>if</strong></span> (rc <span style="color:#666666">==</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"E: bind failed: %s</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, strerror (errno));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">-</span><span style="color:#666666">1</span>;<br>
}</p>
</div>
<p>There are two main exceptional conditions that you should handle as nonfatal:</p>
<ul>
<li>When your code receives a message with the <tt>ZMQ_DONTWAIT</tt> option and there is no waiting data, ZeroMQ will return -1 and set <tt>errno</tt> to <tt>EAGAIN</tt>.</li>
</ul>
<ul>
<li>When one thread calls <tt><a href="http://api.zeromq.org/3-2:zmq_ctx_destroy">zmq_ctx_destroy()</a></tt>, and other threads are still doing blocking work, the <tt><a href="http://api.zeromq.org/3-2:zmq_ctx_destroy">zmq_ctx_destroy()</a></tt> call closes the context and all blocking calls exit with -1, and <tt>errno</tt> set to <tt>ETERM</tt>.</li>
</ul>
<p>In C/C++, asserts can be removed entirely in optimized code, so don't make the mistake of wrapping the whole ZeroMQ call in an <tt>assert()</tt>. It looks neat; then the optimizer removes all the asserts and the calls you want to make, and your application breaks in impressive ways.</p>
<p><strong>Figure 19 - Parallel Pipeline with Kill Signaling</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig19.png" alt="fig19.png" class="image"></div>
<p>Let's see how to shut down a process cleanly. We'll take the parallel pipeline example from the previous section. If we've started a whole lot of workers in the background, we now want to kill them when the batch is finished. Let's do this by sending a kill message to the workers. The best place to do this is the sink because it really knows when the batch is done.</p>
<p>How do we connect the sink to the workers? The PUSH/PULL sockets are one-way only. We could switch to another socket type, or we could mix multiple socket flows. Let's try the latter: using a pub-sub model to send kill messages to the workers:</p>
<ul>
<li>The sink creates a PUB socket on a new endpoint.</li>
<li>Workers bind their input socket to this endpoint.</li>
<li>When the sink detects the end of the batch, it sends a kill to its PUB socket.</li>
<li>When a worker detects this kill message, it exits.</li>
</ul>
<p>It doesn't take much new code in the sink:</p>
<div class="code">
<p><span style="color:#B00040">void</span> <span style="color:#666666">*</span>controller <span style="color:#666666">=</span> zmq_socket (context, ZMQ_PUB);<br>
zmq_bind (controller, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5559"</span>);<br>
…<br>
<span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send kill signal to workers</em></span><br>
s_send (controller, <span style="color:#BA2121">"KILL"</span>);</p>
</div>
<p>Here is the worker process, which manages two sockets (a PULL socket getting tasks, and a SUB socket getting control commands), using the <tt><a href="http://api.zeromq.org/3-2:zmq_poll">zmq_poll()</a></tt> technique we saw earlier:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">taskwork2:&nbsp;Parallel&nbsp;task&nbsp;worker&nbsp;with&nbsp;kill&nbsp;signaling&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">taskwork2:&nbsp;Parallel&nbsp;task&nbsp;worker&nbsp;with&nbsp;kill&nbsp;signaling&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Task worker - design 2<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Adds pub-sub flow to receive and respond to kill signal</span></p>
<p>#include "zhelpers.h"</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Socket to receive messages on</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zmq_ctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>receiver <span style="color:#666666">=</span> zmq_socket (context, ZMQ_PULL);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_connect (receiver, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5557"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Socket to send messages to</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>sender <span style="color:#666666">=</span> zmq_socket (context, ZMQ_PUSH);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_connect (sender, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5558"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Socket for control input</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>controller <span style="color:#666666">=</span> zmq_socket (context, ZMQ_SUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_connect (controller, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5559"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_setsockopt (controller, ZMQ_SUBSCRIBE, <span style="color:#BA2121">""</span>, <span style="color:#666666">0</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Process messages from either socket</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_pollitem_t items <span style="white-space: pre-wrap;">[]</span> <span style="color:#666666">=</span> {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>{ receiver, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> },<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>{ controller, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> }<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_poll (items, <span style="color:#666666">2</span>, <span style="color:#666666">-</span><span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>string <span style="color:#666666">=</span> s_recv (receiver);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"%s."</span>, string);<tt><span style="white-space: pre-wrap;">     </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Show progress</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>fflush (stdout);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>s_sleep (atoi (string));<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Do the work</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>free (string);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>s_send (sender, <span style="color:#BA2121">""</span>);<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send results to sink</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Any waiting controller command acts as 'KILL'</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">                      </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Exit loop</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (receiver);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (sender);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (controller);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_ctx_destroy (context);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:taskwork2" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:taskwork2" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/clj:taskwork2" target="_blank">Clojure</a> | <a href="http://zguide.zeromq.org/lisp:taskwork2" target="_blank">CL</a> | <a href="http://zguide.zeromq.org/dpr:taskwork2" target="_blank">Delphi</a> | <a href="http://zguide.zeromq.org/es:taskwork2" target="_blank">Erlang</a> | <a href="http://zguide.zeromq.org/fsx:taskwork2" target="_blank">F#</a> | <a href="http://zguide.zeromq.org/go:taskwork2" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:taskwork2" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:taskwork2" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:taskwork2" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:taskwork2" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/js:taskwork2" target="_blank">Node.js</a> | <a href="http://zguide.zeromq.org/m:taskwork2" target="_blank">Objective-C</a> | <a href="http://zguide.zeromq.org/pl:taskwork2" target="_blank">Perl</a> | <a href="http://zguide.zeromq.org/php:taskwork2" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:taskwork2" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rb:taskwork2" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/scala:taskwork2" target="_blank">Scala</a> | <a href="http://zguide.zeromq.org/tcl:taskwork2" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | Felix | ooc | Q | Racket</a></span>
<p>Here is the modified sink application. When it's finished collecting results, it broadcasts a kill message to all workers:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">tasksink2:&nbsp;Parallel&nbsp;task&nbsp;sink&nbsp;with&nbsp;kill&nbsp;signaling&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">tasksink2:&nbsp;Parallel&nbsp;task&nbsp;sink&nbsp;with&nbsp;kill&nbsp;signaling&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Task sink - design 2<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Adds pub-sub flow to send kill signal to workers</span></span></p>
<p><span style="color:#BC7A00">#include "zhelpers.h"</span></p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Socket to receive messages on</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zmq_ctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>receiver <span style="color:#666666">=</span> zmq_socket (context, ZMQ_PULL);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_bind (receiver, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5558"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Socket for worker control</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>controller <span style="color:#666666">=</span> zmq_socket (context, ZMQ_PUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_bind (controller, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5559"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Wait for start of batch</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>string <span style="color:#666666">=</span> s_recv (receiver);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>free (string);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Start our clock now</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int64_t</span> start_time <span style="color:#666666">=</span> s_clock ();</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Process 100 confirmations</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> task_nbr;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (task_nbr <span style="color:#666666">=</span> <span style="color:#666666">0</span>; task_nbr <span style="color:#666666">&lt;</span> <span style="color:#666666">100</span>; task_nbr<span style="color:#666666">++</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>string <span style="color:#666666">=</span> s_recv (receiver);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (string);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (task_nbr <span style="color:#666666">%</span> <span style="color:#666666">10</span> <span style="color:#666666">==</span> <span style="color:#666666">0</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">":"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"."</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>fflush (stdout);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"Total elapsed time: %d msec</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>,<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>(<span style="color:#B00040">int</span>) (s_clock () <span style="color:#666666">-</span> start_time));</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send kill signal to workers</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_send (controller, <span style="color:#BA2121">"KILL"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (receiver);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (controller);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_ctx_destroy (context);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:tasksink2" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:tasksink2" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/clj:tasksink2" target="_blank">Clojure</a> | <a href="http://zguide.zeromq.org/lisp:tasksink2" target="_blank">CL</a> | <a href="http://zguide.zeromq.org/dpr:tasksink2" target="_blank">Delphi</a> | <a href="http://zguide.zeromq.org/es:tasksink2" target="_blank">Erlang</a> | <a href="http://zguide.zeromq.org/fsx:tasksink2" target="_blank">F#</a> | <a href="http://zguide.zeromq.org/go:tasksink2" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:tasksink2" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:tasksink2" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:tasksink2" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:tasksink2" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/js:tasksink2" target="_blank">Node.js</a> | <a href="http://zguide.zeromq.org/m:tasksink2" target="_blank">Objective-C</a> | <a href="http://zguide.zeromq.org/pl:tasksink2" target="_blank">Perl</a> | <a href="http://zguide.zeromq.org/php:tasksink2" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:tasksink2" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rb:tasksink2" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/scala:tasksink2" target="_blank">Scala</a> | <a href="http://zguide.zeromq.org/tcl:tasksink2" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | Felix | ooc | Q | Racket</a></span>
<p><a name="Handling-Interrupt-Signals"></a><a name="header-44"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc43"><span><a href="http://zguide.zeromq.org/page:all#Handling-Interrupt-Signals">Handling Interrupt Signals</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-43">prev</a> <a href="http://zguide.zeromq.org/page:all#header-45">next</a></td>
</tr>
</tbody></table>
<p>Realistic applications need to shut down cleanly when interrupted with Ctrl-C or another signal such as <tt>SIGTERM</tt>. By default, these simply kill the process, meaning messages won't be flushed, files won't be closed cleanly, and so on.</p>
<p>Here is how we handle a signal in various languages:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">interrupt:&nbsp;Handling&nbsp;Ctrl-C&nbsp;cleanly&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">interrupt:&nbsp;Handling&nbsp;Ctrl-C&nbsp;cleanly&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Shows how to handle Ctrl-C</em></span></p>
<p><span style="color:#BC7A00">#include &lt;stdlib.h&gt;<br>
#include &lt;stdio.h&gt;<br>
#include &lt;signal.h&gt;<br>
#include &lt;unistd.h&gt;<br>
#include &lt;fcntl.h&gt;</span></p>
<p><span style="color:#BC7A00">#include &lt;zmq.h&gt;</span></p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Signal handling<br>
<span style="white-space: pre-wrap;">//</span><br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Create a self-pipe and call s_catch_signals(pipe's writefd) in your application<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>at startup, and then exit your main loop if your pipe contains any data.<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Works especially well with zmq_poll.</span></span></p>
<p><span style="color:#BC7A00">#define S_NOTIFY_MSG " "<br>
#define S_ERROR_MSG "Error while writing to self-pipe.\n"</span><br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">int</span> s_fd;<br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span> <span style="color:#0000FF">s_signal_handler</span> (<span style="color:#B00040">int</span> signal_value)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> rc <span style="color:#666666">=</span> write (s_fd, S_NOTIFY_MSG, <span style="color:#008000"><strong>sizeof</strong></span>(S_NOTIFY_MSG));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (rc <span style="color:#666666">!=</span> <span style="color:#008000"><strong>sizeof</strong></span>(S_NOTIFY_MSG)) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>write (STDOUT_FILENO, S_ERROR_MSG, <span style="color:#008000"><strong>sizeof</strong></span>(S_ERROR_MSG)<span style="color:#666666">-</span><span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>exit(<span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
}</p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span> <span style="color:#0000FF">s_catch_signals</span> (<span style="color:#B00040">int</span> fd)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_fd <span style="color:#666666">=</span> fd;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>struct</strong></span> sigaction action;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>action.sa_handler <span style="color:#666666">=</span> s_signal_handler;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Doesn't matter if SA_RESTART set because self-pipe will wake up zmq_poll</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>But setting to 0 will allow zmq_read to be interrupted.</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>action.sa_flags <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>sigemptyset (<span style="color:#666666">&amp;</span>action.sa_mask);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>sigaction (SIGINT, <span style="color:#666666">&amp;</span>action, <span style="color:#008000">NULL</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>sigaction (SIGTERM, <span style="color:#666666">&amp;</span>action, <span style="color:#008000">NULL</span>);<br>
}</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> rc;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zmq_ctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>socket <span style="color:#666666">=</span> zmq_socket (context, ZMQ_REP);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_bind (socket, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5555"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> pipefds<span style="white-space: pre-wrap;">[</span><span style="color:#666666">2</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>rc <span style="color:#666666">=</span> pipe(pipefds);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (rc <span style="color:#666666">!=</span> <span style="color:#666666">0</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>perror(<span style="color:#BA2121">"Creating self-pipe"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>exit(<span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (<span style="color:#B00040">int</span> i <span style="color:#666666">=</span> <span style="color:#666666">0</span>; i <span style="color:#666666">&lt;</span> <span style="color:#666666">2</span>; i<span style="color:#666666">++</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> flags <span style="color:#666666">=</span> fcntl(pipefds<span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>, F_GETFL, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (flags <span style="color:#666666">&lt;</span> <span style="color:#666666">0</span>) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>perror (<span style="color:#BA2121">"fcntl(F_GETFL)"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>exit(<span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>rc <span style="color:#666666">=</span> fcntl (pipefds<span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>, F_SETFL, flags <span style="color:#666666">|</span> O_NONBLOCK);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (rc <span style="color:#666666">!=</span> <span style="color:#666666">0</span>) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>perror (<span style="color:#BA2121">"fcntl(F_SETFL)"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>exit(<span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt></p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>s_catch_signals (pipefds<span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">zmq_pollitem_t</span> items <span style="white-space: pre-wrap;">[]</span> <span style="color:#666666">=</span> {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>{ <span style="color:#666666">0</span>, pipefds<span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> },<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>{ socket, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> }<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt>;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>rc <span style="color:#666666">=</span> zmq_poll (items, <span style="color:#666666">2</span>, <span style="color:#666666">-</span><span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (rc <span style="color:#666666">==</span> <span style="color:#666666">0</span>) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>continue</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt> <span style="color:#008000"><strong>else</strong></span> <span style="color:#008000"><strong>if</strong></span> (rc <span style="color:#666666">&lt;</span> <span style="color:#666666">0</span>) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (errno <span style="color:#666666">==</span> EINTR) { <span style="color:#008000"><strong>continue</strong></span>; }<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>perror(<span style="color:#BA2121">"zmq_poll"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>exit(<span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt></p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span> Signal pipe FD</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">char</span> buffer <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>read (pipefds<span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>, buffer, <span style="color:#666666">1</span>);<tt><span style="white-space: pre-wrap;">  </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span> clear notifying byte</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"W: interrupt received, killing server…</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt></p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span> Read socket</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">char</span> buffer <span style="white-space: pre-wrap;">[</span><span style="color:#666666">255</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span> Use non-blocking so we can continue to check self-pipe via zmq_poll</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>rc <span style="color:#666666">=</span> zmq_recv (socket, buffer, <span style="color:#666666">255</span>, ZMQ_NOBLOCK);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (rc <span style="color:#666666">&lt;</span> <span style="color:#666666">0</span>) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>if</strong></span> (errno <span style="color:#666666">==</span> EAGAIN) { <span style="color:#008000"><strong>continue</strong></span>; }<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>if</strong></span> (errno <span style="color:#666666">==</span> EINTR) { <span style="color:#008000"><strong>continue</strong></span>; }<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>perror(<span style="color:#BA2121">"recv"</span>);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>exit(<span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"W: recv</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span> Now send message back.</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span> …</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt></p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"W: cleaning up</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (socket);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_ctx_destroy (context);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:interrupt" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:interrupt" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/dpr:interrupt" target="_blank">Delphi</a> | <a href="http://zguide.zeromq.org/es:interrupt" target="_blank">Erlang</a> | <a href="http://zguide.zeromq.org/go:interrupt" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:interrupt" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:interrupt" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:interrupt" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:interrupt" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/js:interrupt" target="_blank">Node.js</a> | <a href="http://zguide.zeromq.org/pl:interrupt" target="_blank">Perl</a> | <a href="http://zguide.zeromq.org/php:interrupt" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:interrupt" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rb:interrupt" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/scala:interrupt" target="_blank">Scala</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | Clojure | CL | F# | Felix | Objective-C | ooc | Q | Racket | Tcl</a></span>
<p>The program provides <tt>s_catch_signals()</tt>, which traps Ctrl-C (<tt>SIGINT</tt>) and <tt>SIGTERM</tt>. When either of these signals arrive, the <tt>s_catch_signals()</tt> handler sets the global variable <tt>s_interrupted</tt>. Thanks to your signal handler, your application will not die automatically. Instead, you have a chance to clean up and exit gracefully. You have to now explicitly check for an interrupt and handle it properly. Do this by calling <tt>s_catch_signals()</tt> (copy this from <tt>interrupt.c</tt>) at the start of your main code. This sets up the signal handling. The interrupt will affect ZeroMQ calls as follows:</p>
<ul>
<li>If your code is blocking in a blocking call (sending a message, receiving a message, or polling), then when a signal arrives, the call will return with <tt>EINTR</tt>.</li>
<li>Wrappers like <tt>s_recv()</tt> return NULL if they are interrupted.</li>
</ul>
<p>So check for an <tt>EINTR</tt> return code, a NULL return, and/or <tt>s_interrupted</tt>.</p>
<p>Here is a typical code fragment:</p>
<div class="code">
<pre><code>s_catch_signals ();
client = zmq_socket (...);
while (!s_interrupted) {
    char *message = s_recv (client);
    if (!message)
        break;          //  Ctrl-C used
}
zmq_close (client);</code>
</pre></div>
<p>If you call <tt>s_catch_signals()</tt> and don't test for interrupts, then your application will become immune to Ctrl-C and <tt>SIGTERM</tt>, which may be useful, but is usually not.</p>
<p><a name="Detecting-Memory-Leaks"></a><a name="header-45"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc44"><span><a href="http://zguide.zeromq.org/page:all#Detecting-Memory-Leaks">Detecting Memory Leaks</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-44">prev</a> <a href="http://zguide.zeromq.org/page:all#header-46">next</a></td>
</tr>
</tbody></table>
<p>Any long-running application has to manage memory correctly, or eventually it'll use up all available memory and crash. If you use a language that handles this automatically for you, congratulations. If you program in C or C++ or any other language where you're responsible for memory management, here's a short tutorial on using valgrind, which among other things will report on any leaks your programs have.</p>
<ul>
<li>To install valgrind, e.g., on Ubuntu or Debian, issue this command:</li>
</ul>
<div class="code">
<pre><code>sudo apt-get install valgrind</code>
</pre></div>
<ul>
<li>By default, ZeroMQ will cause valgrind to complain a lot. To remove these warnings, create a file called <tt>vg.supp</tt> that contains this:</li>
</ul>
<div class="code">
<pre><code>{
   &lt;socketcall_sendto&gt;
   Memcheck:Param
   socketcall.sendto(msg)
   fun:send
   ...
}
{
   &lt;socketcall_sendto&gt;
   Memcheck:Param
   socketcall.send(msg)
   fun:send
   ...
}</code>
</pre></div>
<ul>
<li>Fix your applications to exit cleanly after Ctrl-C. For any application that exits by itself, that's not needed, but for long-running applications, this is essential, otherwise valgrind will complain about all currently allocated memory.</li>
</ul>
<ul>
<li>Build your application with <tt>-DDEBUG</tt> if it's not your default setting. That ensures valgrind can tell you exactly where memory is being leaked.</li>
</ul>
<ul>
<li>Finally, run valgrind thus:</li>
</ul>
<div class="code">
<pre><code>valgrind --tool=memcheck --leak-check=full --suppressions=vg.supp someprog</code>
</pre></div>
<p>And after fixing any errors it reported, you should get the pleasant message:</p>
<div class="code">
<pre><code>==30536== ERROR SUMMARY: 0 errors from 0 contexts...</code>
</pre></div>
<p><a name="Multithreading-with-ZeroMQ"></a><a name="header-46"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc45"><span><a href="http://zguide.zeromq.org/page:all#Multithreading-with-ZeroMQ">Multithreading with ZeroMQ</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-45">prev</a> <a href="http://zguide.zeromq.org/page:all#header-47">next</a></td>
</tr>
</tbody></table>
<p>ZeroMQ is perhaps the nicest way ever to write multithreaded (MT) applications. Whereas ZeroMQ sockets require some readjustment if you are used to traditional sockets, ZeroMQ multithreading will take everything you know about writing MT applications, throw it into a heap in the garden, pour gasoline over it, and set it alight. It's a rare book that deserves burning, but most books on concurrent programming do.</p>
<p>To make utterly perfect MT programs (and I mean that literally), <strong>we don't need mutexes, locks, or any other form of inter-thread communication except messages sent across ZeroMQ sockets.</strong></p>
<p>By "perfect MT programs", I mean code that's easy to write and understand, that works with the same design approach in any programming language, and on any operating system, and that scales across any number of CPUs with zero wait states and no point of diminishing returns.</p>
<p>If you've spent years learning tricks to make your MT code work at all, let alone rapidly, with locks and semaphores and critical sections, you will be disgusted when you realize it was all for nothing. If there's one lesson we've learned from 30+ years of concurrent programming, it is: <em>just don't share state</em>. It's like two drunkards trying to share a beer. It doesn't matter if they're good buddies. Sooner or later, they're going to get into a fight. And the more drunkards you add to the table, the more they fight each other over the beer. The tragic majority of MT applications look like drunken bar fights.</p>
<p>The list of weird problems that you need to fight as you write classic shared-state MT code would be hilarious if it didn't translate directly into stress and risk, as code that seems to work suddenly fails under pressure. A large firm with world-beating experience in buggy code released its list of "11 Likely Problems In Your Multithreaded Code", which covers forgotten synchronization, incorrect granularity, read and write tearing, lock-free reordering, lock convoys, two-step dance, and priority inversion.</p>
<p>Yeah, we counted seven problems, not eleven. That's not the point though. The point is, do you really want that code running the power grid or stock market to start getting two-step lock convoys at 3 p.m. on a busy Thursday? Who cares what the terms actually mean? This is not what turned us on to programming, fighting ever more complex side effects with ever more complex hacks.</p>
<p>Some widely used models, despite being the basis for entire industries, are fundamentally broken, and shared state concurrency is one of them. Code that wants to scale without limit does it like the Internet does, by sending messages and sharing nothing except a common contempt for broken programming models.</p>
<p>You should follow some rules to write happy multithreaded code with ZeroMQ:</p>
<ul>
<li>Isolate data privately within its thread and never share data in multiple threads. The only exception to this are ZeroMQ contexts, which are threadsafe.</li>
</ul>
<ul>
<li>Stay away from the classic concurrency mechanisms like as mutexes, critical sections, semaphores, etc. These are an anti-pattern in ZeroMQ applications.</li>
</ul>
<ul>
<li>Create one ZeroMQ context at the start of your process, and pass that to all threads that you want to connect via <tt>inproc</tt> sockets.</li>
</ul>
<ul>
<li>Use <em>attached</em> threads to create structure within your application, and connect these to their parent threads using PAIR sockets over <tt>inproc</tt>. The pattern is: bind parent socket, then create child thread which connects its socket.</li>
</ul>
<ul>
<li>Use <em>detached</em> threads to simulate independent tasks, with their own contexts. Connect these over <tt>tcp</tt>. Later you can move these to stand-alone processes without changing the code significantly.</li>
</ul>
<ul>
<li>All interaction between threads happens as ZeroMQ messages, which you can define more or less formally.</li>
</ul>
<ul>
<li>Don't share ZeroMQ sockets between threads. ZeroMQ sockets are not threadsafe. Technically it's possible to migrate a socket from one thread to another but it demands skill. The only place where it's remotely sane to share sockets between threads are in language bindings that need to do magic like garbage collection on sockets.</li>
</ul>
<p>If you need to start more than one proxy in an application, for example, you will want to run each in their own thread. It is easy to make the error of creating the proxy frontend and backend sockets in one thread, and then passing the sockets to the proxy in another thread. This may appear to work at first but will fail randomly in real use. Remember: <em>Do not use or close sockets except in the thread that created them.</em></p>
<p>If you follow these rules, you can quite easily build elegant multithreaded applications, and later split off threads into separate processes as you need to. Application logic can sit in threads, processes, or nodes: whatever your scale needs.</p>
<p>ZeroMQ uses native OS threads rather than virtual "green" threads. The advantage is that you don't need to learn any new threading API, and that ZeroMQ threads map cleanly to your operating system. You can use standard tools like Intel's ThreadChecker to see what your application is doing. The disadvantages are that native threading APIs are not always portable, and that if you have a huge number of threads (in the thousands), some operating systems will get stressed.</p>
<p>Let's see how this works in practice. We'll turn our old Hello World server into something more capable. The original server ran in a single thread. If the work per request is low, that's fine: one ØMQ thread can run at full speed on a CPU core, with no waits, doing an awful lot of work. But realistic servers have to do nontrivial work per request. A single core may not be enough when 10,000 clients hit the server all at once. So a realistic server will start multiple worker threads. It then accepts requests as fast as it can and distributes these to its worker threads. The worker threads grind through the work and eventually send their replies back.</p>
<p>You can, of course, do all this using a proxy broker and external worker processes, but often it's easier to start one process that gobbles up sixteen cores than sixteen processes, each gobbling up one core. Further, running workers as threads will cut out a network hop, latency, and network traffic.</p>
<p>The MT version of the Hello World service basically collapses the broker and workers into a single process:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">mtserver:&nbsp;Multithreaded&nbsp;service&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">mtserver:&nbsp;Multithreaded&nbsp;service&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Multithreaded Hello World server</em></span></p>
<p><span style="color:#BC7A00">#include "zhelpers.h"<br>
#include &lt;pthread.h&gt;<br>
#include &lt;unistd.h&gt;</span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span> <span style="color:#666666">*</span><br>
<span style="color:#0000FF">worker_routine</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>context) {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Socket to talk to dispatcher</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>receiver <span style="color:#666666">=</span> zmq_socket (context, ZMQ_REP);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_connect (receiver, <span style="color:#BA2121">"inproc:<span style="white-space: pre-wrap;">//</span>workers"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>string <span style="color:#666666">=</span> s_recv (receiver);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"Received request: <span style="white-space: pre-wrap;">[</span>%s<span style="white-space: pre-wrap;">]</span></span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, string);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (string);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Do some 'work'</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>sleep (<span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send reply back to client</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>s_send (receiver, <span style="color:#BA2121">"World"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (receiver);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#008000">NULL</span>;<br>
}</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zmq_ctx_new ();</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Socket to talk to clients</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>clients <span style="color:#666666">=</span> zmq_socket (context, ZMQ_ROUTER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_bind (clients, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5555"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Socket to talk to workers</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>workers <span style="color:#666666">=</span> zmq_socket (context, ZMQ_DEALER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_bind (workers, <span style="color:#BA2121">"inproc:<span style="white-space: pre-wrap;">//</span>workers"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Launch pool of worker threads</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> thread_nbr;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (thread_nbr <span style="color:#666666">=</span> <span style="color:#666666">0</span>; thread_nbr <span style="color:#666666">&lt;</span> <span style="color:#666666">5</span>; thread_nbr<span style="color:#666666">++</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">pthread_t</span> worker;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>pthread_create (<span style="color:#666666">&amp;</span>worker, <span style="color:#008000">NULL</span>, worker_routine, context);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Connect work threads to client threads via a queue proxy</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_proxy (clients, workers, <span style="color:#008000">NULL</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We never get here, but clean up anyhow</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (clients);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (workers);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_ctx_destroy (context);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:mtserver" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:mtserver" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/clj:mtserver" target="_blank">Clojure</a> | <a href="http://zguide.zeromq.org/lisp:mtserver" target="_blank">CL</a> | <a href="http://zguide.zeromq.org/dpr:mtserver" target="_blank">Delphi</a> | <a href="http://zguide.zeromq.org/es:mtserver" target="_blank">Erlang</a> | <a href="http://zguide.zeromq.org/fsx:mtserver" target="_blank">F#</a> | <a href="http://zguide.zeromq.org/go:mtserver" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:mtserver" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:mtserver" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:mtserver" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:mtserver" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/pl:mtserver" target="_blank">Perl</a> | <a href="http://zguide.zeromq.org/php:mtserver" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:mtserver" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/q:mtserver" target="_blank">Q</a> | <a href="http://zguide.zeromq.org/rb:mtserver" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/scala:mtserver" target="_blank">Scala</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | Felix | Node.js | Objective-C | ooc | Racket | Tcl</a></span>
<p><strong>Figure 20 - Multithreaded Server</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig20.png" alt="fig20.png" class="image"></div>
<p>All the code should be recognizable to you by now. How it works:</p>
<ul>
<li>The server starts a set of worker threads. Each worker thread creates a REP socket and then processes requests on this socket. Worker threads are just like single-threaded servers. The only differences are the transport (<tt>inproc</tt> instead of <tt>tcp</tt>), and the bind-connect direction.</li>
</ul>
<ul>
<li>The server creates a ROUTER socket to talk to clients and binds this to its external interface (over <tt>tcp</tt>).</li>
</ul>
<ul>
<li>The server creates a DEALER socket to talk to the workers and binds this to its internal interface (over <tt>inproc</tt>).</li>
</ul>
<ul>
<li>The server starts a proxy that connects the two sockets. The proxy pulls incoming requests fairly from all clients, and distributes those out to workers. It also routes replies back to their origin.</li>
</ul>
<p>Note that creating threads is not portable in most programming languages. The POSIX library is pthreads, but on Windows you have to use a different API. In our example, the <tt>pthread_create</tt> call starts up a new thread running the <tt>worker_routine</tt> function we defined. We'll see in <a href="http://zguide.zeromq.org/page:all#advanced-request-reply">Chapter 3 - Advanced Request-Reply Patterns</a> how to wrap this in a portable API.</p>
<p>Here the "work" is just a one-second pause. We could do anything in the workers, including talking to other nodes. This is what the MT server looks like in terms of ØMQ sockets and nodes. Note how the request-reply chain is <tt>REQ-ROUTER-queue-DEALER-REP</tt>.</p>
<p><a name="Signaling-Between-Threads-PAIR-Sockets"></a><a name="header-47"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc46"><span><a href="http://zguide.zeromq.org/page:all#Signaling-Between-Threads-PAIR-Sockets">Signaling Between Threads (PAIR Sockets)</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-46">prev</a> <a href="http://zguide.zeromq.org/page:all#header-48">next</a></td>
</tr>
</tbody></table>
<p>When you start making multithreaded applications with ZeroMQ, you'll encounter the question of how to coordinate your threads. Though you might be tempted to insert "sleep" statements, or use multithreading techniques such as semaphores or mutexes, <strong>the only mechanism that you should use are ZeroMQ messages</strong>. Remember the story of The Drunkards and The Beer Bottle.</p>
<p>Let's make three threads that signal each other when they are ready. In this example, we use PAIR sockets over the <tt>inproc</tt> transport:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">mtrelay:&nbsp;Multithreaded&nbsp;relay&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">mtrelay:&nbsp;Multithreaded&nbsp;relay&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Multithreaded relay</span></p>
<p>#include "zhelpers.h"<br>
#include &lt;pthread.h&gt;</p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span> <span style="color:#666666">*</span><br>
<span style="color:#0000FF">step1</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>context) {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Connect to step2 and tell it we're ready</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>xmitter <span style="color:#666666">=</span> zmq_socket (context, ZMQ_PAIR);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_connect (xmitter, <span style="color:#BA2121">"inproc:<span style="white-space: pre-wrap;">//</span>step2"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"Step 1 ready, signaling step 2</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_send (xmitter, <span style="color:#BA2121">"READY"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (xmitter);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#008000">NULL</span>;<br>
}</p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span> <span style="color:#666666">*</span><br>
<span style="color:#0000FF">step2</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>context) {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Bind inproc socket before starting step1</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>receiver <span style="color:#666666">=</span> zmq_socket (context, ZMQ_PAIR);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_bind (receiver, <span style="color:#BA2121">"inproc:<span style="white-space: pre-wrap;">//</span>step2"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>pthread_t <span style="color:#008000"><strong>thread</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>pthread_create (<span style="color:#666666">&amp;</span><span style="color:#008000"><strong>thread</strong></span>, <span style="color:#008000">NULL</span>, step1, context);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Wait for signal and pass it on</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>string <span style="color:#666666">=</span> s_recv (receiver);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>free (string);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (receiver);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Connect to step3 and tell it we're ready</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>xmitter <span style="color:#666666">=</span> zmq_socket (context, ZMQ_PAIR);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_connect (xmitter, <span style="color:#BA2121">"inproc:<span style="white-space: pre-wrap;">//</span>step3"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"Step 2 ready, signaling step 3</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_send (xmitter, <span style="color:#BA2121">"READY"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (xmitter);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#008000">NULL</span>;<br>
}</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zmq_ctx_new ();</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Bind inproc socket before starting step2</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>receiver <span style="color:#666666">=</span> zmq_socket (context, ZMQ_PAIR);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_bind (receiver, <span style="color:#BA2121">"inproc:<span style="white-space: pre-wrap;">//</span>step3"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>pthread_t <span style="color:#008000"><strong>thread</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>pthread_create (<span style="color:#666666">&amp;</span><span style="color:#008000"><strong>thread</strong></span>, <span style="color:#008000">NULL</span>, step2, context);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Wait for signal</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>string <span style="color:#666666">=</span> s_recv (receiver);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>free (string);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (receiver);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"Test successful!</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_ctx_destroy (context);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:mtrelay" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:mtrelay" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/clj:mtrelay" target="_blank">Clojure</a> | <a href="http://zguide.zeromq.org/lisp:mtrelay" target="_blank">CL</a> | <a href="http://zguide.zeromq.org/dpr:mtrelay" target="_blank">Delphi</a> | <a href="http://zguide.zeromq.org/es:mtrelay" target="_blank">Erlang</a> | <a href="http://zguide.zeromq.org/fsx:mtrelay" target="_blank">F#</a> | <a href="http://zguide.zeromq.org/go:mtrelay" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:mtrelay" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:mtrelay" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:mtrelay" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:mtrelay" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/pl:mtrelay" target="_blank">Perl</a> | <a href="http://zguide.zeromq.org/php:mtrelay" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:mtrelay" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/q:mtrelay" target="_blank">Q</a> | <a href="http://zguide.zeromq.org/rb:mtrelay" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/scala:mtrelay" target="_blank">Scala</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | Felix | Node.js | Objective-C | ooc | Racket | Tcl</a></span>
<p><strong>Figure 21 - The Relay Race</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig21.png" alt="fig21.png" class="image"></div>
<p>This is a classic pattern for multithreading with ZeroMQ:</p>
<ol>
<li>Two threads communicate over <tt>inproc</tt>, using a shared context.</li>
<li>The parent thread creates one socket, binds it to an <tt>inproc:<span style="white-space: pre-wrap;">//</span></tt> endpoint, and <em>then</em> starts the child thread, passing the context to it.</li>
<li>The child thread creates the second socket, connects it to that <tt>inproc:<span style="white-space: pre-wrap;">//</span></tt> endpoint, and <em>then</em> signals to the parent thread that it's ready.</li>
</ol>
<p>Note that multithreading code using this pattern is not scalable out to processes. If you use <tt>inproc</tt> and socket pairs, you are building a tightly-bound application, i.e., one where your threads are structurally interdependent. Do this when low latency is really vital. The other design pattern is a loosely bound application, where threads have their own context and communicate over <tt>ipc</tt> or <tt>tcp</tt>. You can easily break loosely bound threads into separate processes.</p>
<p>This is the first time we've shown an example using PAIR sockets. Why use PAIR? Other socket combinations might seem to work, but they all have side effects that could interfere with signaling:</p>
<ul>
<li>You can use PUSH for the sender and PULL for the receiver. This looks simple and will work, but remember that PUSH will distribute messages to all available receivers. If you by accident start two receivers (e.g., you already have one running and you start a second), you'll "lose" half of your signals. PAIR has the advantage of refusing more than one connection; the pair is <em>exclusive</em>.</li>
</ul>
<ul>
<li>You can use DEALER for the sender and ROUTER for the receiver. ROUTER, however, wraps your message in an "envelope", meaning your zero-size signal turns into a multipart message. If you don't care about the data and treat anything as a valid signal, and if you don't read more than once from the socket, that won't matter. If, however, you decide to send real data, you will suddenly find ROUTER providing you with "wrong" messages. DEALER also distributes outgoing messages, giving the same risk as PUSH.</li>
</ul>
<ul>
<li>You can use PUB for the sender and SUB for the receiver. This will correctly deliver your messages exactly as you sent them and PUB does not distribute as PUSH or DEALER do. However, you need to configure the subscriber with an empty subscription, which is annoying.</li>
</ul>
<p>For these reasons, PAIR makes the best choice for coordination between pairs of threads.</p>
<p><a name="Node-Coordination"></a><a name="header-48"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc47"><span><a href="http://zguide.zeromq.org/page:all#Node-Coordination">Node Coordination</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-47">prev</a> <a href="http://zguide.zeromq.org/page:all#header-49">next</a></td>
</tr>
</tbody></table>
<p>When you want to coordinate a set of nodes on a network, PAIR sockets won't work well any more. This is one of the few areas where the strategies for threads and nodes are different. Principally, nodes come and go whereas threads are usually static. PAIR sockets do not automatically reconnect if the remote node goes away and comes back.</p>
<p><strong>Figure 22 - Pub-Sub Synchronization</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig22.png" alt="fig22.png" class="image"></div>
<p>The second significant difference between threads and nodes is that you typically have a fixed number of threads but a more variable number of nodes. Let's take one of our earlier scenarios (the weather server and clients) and use node coordination to ensure that subscribers don't lose data when starting up.</p>
<p>This is how the application will work:</p>
<ul>
<li>The publisher knows in advance how many subscribers it expects. This is just a magic number it gets from somewhere.</li>
</ul>
<ul>
<li>The publisher starts up and waits for all subscribers to connect. This is the node coordination part. Each subscriber subscribes and then tells the publisher it's ready via another socket.</li>
</ul>
<ul>
<li>When the publisher has all subscribers connected, it starts to publish data.</li>
</ul>
<p>In this case, we'll use a REQ-REP socket flow to synchronize subscribers and publisher. Here is the publisher:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">syncpub:&nbsp;Synchronized&nbsp;publisher&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">syncpub:&nbsp;Synchronized&nbsp;publisher&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Synchronized publisher</span></p>
<p>#include "zhelpers.h"<br>
#define SUBSCRIBERS_EXPECTED<tt><span style="white-space: pre-wrap;">  </span></tt>10<tt><span style="white-space: pre-wrap;">  </span></tt><span style="color:#408080">//<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We wait for 10 subscribers //</span></p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zmq_ctx_new ();</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Socket to talk to clients</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>publisher <span style="color:#666666">=</span> zmq_socket (context, ZMQ_PUB);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> sndhwm <span style="color:#666666">=</span> <span style="color:#666666">1100000</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_setsockopt (publisher, ZMQ_SNDHWM, <span style="color:#666666">&amp;</span>sndhwm, <span style="color:#008000"><strong>sizeof</strong></span> (<span style="color:#B00040">int</span>));</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zmq_bind (publisher, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5561"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Socket to receive signals</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>syncservice <span style="color:#666666">=</span> zmq_socket (context, ZMQ_REP);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_bind (syncservice, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5562"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Get synchronization from subscribers</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"Waiting for subscribers</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> subscribers <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (subscribers <span style="color:#666666">&lt;</span> SUBSCRIBERS_EXPECTED) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>- wait for synchronization request</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>string <span style="color:#666666">=</span> s_recv (syncservice);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (string);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>- send synchronization reply</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>s_send (syncservice, <span style="color:#BA2121">""</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>subscribers<span style="color:#666666">++</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Now broadcast exactly 1M updates followed by END</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"Broadcasting messages</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> update_nbr;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (update_nbr <span style="color:#666666">=</span> <span style="color:#666666">0</span>; update_nbr <span style="color:#666666">&lt;</span> <span style="color:#666666">1000000</span>; update_nbr<span style="color:#666666">++</span>)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>s_send (publisher, <span style="color:#BA2121">"Rhubarb"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>s_send (publisher, <span style="color:#BA2121">"END"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (publisher);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (syncservice);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_ctx_destroy (context);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:syncpub" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:syncpub" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/clj:syncpub" target="_blank">Clojure</a> | <a href="http://zguide.zeromq.org/lisp:syncpub" target="_blank">CL</a> | <a href="http://zguide.zeromq.org/dpr:syncpub" target="_blank">Delphi</a> | <a href="http://zguide.zeromq.org/es:syncpub" target="_blank">Erlang</a> | <a href="http://zguide.zeromq.org/fsx:syncpub" target="_blank">F#</a> | <a href="http://zguide.zeromq.org/go:syncpub" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:syncpub" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:syncpub" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:syncpub" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:syncpub" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/js:syncpub" target="_blank">Node.js</a> | <a href="http://zguide.zeromq.org/pl:syncpub" target="_blank">Perl</a> | <a href="http://zguide.zeromq.org/php:syncpub" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:syncpub" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rkt:syncpub" target="_blank">Racket</a> | <a href="http://zguide.zeromq.org/rb:syncpub" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/scala:syncpub" target="_blank">Scala</a> | <a href="http://zguide.zeromq.org/tcl:syncpub" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | Felix | Objective-C | ooc | Q</a></span>
<p>And here is the subscriber:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">syncsub:&nbsp;Synchronized&nbsp;subscriber&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">syncsub:&nbsp;Synchronized&nbsp;subscriber&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Synchronized subscriber</em></span></p>
<p><span style="color:#BC7A00">#include "zhelpers.h"<br>
#include &lt;unistd.h&gt;</span></p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zmq_ctx_new ();</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>First, connect our subscriber socket</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>subscriber <span style="color:#666666">=</span> zmq_socket (context, ZMQ_SUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_connect (subscriber, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5561"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_setsockopt (subscriber, ZMQ_SUBSCRIBE, <span style="color:#BA2121">""</span>, <span style="color:#666666">0</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>0MQ is so fast, we need to wait a while…</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>sleep (<span style="color:#666666">1</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Second, synchronize with publisher</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>syncclient <span style="color:#666666">=</span> zmq_socket (context, ZMQ_REQ);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_connect (syncclient, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5562"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>- send a synchronization request</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_send (syncclient, <span style="color:#BA2121">""</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>- wait for synchronization reply</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>string <span style="color:#666666">=</span> s_recv (syncclient);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>free (string);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Third, get our updates and report how many we got</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> update_nbr <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>string <span style="color:#666666">=</span> s_recv (subscriber);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (strcmp (string, <span style="color:#BA2121">"END"</span>) <span style="color:#666666">==</span> <span style="color:#666666">0</span>) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>free (string);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (string);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>update_nbr<span style="color:#666666">++</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"Received %d updates</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, update_nbr);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (subscriber);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (syncclient);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_ctx_destroy (context);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:syncsub" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:syncsub" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/clj:syncsub" target="_blank">Clojure</a> | <a href="http://zguide.zeromq.org/lisp:syncsub" target="_blank">CL</a> | <a href="http://zguide.zeromq.org/dpr:syncsub" target="_blank">Delphi</a> | <a href="http://zguide.zeromq.org/es:syncsub" target="_blank">Erlang</a> | <a href="http://zguide.zeromq.org/fsx:syncsub" target="_blank">F#</a> | <a href="http://zguide.zeromq.org/go:syncsub" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:syncsub" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:syncsub" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:syncsub" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:syncsub" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/js:syncsub" target="_blank">Node.js</a> | <a href="http://zguide.zeromq.org/pl:syncsub" target="_blank">Perl</a> | <a href="http://zguide.zeromq.org/php:syncsub" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:syncsub" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rkt:syncsub" target="_blank">Racket</a> | <a href="http://zguide.zeromq.org/rb:syncsub" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/scala:syncsub" target="_blank">Scala</a> | <a href="http://zguide.zeromq.org/tcl:syncsub" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | Felix | Objective-C | ooc | Q</a></span>
<p>This Bash shell script will start ten subscribers and then the publisher:</p>
<div class="code">
<pre><code>echo "Starting subscribers..."
for ((a=0; a&lt;10; a++)); do
    syncsub &amp;
done
echo "Starting publisher..."
syncpub</code>
</pre></div>
<p>Which gives us this satisfying output:</p>
<div class="code">
<pre><code>Starting subscribers...
Starting publisher...
Received 1000000 updates
Received 1000000 updates
...
Received 1000000 updates
Received 1000000 updates</code>
</pre></div>
<p>We can't assume that the SUB connect will be finished by the time the REQ/REP dialog is complete. There are no guarantees that outbound connects will finish in any order whatsoever, if you're using any transport except <tt>inproc</tt>. So, the example does a brute force sleep of one second between subscribing, and sending the REQ/REP synchronization.</p>
<p>A more robust model could be:</p>
<ul>
<li>Publisher opens PUB socket and starts sending "Hello" messages (not data).</li>
<li>Subscribers connect SUB socket and when they receive a Hello message they tell the publisher via a REQ/REP socket pair.</li>
<li>When the publisher has had all the necessary confirmations, it starts to send real data.</li>
</ul>
<p><a name="Zero-Copy"></a><a name="header-49"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc48"><span><a href="http://zguide.zeromq.org/page:all#Zero-Copy">Zero-Copy</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-48">prev</a> <a href="http://zguide.zeromq.org/page:all#header-50">next</a></td>
</tr>
</tbody></table>
<p>ZeroMQ's message API lets you send and receive messages directly from and to application buffers without copying data. We call this <em>zero-copy</em>, and it can improve performance in some applications.</p>
<p>You should think about using zero-copy in the specific case where you are sending large blocks of memory (thousands of bytes), at a high frequency. For short messages, or for lower message rates, using zero-copy will make your code messier and more complex with no measurable benefit. Like all optimizations, use this when you know it helps, and <em>measure</em> before and after.</p>
<p>To do zero-copy, you use <tt><a href="http://api.zeromq.org/3-2:zmq_msg_init_data">zmq_msg_init_data()</a></tt> to create a message that refers to a block of data already allocated with <tt>malloc()</tt> or some other allocator, and then you pass that to <tt><a href="http://api.zeromq.org/3-2:zmq_msg_send">zmq_msg_send()</a></tt>. When you create the message, you also pass a function that ZeroMQ will call to free the block of data, when it has finished sending the message. This is the simplest example, assuming <tt>buffer</tt> is a block of 1,000 bytes allocated on the heap:</p>
<div class="code">
<p><span style="color:#B00040">void</span> <span style="color:#0000FF">my_free</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>data, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>hint) {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>free (data);<br>
}<br>
<span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send message from buffer, which we allocate and ZeroMQ will free for us</em></span><br>
zmq_msg_t message;<br>
zmq_msg_init_data (<span style="color:#666666">&amp;</span>message, buffer, <span style="color:#666666">1000</span>, my_free, <span style="color:#008000">NULL</span>);<br>
zmq_msg_send (<span style="color:#666666">&amp;</span>message, socket, <span style="color:#666666">0</span>);</p>
</div>
<p>Note that you don't call <tt><a href="http://api.zeromq.org/3-2:zmq_msg_close">zmq_msg_close()</a></tt> after sending a message—<tt>libzmq</tt> will do this automatically when it's actually done sending the message.</p>
<p>There is no way to do zero-copy on receive: ZeroMQ delivers you a buffer that you can store as long as you wish, but it will not write data directly into application buffers.</p>
<p>On writing, ZeroMQ's multipart messages work nicely together with zero-copy. In traditional messaging, you need to marshal different buffers together into one buffer that you can send. That means copying data. With ZeroMQ, you can send multiple buffers coming from different sources as individual message frames. Send each field as a length-delimited frame. To the application, it looks like a series of send and receive calls. But internally, the multiple parts get written to the network and read back with single system calls, so it's very efficient.</p>
<p><a name="Pub-Sub-Message-Envelopes"></a><a name="header-50"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc49"><span><a href="http://zguide.zeromq.org/page:all#Pub-Sub-Message-Envelopes">Pub-Sub Message Envelopes</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-49">prev</a> <a href="http://zguide.zeromq.org/page:all#header-51">next</a></td>
</tr>
</tbody></table>
<p>In the pub-sub pattern, we can split the key into a separate message frame that we call an <em>envelope</em>. If you want to use pub-sub envelopes, make them yourself. It's optional, and in previous pub-sub examples we didn't do this. Using a pub-sub envelope is a little more work for simple cases, but it's cleaner especially for real cases, where the key and the data are naturally separate things.</p>
<p><strong>Figure 23 - Pub-Sub Envelope with Separate Key</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig23.png" alt="fig23.png" class="image"></div>
<p>Subscriptions do a prefix match. That is, they look for "all messages starting with XYZ". The obvious question is: how to delimit keys from data so that the prefix match doesn't accidentally match data. The best answer is to use an envelope because the match won't cross a frame boundary. Here is a minimalist example of how pub-sub envelopes look in code. This publisher sends messages of two types, A and B.</p>
<p>The envelope holds the message type:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">psenvpub:&nbsp;Pub-Sub&nbsp;envelope&nbsp;publisher&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">psenvpub:&nbsp;Pub-Sub&nbsp;envelope&nbsp;publisher&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Pubsub envelope publisher<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Note that the zhelpers.h file also provides s_sendmore</span></span></p>
<p><span style="color:#BC7A00">#include "zhelpers.h"<br>
#include &lt;unistd.h&gt;</span></p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Prepare our context and publisher</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zmq_ctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>publisher <span style="color:#666666">=</span> zmq_socket (context, ZMQ_PUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_bind (publisher, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5563"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Write two messages, each with an envelope and content</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>s_sendmore (publisher, <span style="color:#BA2121">"A"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>s_send (publisher, <span style="color:#BA2121">"We don't want to see this"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>s_sendmore (publisher, <span style="color:#BA2121">"B"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>s_send (publisher, <span style="color:#BA2121">"We would like to see this"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>sleep (<span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We never get here, but clean up anyhow</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (publisher);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_ctx_destroy (context);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:psenvpub" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:psenvpub" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/clj:psenvpub" target="_blank">Clojure</a> | <a href="http://zguide.zeromq.org/lisp:psenvpub" target="_blank">CL</a> | <a href="http://zguide.zeromq.org/dpr:psenvpub" target="_blank">Delphi</a> | <a href="http://zguide.zeromq.org/es:psenvpub" target="_blank">Erlang</a> | <a href="http://zguide.zeromq.org/fsx:psenvpub" target="_blank">F#</a> | <a href="http://zguide.zeromq.org/go:psenvpub" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:psenvpub" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:psenvpub" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:psenvpub" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:psenvpub" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/js:psenvpub" target="_blank">Node.js</a> | <a href="http://zguide.zeromq.org/pl:psenvpub" target="_blank">Perl</a> | <a href="http://zguide.zeromq.org/php:psenvpub" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:psenvpub" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rb:psenvpub" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/scala:psenvpub" target="_blank">Scala</a> | <a href="http://zguide.zeromq.org/tcl:psenvpub" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | Felix | Objective-C | ooc | Q | Racket</a></span>
<p>The subscriber wants only messages of type B:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">psenvsub:&nbsp;Pub-Sub&nbsp;envelope&nbsp;subscriber&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">psenvsub:&nbsp;Pub-Sub&nbsp;envelope&nbsp;subscriber&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Pubsub envelope subscriber</span></p>
<p>#include "zhelpers.h"</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Prepare our context and subscriber</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zmq_ctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>subscriber <span style="color:#666666">=</span> zmq_socket (context, ZMQ_SUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_connect (subscriber, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5563"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_setsockopt (subscriber, ZMQ_SUBSCRIBE, <span style="color:#BA2121">"B"</span>, <span style="color:#666666">1</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Read envelope with address</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>address <span style="color:#666666">=</span> s_recv (subscriber);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Read message contents</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>contents <span style="color:#666666">=</span> s_recv (subscriber);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"<span style="white-space: pre-wrap;">[</span>%s<span style="white-space: pre-wrap;">]</span> %s</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, address, contents);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (address);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (contents);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We never get here, but clean up anyhow</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (subscriber);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_ctx_destroy (context);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:psenvsub" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:psenvsub" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/clj:psenvsub" target="_blank">Clojure</a> | <a href="http://zguide.zeromq.org/lisp:psenvsub" target="_blank">CL</a> | <a href="http://zguide.zeromq.org/dpr:psenvsub" target="_blank">Delphi</a> | <a href="http://zguide.zeromq.org/es:psenvsub" target="_blank">Erlang</a> | <a href="http://zguide.zeromq.org/fsx:psenvsub" target="_blank">F#</a> | <a href="http://zguide.zeromq.org/go:psenvsub" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:psenvsub" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:psenvsub" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:psenvsub" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:psenvsub" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/js:psenvsub" target="_blank">Node.js</a> | <a href="http://zguide.zeromq.org/pl:psenvsub" target="_blank">Perl</a> | <a href="http://zguide.zeromq.org/php:psenvsub" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:psenvsub" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rb:psenvsub" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/scala:psenvsub" target="_blank">Scala</a> | <a href="http://zguide.zeromq.org/tcl:psenvsub" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | Felix | Objective-C | ooc | Q | Racket</a></span>
<p>When you run the two programs, the subscriber should show you this:</p>
<div class="code">
<pre><code>[B] We would like to see this
[B] We would like to see this
[B] We would like to see this
...</code>
</pre></div>
<p>This example shows that the subscription filter rejects or accepts the entire multipart message (key plus data). You won't get part of a multipart message, ever. If you subscribe to multiple publishers and you want to know their address so that you can send them data via another socket (and this is a typical use case), create a three-part message.</p>
<p><strong>Figure 24 - Pub-Sub Envelope with Sender Address</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig24.png" alt="fig24.png" class="image"></div>
<p><a name="High-Water-Marks"></a><a name="header-51"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc50"><span><a href="http://zguide.zeromq.org/page:all#High-Water-Marks">High-Water Marks</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-50">prev</a> <a href="http://zguide.zeromq.org/page:all#header-52">next</a></td>
</tr>
</tbody></table>
<p>When you can send messages rapidly from process to process, you soon discover that memory is a precious resource, and one that can be trivially filled up. A few seconds of delay somewhere in a process can turn into a backlog that blows up a server unless you understand the problem and take precautions.</p>
<p>The problem is this: imagine you have process A sending messages at high frequency to process B, which is processing them. Suddenly B gets very busy (garbage collection, CPU overload, whatever), and can't process the messages for a short period. It could be a few seconds for some heavy garbage collection, or it could be much longer, if there's a more serious problem. What happens to the messages that process A is still trying to send frantically? Some will sit in B's network buffers. Some will sit on the Ethernet wire itself. Some will sit in A's network buffers. And the rest will accumulate in A's memory, as rapidly as the application behind A sends them. If you don't take some precaution, A can easily run out of memory and crash.</p>
<p>It is a consistent, classic problem with message brokers. What makes it hurt more is that it's B's fault, superficially, and B is typically a user-written application which A has no control over.</p>
<p>What are the answers? One is to pass the problem upstream. A is getting the messages from somewhere else. So tell that process, "Stop!" And so on. This is called <em>flow control</em>. It sounds plausible, but what if you're sending out a Twitter feed? Do you tell the whole world to stop tweeting while B gets its act together?</p>
<p>Flow control works in some cases, but not in others. The transport layer can't tell the application layer to "stop" any more than a subway system can tell a large business, "please keep your staff at work for another half an hour. I'm too busy". The answer for messaging is to set limits on the size of buffers, and then when we reach those limits, to take some sensible action. In some cases (not for a subway system, though), the answer is to throw away messages. In others, the best strategy is to wait.</p>
<p>ZeroMQ uses the concept of HWM (high-water mark) to define the capacity of its internal pipes. Each connection out of a socket or into a socket has its own pipe, and HWM for sending, and/or receiving, depending on the socket type. Some sockets (PUB, PUSH) only have send buffers. Some (SUB, PULL, REQ, REP) only have receive buffers. Some (DEALER, ROUTER, PAIR) have both send and receive buffers.</p>
<p>In ZeroMQ v2.x, the HWM was infinite by default. This was easy but also typically fatal for high-volume publishers. In ZeroMQ v3.x, it's set to 1,000 by default, which is more sensible. If you're still using ZeroMQ v2.x, you should always set a HWM on your sockets, be it 1,000 to match ZeroMQ v3.x or another figure that takes into account your message sizes and expected subscriber performance.</p>
<p>When your socket reaches its HWM, it will either block or drop data depending on the socket type. PUB and ROUTER sockets will drop data if they reach their HWM, while other socket types will block. Over the <tt>inproc</tt> transport, the sender and receiver share the same buffers, so the real HWM is the sum of the HWM set by both sides.</p>
<p>Lastly, the HWMs are not exact; while you may get <em>up to</em> 1,000 messages by default, the real buffer size may be much lower (as little as half), due to the way <tt>libzmq</tt> implements its queues.</p>
<p><a name="Missing-Message-Problem-Solver"></a><a name="header-52"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc51"><span><a href="http://zguide.zeromq.org/page:all#Missing-Message-Problem-Solver">Missing Message Problem Solver</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-51">prev</a> <a href="http://zguide.zeromq.org/page:all#header-53">next</a></td>
</tr>
</tbody></table>
<p>As you build applications with ZeroMQ, you will come across this problem more than once: losing messages that you expect to receive. We have put together a diagram that walks through the most common causes for this.</p>
<p><strong>Figure 25 - Missing Message Problem Solver</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig25.png" alt="fig25.png" class="image"></div>
<p>Here's a summary of what the graphic says:</p>
<ul>
<li>On SUB sockets, set a subscription using <tt><a href="http://api.zeromq.org/3-2:zmq_setsockopt">zmq_setsockopt()</a></tt> with <tt>ZMQ_SUBSCRIBE</tt>, or you won't get messages. Because you subscribe to messages by prefix, if you subscribe to "" (an empty subscription), you will get everything.</li>
</ul>
<ul>
<li>If you start the SUB socket (i.e., establish a connection to a PUB socket) <em>after</em> the PUB socket has started sending out data, you will lose whatever it published before the connection was made. If this is a problem, set up your architecture so the SUB socket starts first, then the PUB socket starts publishing.</li>
</ul>
<ul>
<li>Even if you synchronize a SUB and PUB socket, you may still lose messages. It's due to the fact that internal queues aren't created until a connection is actually created. If you can switch the bind/connect direction so the SUB socket binds, and the PUB socket connects, you may find it works more as you'd expect.</li>
</ul>
<ul>
<li>If you're using REP and REQ sockets, and you're not sticking to the synchronous send/recv/send/recv order, ZeroMQ will report errors, which you might ignore. Then, it would look like you're losing messages. If you use REQ or REP, stick to the send/recv order, and always, in real code, check for errors on ZeroMQ calls.</li>
</ul>
<ul>
<li>If you're using PUSH sockets, you'll find that the first PULL socket to connect will grab an unfair share of messages. The accurate rotation of messages only happens when all PULL sockets are successfully connected, which can take some milliseconds. As an alternative to PUSH/PULL, for lower data rates, consider using ROUTER/DEALER and the load balancing pattern.</li>
</ul>
<ul>
<li>If you're sharing sockets across threads, don't. It will lead to random weirdness, and crashes.</li>
</ul>
<ul>
<li>If you're using <tt>inproc</tt>, make sure both sockets are in the same context. Otherwise the connecting side will in fact fail. Also, bind first, then connect. <tt>inproc</tt> is not a disconnected transport like <tt>tcp</tt>.</li>
</ul>
<ul>
<li>If you're using ROUTER sockets, it's remarkably easy to lose messages by accident, by sending malformed identity frames (or forgetting to send an identity frame). In general setting the <tt>ZMQ_ROUTER_MANDATORY</tt> option on ROUTER sockets is a good idea, but do also check the return code on every send call.</li>
</ul>
<ul>
<li>Lastly, if you really can't figure out what's going wrong, make a <em>minimal</em> test case that reproduces the problem, and ask for help from the ZeroMQ community.</li>
</ul>
<p><a name="advanced-request-reply"></a><br>
<a name="Chapter-Advanced-Request-Reply-Patterns"></a><a name="header-53"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h2 id="toc52"><span><a href="http://zguide.zeromq.org/page:all#Chapter-Advanced-Request-Reply-Patterns">Chapter 3 - Advanced Request-Reply Patterns</a></span></h2>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-52">prev</a> <a href="http://zguide.zeromq.org/page:all#header-54">next</a></td>
</tr>
</tbody></table>
<p>In <a href="http://zguide.zeromq.org/page:all#sockets-and-patterns">Chapter 2 - Sockets and Patterns</a> we worked through the basics of using ZeroMQ by developing a series of small applications, each time exploring new aspects of ZeroMQ. We'll continue this approach in this chapter as we explore advanced patterns built on top of ZeroMQ's core request-reply pattern.</p>
<p>We'll cover:</p>
<ul>
<li>How the request-reply mechanisms work</li>
<li>How to combine REQ, REP, DEALER, and ROUTER sockets</li>
<li>How ROUTER sockets work, in detail</li>
<li>The load balancing pattern</li>
<li>Building a simple load balancing message broker</li>
<li>Designing a high-level API for ZeroMQ</li>
<li>Building an asynchronous request-reply server</li>
<li>A detailed inter-broker routing example</li>
</ul>
<p><a name="The-Request-Reply-Mechanisms"></a><a name="header-54"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc53"><span><a href="http://zguide.zeromq.org/page:all#The-Request-Reply-Mechanisms">The Request-Reply Mechanisms</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-53">prev</a> <a href="http://zguide.zeromq.org/page:all#header-55">next</a></td>
</tr>
</tbody></table>
<p>We already looked briefly at multipart messages. Let's now look at a major use case, which is <em>reply message envelopes</em>. An envelope is a way of safely packaging up data with an address, without touching the data itself. By separating reply addresses into an envelope we make it possible to write general purpose intermediaries such as APIs and proxies that create, read, and remove addresses no matter what the message payload or structure is.</p>
<p>In the request-reply pattern, the envelope holds the return address for replies. It is how a ZeroMQ network with no state can create round-trip request-reply dialogs.</p>
<p>When you use REQ and REP sockets you don't even see envelopes; these sockets deal with them automatically. But for most of the interesting request-reply patterns, you'll want to understand envelopes and particularly ROUTER sockets. We'll work through this step-by-step.</p>
<p><a name="The-Simple-Reply-Envelope"></a><a name="header-55"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc54"><span><a href="http://zguide.zeromq.org/page:all#The-Simple-Reply-Envelope">The Simple Reply Envelope</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-54">prev</a> <a href="http://zguide.zeromq.org/page:all#header-56">next</a></td>
</tr>
</tbody></table>
<p>A request-reply exchange consists of a <em>request</em> message, and an eventual <em>reply</em> message. In the simple request-reply pattern, there's one reply for each request. In more advanced patterns, requests and replies can flow asynchronously. However, the reply envelope always works the same way.</p>
<p>The ZeroMQ reply envelope formally consists of zero or more reply addresses, followed by an empty frame (the envelope delimiter), followed by the message body (zero or more frames). The envelope is created by multiple sockets working together in a chain. We'll break this down.</p>
<p>We'll start by sending "Hello" through a REQ socket. The REQ socket creates the simplest possible reply envelope, which has no addresses, just an empty delimiter frame and the message frame containing the "Hello" string. This is a two-frame message.</p>
<p><strong>Figure 26 - Request with Minimal Envelope</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig26.png" alt="fig26.png" class="image"></div>
<p>The REP socket does the matching work: it strips off the envelope, up to and including the delimiter frame, saves the whole envelope, and passes the "Hello" string up the application. Thus our original Hello World example used request-reply envelopes internally, but the application never saw them.</p>
<p>If you spy on the network data flowing between <tt>hwclient</tt> and <tt>hwserver</tt>, this is what you'll see: every request and every reply is in fact two frames, an empty frame and then the body. It doesn't seem to make much sense for a simple REQ-REP dialog. However you'll see the reason when we explore how ROUTER and DEALER handle envelopes.</p>
<p><a name="The-Extended-Reply-Envelope"></a><a name="header-56"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc55"><span><a href="http://zguide.zeromq.org/page:all#The-Extended-Reply-Envelope">The Extended Reply Envelope</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-55">prev</a> <a href="http://zguide.zeromq.org/page:all#header-57">next</a></td>
</tr>
</tbody></table>
<p>Now let's extend the REQ-REP pair with a ROUTER-DEALER proxy in the middle and see how this affects the reply envelope. This is the <em>extended request-reply pattern</em> we already saw in <a href="http://zguide.zeromq.org/page:all#sockets-and-patterns">Chapter 2 - Sockets and Patterns</a>. We can, in fact, insert any number of proxy steps. The mechanics are the same.</p>
<p><strong>Figure 27 - Extended Request-Reply Pattern</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig27.png" alt="fig27.png" class="image"></div>
<p>The proxy does this, in pseudo-code:</p>
<div class="code">
<pre><code>prepare context, frontend and backend sockets
while true:
    poll on both sockets
    if frontend had input:
        read all frames from frontend
        send to backend
    if backend had input:
        read all frames from backend
        send to frontend</code>
</pre></div>
<p>The ROUTER socket, unlike other sockets, tracks every connection it has, and tells the caller about these. The way it tells the caller is to stick the connection <em>identity</em> in front of each message received. An identity, sometimes called an <em>address</em>, is just a binary string with no meaning except "this is a unique handle to the connection". Then, when you send a message via a ROUTER socket, you first send an identity frame.</p>
<p>The <tt><a href="http://api.zeromq.org/3-2:zmq_socket">zmq_socket()</a></tt> man page describes it thus:</p>
<blockquote>
<p>When receiving messages a ZMQ_ROUTER socket shall prepend a message part containing the identity of the originating peer to the message before passing it to the application. Messages received are fair-queued from among all connected peers. When sending messages a ZMQ_ROUTER socket shall remove the first part of the message and use it to determine the identity of the peer the message shall be routed to.</p>
</blockquote>
<p>As a historical note, ZeroMQ v2.2 and earlier use UUIDs as identities. ZeroMQ v3.0 and later generate a 5 byte identity by default (0 + a random 32bit integer). There's some impact on network performance, but only when you use multiple proxy hops, which is rare. Mostly the change was to simplify building <tt>libzmq</tt> by removing the dependency on a UUID library.</p>
<p>Identities are a difficult concept to understand, but it's essential if you want to become a ZeroMQ expert. The ROUTER socket <em>invents</em> a random identity for each connection with which it works. If there are three REQ sockets connected to a ROUTER socket, it will invent three random identities, one for each REQ socket.</p>
<p>So if we continue our worked example, let's say the REQ socket has a 3-byte identity <tt>ABC</tt>. Internally, this means the ROUTER socket keeps a hash table where it can search for <tt>ABC</tt> and find the TCP connection for the REQ socket.</p>
<p>When we receive the message off the ROUTER socket, we get three frames.</p>
<p><strong>Figure 28 - Request with One Address</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig28.png" alt="fig28.png" class="image"></div>
<p>The core of the proxy loop is "read from one socket, write to the other", so we literally send these three frames out on the DEALER socket. If you now sniffed the network traffic, you would see these three frames flying from the DEALER socket to the REP socket. The REP socket does as before, strips off the whole envelope including the new reply address, and once again delivers the "Hello" to the caller.</p>
<p>Incidentally the REP socket can only deal with one request-reply exchange at a time, which is why if you try to read multiple requests or send multiple replies without sticking to a strict recv-send cycle, it gives an error.</p>
<p>You should now be able to visualize the return path. When <tt>hwserver</tt> sends "World" back, the REP socket wraps that with the envelope it saved, and sends a three-frame reply message across the wire to the DEALER socket.</p>
<p><strong>Figure 29 - Reply with one Address</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig29.png" alt="fig29.png" class="image"></div>
<p>Now the DEALER reads these three frames, and sends all three out via the ROUTER socket. The ROUTER takes the first frame for the message, which is the <tt>ABC</tt> identity, and looks up the connection for this. If it finds that, it then pumps the next two frames out onto the wire.</p>
<p><strong>Figure 30 - Reply with Minimal Envelope</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig30.png" alt="fig30.png" class="image"></div>
<p>The REQ socket picks this message up, and checks that the first frame is the empty delimiter, which it is. The REQ socket discards that frame and passes "World" to the calling application, which prints it out to the amazement of the younger us looking at ZeroMQ for the first time.</p>
<p><a name="What-s-This-Good-For"></a><a name="header-57"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc56"><span><a href="http://zguide.zeromq.org/page:all#What-s-This-Good-For">What's This Good For?</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-56">prev</a> <a href="http://zguide.zeromq.org/page:all#header-58">next</a></td>
</tr>
</tbody></table>
<p>To be honest, the use cases for strict request-reply or extended request-reply are somewhat limited. For one thing, there's no easy way to recover from common failures like the server crashing due to buggy application code. We'll see more about this in <a href="http://zguide.zeromq.org/page:all#reliable-request-reply">Chapter 4 - Reliable Request-Reply Patterns</a>. However once you grasp the way these four sockets deal with envelopes, and how they talk to each other, you can do very useful things. We saw how ROUTER uses the reply envelope to decide which client REQ socket to route a reply back to. Now let's express this another way:</p>
<ul>
<li>Each time ROUTER gives you a message, it tells you what peer that came from, as an identity.</li>
<li>You can use this with a hash table (with the identity as key) to track new peers as they arrive.</li>
<li>ROUTER will route messages asynchronously to any peer connected to it, if you prefix the identity as the first frame of the message.</li>
</ul>
<p>ROUTER sockets don't care about the whole envelope. They don't know anything about the empty delimiter. All they care about is that one identity frame that lets them figure out which connection to send a message to.</p>
<p><a name="Recap-of-Request-Reply-Sockets"></a><a name="header-58"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc57"><span><a href="http://zguide.zeromq.org/page:all#Recap-of-Request-Reply-Sockets">Recap of Request-Reply Sockets</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-57">prev</a> <a href="http://zguide.zeromq.org/page:all#header-59">next</a></td>
</tr>
</tbody></table>
<p>Let's recap this:</p>
<ul>
<li>The REQ socket sends, to the network, an empty delimiter frame in front of the message data. REQ sockets are synchronous. REQ sockets always send one request and then wait for one reply. REQ sockets talk to one peer at a time. If you connect a REQ socket to multiple peers, requests are distributed to and replies expected from each peer one turn at a time.</li>
</ul>
<ul>
<li>The REP socket reads and saves all identity frames up to and including the empty delimiter, then passes the following frame or frames to the caller. REP sockets are synchronous and talk to one peer at a time. If you connect a REP socket to multiple peers, requests are read from peers in fair fashion, and replies are always sent to the same peer that made the last request.</li>
</ul>
<ul>
<li>The DEALER socket is oblivious to the reply envelope and handles this like any multipart message. DEALER sockets are asynchronous and like PUSH and PULL combined. They distribute sent messages among all connections, and fair-queue received messages from all connections.</li>
</ul>
<ul>
<li>The ROUTER socket is oblivious to the reply envelope, like DEALER. It creates identities for its connections, and passes these identities to the caller as a first frame in any received message. Conversely, when the caller sends a message, it uses the first message frame as an identity to look up the connection to send to. ROUTERS are asynchronous.</li>
</ul>
<p><a name="Request-Reply-Combinations"></a><a name="header-59"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc58"><span><a href="http://zguide.zeromq.org/page:all#Request-Reply-Combinations">Request-Reply Combinations</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-58">prev</a> <a href="http://zguide.zeromq.org/page:all#header-60">next</a></td>
</tr>
</tbody></table>
<p>We have four request-reply sockets, each with a certain behavior. We've seen how they connect in simple and extended request-reply patterns. But these sockets are building blocks that you can use to solve many problems.</p>
<p>These are the legal combinations:</p>
<ul>
<li>REQ to REP</li>
<li>DEALER to REP</li>
<li>REQ to ROUTER</li>
<li>DEALER to ROUTER</li>
<li>DEALER to DEALER</li>
<li>ROUTER to ROUTER</li>
</ul>
<p>And these combinations are invalid (and I'll explain why):</p>
<ul>
<li>REQ to REQ</li>
<li>REQ to DEALER</li>
<li>REP to REP</li>
<li>REP to ROUTER</li>
</ul>
<p>Here are some tips for remembering the semantics. DEALER is like an asynchronous REQ socket, and ROUTER is like an asynchronous REP socket. Where we use a REQ socket, we can use a DEALER; we just have to read and write the envelope ourselves. Where we use a REP socket, we can stick a ROUTER; we just need to manage the identities ourselves.</p>
<p>Think of REQ and DEALER sockets as "clients" and REP and ROUTER sockets as "servers". Mostly, you'll want to bind REP and ROUTER sockets, and connect REQ and DEALER sockets to them. It's not always going to be this simple, but it is a clean and memorable place to start.</p>
<p><a name="The-REQ-to-REP-Combination"></a><a name="header-60"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc59"><span><a href="http://zguide.zeromq.org/page:all#The-REQ-to-REP-Combination">The REQ to REP Combination</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-59">prev</a> <a href="http://zguide.zeromq.org/page:all#header-61">next</a></td>
</tr>
</tbody></table>
<p>We've already covered a REQ client talking to a REP server but let's take one aspect: the REQ client <em>must</em> initiate the message flow. A REP server cannot talk to a REQ client that hasn't first sent it a request. Technically, it's not even possible, and the API also returns an <tt>EFSM</tt> error if you try it.</p>
<p><a name="The-DEALER-to-REP-Combination"></a><a name="header-61"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc60"><span><a href="http://zguide.zeromq.org/page:all#The-DEALER-to-REP-Combination">The DEALER to REP Combination</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-60">prev</a> <a href="http://zguide.zeromq.org/page:all#header-62">next</a></td>
</tr>
</tbody></table>
<p>Now, let's replace the REQ client with a DEALER. This gives us an asynchronous client that can talk to multiple REP servers. If we rewrote the "Hello World" client using DEALER, we'd be able to send off any number of "Hello" requests without waiting for replies.</p>
<p>When we use a DEALER to talk to a REP socket, we <em>must</em> accurately emulate the envelope that the REQ socket would have sent, or the REP socket will discard the message as invalid. So, to send a message, we:</p>
<ul>
<li>Send an empty message frame with the MORE flag set; then</li>
<li>Send the message body.</li>
</ul>
<p>And when we receive a message, we:</p>
<ul>
<li>Receive the first frame and if it's not empty, discard the whole message;</li>
<li>Receive the next frame and pass that to the application.</li>
</ul>
<p><a name="The-REQ-to-ROUTER-Combination"></a><a name="header-62"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc61"><span><a href="http://zguide.zeromq.org/page:all#The-REQ-to-ROUTER-Combination">The REQ to ROUTER Combination</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-61">prev</a> <a href="http://zguide.zeromq.org/page:all#header-63">next</a></td>
</tr>
</tbody></table>
<p>In the same way that we can replace REQ with DEALER, we can replace REP with ROUTER. This gives us an asynchronous server that can talk to multiple REQ clients at the same time. If we rewrote the "Hello World" server using ROUTER, we'd be able to process any number of "Hello" requests in parallel. We saw this in the <a href="http://zguide.zeromq.org/page:all#sockets-and-patterns">Chapter 2 - Sockets and Patterns</a> <tt>mtserver</tt> example.</p>
<p>We can use ROUTER in two distinct ways:</p>
<ul>
<li>As a proxy that switches messages between frontend and backend sockets.</li>
<li>As an application that reads the message and acts on it.</li>
</ul>
<p>In the first case, the ROUTER simply reads all frames, including the artificial identity frame, and passes them on blindly. In the second case the ROUTER <em>must</em> know the format of the reply envelope it's being sent. As the other peer is a REQ socket, the ROUTER gets the identity frame, an empty frame, and then the data frame.</p>
<p><a name="The-DEALER-to-ROUTER-Combination"></a><a name="header-63"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc62"><span><a href="http://zguide.zeromq.org/page:all#The-DEALER-to-ROUTER-Combination">The DEALER to ROUTER Combination</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-62">prev</a> <a href="http://zguide.zeromq.org/page:all#header-64">next</a></td>
</tr>
</tbody></table>
<p>Now we can switch out both REQ and REP with DEALER and ROUTER to get the most powerful socket combination, which is DEALER talking to ROUTER. It gives us asynchronous clients talking to asynchronous servers, where both sides have full control over the message formats.</p>
<p>Because both DEALER and ROUTER can work with arbitrary message formats, if you hope to use these safely, you have to become a little bit of a protocol designer. At the very least you must decide whether you wish to emulate the REQ/REP reply envelope. It depends on whether you actually need to send replies or not.</p>
<p><a name="The-DEALER-to-DEALER-Combination"></a><a name="header-64"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc63"><span><a href="http://zguide.zeromq.org/page:all#The-DEALER-to-DEALER-Combination">The DEALER to DEALER Combination</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-63">prev</a> <a href="http://zguide.zeromq.org/page:all#header-65">next</a></td>
</tr>
</tbody></table>
<p>You can swap a REP with a ROUTER, but you can also swap a REP with a DEALER, if the DEALER is talking to one and only one peer.</p>
<p>When you replace a REP with a DEALER, your worker can suddenly go full asynchronous, sending any number of replies back. The cost is that you have to manage the reply envelopes yourself, and get them right, or nothing at all will work. We'll see a worked example later. Let's just say for now that DEALER to DEALER is one of the trickier patterns to get right, and happily it's rare that we need it.</p>
<p><a name="The-ROUTER-to-ROUTER-Combination"></a><a name="header-65"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc64"><span><a href="http://zguide.zeromq.org/page:all#The-ROUTER-to-ROUTER-Combination">The ROUTER to ROUTER Combination</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-64">prev</a> <a href="http://zguide.zeromq.org/page:all#header-66">next</a></td>
</tr>
</tbody></table>
<p>This sounds perfect for N-to-N connections, but it's the most difficult combination to use. You should avoid it until you are well advanced with ZeroMQ. We'll see one example it in the Freelance pattern in <a href="http://zguide.zeromq.org/page:all#reliable-request-reply">Chapter 4 - Reliable Request-Reply Patterns</a>, and an alternative DEALER to ROUTER design for peer-to-peer work in <a href="http://zguide.zeromq.org/page:all#moving-pieces">Chapter 8 - A Framework for Distributed Computing</a>.</p>
<p><a name="Invalid-Combinations"></a><a name="header-66"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc65"><span><a href="http://zguide.zeromq.org/page:all#Invalid-Combinations">Invalid Combinations</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-65">prev</a> <a href="http://zguide.zeromq.org/page:all#header-67">next</a></td>
</tr>
</tbody></table>
<p>Mostly, trying to connect clients to clients, or servers to servers is a bad idea and won't work. However, rather than give general vague warnings, I'll explain in detail:</p>
<ul>
<li>REQ to REQ: both sides want to start by sending messages to each other, and this could only work if you timed things so that both peers exchanged messages at the same time. It hurts my brain to even think about it.</li>
</ul>
<ul>
<li>REQ to DEALER: you could in theory do this, but it would break if you added a second REQ because DEALER has no way of sending a reply to the original peer. Thus the REQ socket would get confused, and/or return messages meant for another client.</li>
</ul>
<ul>
<li>REP to REP: both sides would wait for the other to send the first message.</li>
</ul>
<ul>
<li>REP to ROUTER: the ROUTER socket can in theory initiate the dialog and send a properly-formatted request, if it knows the REP socket has connected <em>and</em> it knows the identity of that connection. It's messy and adds nothing over DEALER to ROUTER.</li>
</ul>
<p>The common thread in this valid versus invalid breakdown is that a ZeroMQ socket connection is always biased towards one peer that binds to an endpoint, and another that connects to that. Further, that which side binds and which side connects is not arbitrary, but follows natural patterns. The side which we expect to "be there" binds: it'll be a server, a broker, a publisher, a collector. The side that "comes and goes" connects: it'll be clients and workers. Remembering this will help you design better ZeroMQ architectures.</p>
<p><a name="Exploring-ROUTER-Sockets"></a><a name="header-67"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc66"><span><a href="http://zguide.zeromq.org/page:all#Exploring-ROUTER-Sockets">Exploring ROUTER Sockets</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-66">prev</a> <a href="http://zguide.zeromq.org/page:all#header-68">next</a></td>
</tr>
</tbody></table>
<p>Let's look at ROUTER sockets a little closer. We've already seen how they work by routing individual messages to specific connections. I'll explain in more detail how we identify those connections, and what a ROUTER socket does when it can't send a message.</p>
<p><a name="Identities-and-Addresses"></a><a name="header-68"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc67"><span><a href="http://zguide.zeromq.org/page:all#Identities-and-Addresses">Identities and Addresses</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-67">prev</a> <a href="http://zguide.zeromq.org/page:all#header-69">next</a></td>
</tr>
</tbody></table>
<p>The <em>identity</em> concept in ZeroMQ refers specifically to ROUTER sockets and how they identify the connections they have to other sockets. More broadly, identities are used as addresses in the reply envelope. In most cases, the identity is arbitrary and local to the ROUTER socket: it's a lookup key in a hash table. Independently, a peer can have an address that is physical (a network endpoint like "tcp://192.168.55.117:5670") or logical (a UUID or email address or other unique key).</p>
<p>An application that uses a ROUTER socket to talk to specific peers can convert a logical address to an identity if it has built the necessary hash table. Because ROUTER sockets only announce the identity of a connection (to a specific peer) when that peer sends a message, you can only really reply to a message, not spontaneously talk to a peer.</p>
<p>This is true even if you flip the rules and make the ROUTER connect to the peer rather than wait for the peer to connect to the ROUTER. However you can force the ROUTER socket to use a logical address in place of its identity. The <tt>zmq_setsockopt</tt> reference page calls this <em>setting the socket identity</em>. It works as follows:</p>
<ul>
<li>The peer application sets the <tt>ZMQ_IDENTITY</tt> option of its peer socket (DEALER or REQ) <em>before</em> binding or connecting.</li>
<li>Usually the peer then connects to the already-bound ROUTER socket. But the ROUTER can also connect to the peer.</li>
<li>At connection time, the peer socket tells the router socket, "please use this identity for this connection".</li>
<li>If the peer socket doesn't say that, the router generates its usual arbitrary random identity for the connection.</li>
<li>The ROUTER socket now provides this logical address to the application as a prefix identity frame for any messages coming in from that peer.</li>
<li>The ROUTER also expects the logical address as the prefix identity frame for any outgoing messages.</li>
</ul>
<p>Here is a simple example of two peers that connect to a ROUTER socket, one that imposes a logical address "PEER2":</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">identity:&nbsp;Identity&nbsp;check&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">identity:&nbsp;Identity&nbsp;check&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Demonstrate request-reply identities</em></span></p>
<p><span style="color:#BC7A00">#include "zhelpers.h"</span></p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zmq_ctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>sink <span style="color:#666666">=</span> zmq_socket (context, ZMQ_ROUTER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_bind (sink, <span style="color:#BA2121">"inproc:<span style="white-space: pre-wrap;">//</span>example"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>First allow 0MQ to set the identity</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>anonymous <span style="color:#666666">=</span> zmq_socket (context, ZMQ_REQ);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_connect (anonymous, <span style="color:#BA2121">"inproc:<span style="white-space: pre-wrap;">//</span>example"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_send (anonymous, <span style="color:#BA2121">"ROUTER uses a generated 5 byte identity"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_dump (sink);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Then set the identity ourselves</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>identified <span style="color:#666666">=</span> zmq_socket (context, ZMQ_REQ);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_setsockopt (identified, ZMQ_IDENTITY, <span style="color:#BA2121">"PEER2"</span>, <span style="color:#666666">5</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_connect (identified, <span style="color:#BA2121">"inproc:<span style="white-space: pre-wrap;">//</span>example"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_send (identified, <span style="color:#BA2121">"ROUTER socket uses REQ's socket identity"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_dump (sink);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (sink);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (anonymous);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (identified);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_ctx_destroy (context);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:identity" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:identity" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/clj:identity" target="_blank">Clojure</a> | <a href="http://zguide.zeromq.org/lisp:identity" target="_blank">CL</a> | <a href="http://zguide.zeromq.org/dpr:identity" target="_blank">Delphi</a> | <a href="http://zguide.zeromq.org/es:identity" target="_blank">Erlang</a> | <a href="http://zguide.zeromq.org/fsx:identity" target="_blank">F#</a> | <a href="http://zguide.zeromq.org/go:identity" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:identity" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:identity" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:identity" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:identity" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/js:identity" target="_blank">Node.js</a> | <a href="http://zguide.zeromq.org/pl:identity" target="_blank">Perl</a> | <a href="http://zguide.zeromq.org/php:identity" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:identity" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/q:identity" target="_blank">Q</a> | <a href="http://zguide.zeromq.org/rb:identity" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/scala:identity" target="_blank">Scala</a> | <a href="http://zguide.zeromq.org/tcl:identity" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | Felix | Objective-C | ooc | Racket</a></span>
<p>Here is what the program prints:</p>
<div class="code">
<pre><code>----------------------------------------
[005] 006B8B4567
[000]
[039] ROUTER uses a generated 5 byte identity
----------------------------------------
[005] PEER2
[000]
[038] ROUTER uses REQ's socket identity</code>
</pre></div>
<p><a name="ROUTER-Error-Handling"></a><a name="header-69"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc68"><span><a href="http://zguide.zeromq.org/page:all#ROUTER-Error-Handling">ROUTER Error Handling</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-68">prev</a> <a href="http://zguide.zeromq.org/page:all#header-70">next</a></td>
</tr>
</tbody></table>
<p>ROUTER sockets do have a somewhat brutal way of dealing with messages they can't send anywhere: they drop them silently. It's an attitude that makes sense in working code, but it makes debugging hard. The "send identity as first frame" approach is tricky enough that we often get this wrong when we're learning, and the ROUTER's stony silence when we mess up isn't very constructive.</p>
<p>Since ZeroMQ v3.2 there's a socket option you can set to catch this error: <tt>ZMQ_ROUTER_MANDATORY</tt>. Set that on the ROUTER socket and then when you provide an unroutable identity on a send call, the socket will signal an <tt>EHOSTUNREACH</tt> error.</p>
<p><a name="The-Load-Balancing-Pattern"></a><a name="header-70"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc69"><span><a href="http://zguide.zeromq.org/page:all#The-Load-Balancing-Pattern">The Load Balancing Pattern</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-69">prev</a> <a href="http://zguide.zeromq.org/page:all#header-71">next</a></td>
</tr>
</tbody></table>
<p>Now let's look at some code. We'll see how to connect a ROUTER socket to a REQ socket, and then to a DEALER socket. These two examples follow the same logic, which is a <em>load balancing</em> pattern. This pattern is our first exposure to using the ROUTER socket for deliberate routing, rather than simply acting as a reply channel.</p>
<p>The load balancing pattern is very common and we'll see it several times in this book. It solves the main problem with simple round robin routing (as PUSH and DEALER offer) which is that round robin becomes inefficient if tasks do not all roughly take the same time.</p>
<p>It's the post office analogy. If you have one queue per counter, and you have some people buying stamps (a fast, simple transaction), and some people opening new accounts (a very slow transaction), then you will find stamp buyers getting unfairly stuck in queues. Just as in a post office, if your messaging architecture is unfair, people will get annoyed.</p>
<p>The solution in the post office is to create a single queue so that even if one or two counters get stuck with slow work, other counters will continue to serve clients on a first-come, first-serve basis.</p>
<p>One reason PUSH and DEALER use the simplistic approach is sheer performance. If you arrive in any major US airport, you'll find long queues of people waiting at immigration. The border patrol officials will send people in advance to queue up at each counter, rather than using a single queue. Having people walk fifty yards in advance saves a minute or two per passenger. And because every passport check takes roughly the same time, it's more or less fair. This is the strategy for PUSH and DEALER: send work loads ahead of time so that there is less travel distance.</p>
<p>This is a recurring theme with ZeroMQ: the world's problems are diverse and you can benefit from solving different problems each in the right way. The airport isn't the post office and one size fits no one, really well.</p>
<p>Let's return to the scenario of a worker (DEALER or REQ) connected to a broker (ROUTER). The broker has to know when the worker is ready, and keep a list of workers so that it can take the <em>least recently used</em> worker each time.</p>
<p>The solution is really simple, in fact: workers send a "ready" message when they start, and after they finish each task. The broker reads these messages one-by-one. Each time it reads a message, it is from the last used worker. And because we're using a ROUTER socket, we get an identity that we can then use to send a task back to the worker.</p>
<p>It's a twist on request-reply because the task is sent with the reply, and any response for the task is sent as a new request. The following code examples should make it clearer.</p>
<p><a name="ROUTER-Broker-and-REQ-Workers"></a><a name="header-71"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc70"><span><a href="http://zguide.zeromq.org/page:all#ROUTER-Broker-and-REQ-Workers">ROUTER Broker and REQ Workers</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-70">prev</a> <a href="http://zguide.zeromq.org/page:all#header-72">next</a></td>
</tr>
</tbody></table>
<p>Here is an example of the load balancing pattern using a ROUTER broker talking to a set of REQ workers:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">rtreq:&nbsp;ROUTER-to-REQ&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">rtreq:&nbsp;ROUTER-to-REQ&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span> 2015-01-16T09:56+08:00<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>ROUTER-to-REQ example</span></p>
<p>#include "zhelpers.h"<br>
#include &lt;pthread.h&gt;</p>
<p>#define NBR_WORKERS 10</p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span> <span style="color:#666666">*</span><br>
<span style="color:#0000FF">worker_task</span>(<span style="color:#B00040">void</span> <span style="color:#666666">*</span>args)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zmq_ctx_new();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>worker <span style="color:#666666">=</span> zmq_socket(context, ZMQ_REQ);<br>
<span style="color:#BC7A00"><br>
#if (defined (WIN32))</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_set_id(worker, (<span style="color:#B00040">intptr_t</span>)args);<br>
<span style="color:#BC7A00">#else</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_set_id(worker);<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Set a printable identity.</em></span><br>
<span style="color:#BC7A00">#endif</span></p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zmq_connect(worker, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5671"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> total <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Tell the broker we're ready for work</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>s_send(worker, <span style="color:#BA2121">"Hi Boss"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Get workload from broker, until finished</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>workload <span style="color:#666666">=</span> s_recv(worker);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> finished <span style="color:#666666">=</span> (strcmp(workload, <span style="color:#BA2121">"Fired!"</span>) <span style="color:#666666">==</span> <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free(workload);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (finished) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf(<span style="color:#BA2121">"Completed: %d tasks</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, total);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>total<span style="color:#666666">++</span>;</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Do some random work</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>s_sleep(randof(<span style="color:#666666">500</span>) <span style="color:#666666">+</span> <span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close(worker);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_ctx_destroy(context);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#008000">NULL</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>While this example runs in a single process, that is only to make<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>it easier to start and stop the example. Each thread has its own<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>context and conceptually acts as a separate process.</span></span></p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span>(<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zmq_ctx_new();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>broker <span style="color:#666666">=</span> zmq_socket(context, ZMQ_ROUTER);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zmq_bind(broker, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5671"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>srandom((<span style="color:#B00040">unsigned</span>)time(<span style="color:#008000">NULL</span>));</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> worker_nbr;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (worker_nbr <span style="color:#666666">=</span> <span style="color:#666666">0</span>; worker_nbr <span style="color:#666666">&lt;</span> NBR_WORKERS; worker_nbr<span style="color:#666666">++</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>pthread_t worker;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>pthread_create(<span style="color:#666666">&amp;</span>worker, <span style="color:#008000">NULL</span>, worker_task, (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>)(<span style="color:#B00040">intptr_t</span>)worker_nbr);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Run for five seconds and then tell workers to end</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int64_t</span> end_time <span style="color:#666666">=</span> s_clock() <span style="color:#666666">+</span> <span style="color:#666666">5000</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> workers_fired <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Next message gives us least recently used worker</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>identity <span style="color:#666666">=</span> s_recv(broker);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>s_sendmore(broker, identity);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free(identity);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free(s_recv(broker));<tt><span style="white-space: pre-wrap;">     </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Envelope delimiter</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free(s_recv(broker));<tt><span style="white-space: pre-wrap;">     </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Response from worker</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>s_sendmore(broker, <span style="color:#BA2121">""</span>);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Encourage workers until it's time to fire them</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (s_clock() <span style="color:#666666">&lt;</span> end_time)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>s_send(broker, <span style="color:#BA2121">"Work harder"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>s_send(broker, <span style="color:#BA2121">"Fired!"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">++</span>workers_fired <span style="color:#666666">==</span> NBR_WORKERS)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close(broker);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_ctx_destroy(context);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:rtreq" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:rtreq" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/clj:rtreq" target="_blank">Clojure</a> | <a href="http://zguide.zeromq.org/lisp:rtreq" target="_blank">CL</a> | <a href="http://zguide.zeromq.org/dpr:rtreq" target="_blank">Delphi</a> | <a href="http://zguide.zeromq.org/es:rtreq" target="_blank">Erlang</a> | <a href="http://zguide.zeromq.org/fsx:rtreq" target="_blank">F#</a> | <a href="http://zguide.zeromq.org/go:rtreq" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:rtreq" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:rtreq" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:rtreq" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:rtreq" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/js:rtreq" target="_blank">Node.js</a> | <a href="http://zguide.zeromq.org/pl:rtreq" target="_blank">Perl</a> | <a href="http://zguide.zeromq.org/php:rtreq" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:rtreq" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rb:rtreq" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/scala:rtreq" target="_blank">Scala</a> | <a href="http://zguide.zeromq.org/tcl:rtreq" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | Felix | Objective-C | ooc | Q | Racket</a></span>
<p>The example runs for five seconds and then each worker prints how many tasks they handled. If the routing worked, we'd expect a fair distribution of work:</p>
<div class="code">
<pre><code>Completed: 20 tasks
Completed: 18 tasks
Completed: 21 tasks
Completed: 23 tasks
Completed: 19 tasks
Completed: 21 tasks
Completed: 17 tasks
Completed: 17 tasks
Completed: 25 tasks
Completed: 19 tasks</code>
</pre></div>
<p>To talk to the workers in this example, we have to create a REQ-friendly envelope consisting of an identity plus an empty envelope delimiter frame.</p>
<p><strong>Figure 31 - Routing Envelope for REQ</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig31.png" alt="fig31.png" class="image"></div>
<p><a name="ROUTER-Broker-and-DEALER-Workers"></a><a name="header-72"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc71"><span><a href="http://zguide.zeromq.org/page:all#ROUTER-Broker-and-DEALER-Workers">ROUTER Broker and DEALER Workers</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-71">prev</a> <a href="http://zguide.zeromq.org/page:all#header-73">next</a></td>
</tr>
</tbody></table>
<p>Anywhere you can use REQ, you can use DEALER. There are two specific differences:</p>
<ul>
<li>The REQ socket always sends an empty delimiter frame before any data frames; the DEALER does not.</li>
<li>The REQ socket will send only one message before it receives a reply; the DEALER is fully asynchronous.</li>
</ul>
<p>The synchronous versus asynchronous behavior has no effect on our example because we're doing strict request-reply. It is more relevant when we address recovering from failures, which we'll come to in <a href="http://zguide.zeromq.org/page:all#reliable-request-reply">Chapter 4 - Reliable Request-Reply Patterns</a>.</p>
<p>Now let's look at exactly the same example but with the REQ socket replaced by a DEALER socket:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">rtdealer:&nbsp;ROUTER-to-DEALER&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">rtdealer:&nbsp;ROUTER-to-DEALER&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span> 2015-02-27T11:40+08:00<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>ROUTER-to-DEALER example</span></p>
<p>#include "zhelpers.h"<br>
#include &lt;pthread.h&gt;<br>
#define NBR_WORKERS 10</p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span> <span style="color:#666666">*</span><br>
<span style="color:#0000FF">worker_task</span>(<span style="color:#B00040">void</span> <span style="color:#666666">*</span>args)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zmq_ctx_new();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>worker <span style="color:#666666">=</span> zmq_socket(context, ZMQ_DEALER);<br>
<span style="color:#BC7A00"><br>
#if (defined (WIN32))</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_set_id(worker, (<span style="color:#B00040">intptr_t</span>)args);<br>
<span style="color:#BC7A00">#else</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_set_id(worker);<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Set a printable identity</em></span><br>
<span style="color:#BC7A00">#endif</span></p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zmq_connect (worker, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5671"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> total <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Tell the broker we're ready for work</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>s_sendmore(worker, <span style="color:#BA2121">""</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>s_send(worker, <span style="color:#BA2121">"Hi Boss"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Get workload from broker, until finished</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free(s_recv(worker));<tt><span style="white-space: pre-wrap;">     </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Envelope delimiter</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>workload <span style="color:#666666">=</span> s_recv(worker);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> finished <span style="color:#666666">=</span> (strcmp(workload, <span style="color:#BA2121">"Fired!"</span>) <span style="color:#666666">==</span> <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free(workload);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (finished) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf(<span style="color:#BA2121">"Completed: %d tasks</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, total);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>total<span style="color:#666666">++</span>;</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Do some random work</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>s_sleep(randof(<span style="color:#666666">500</span>) <span style="color:#666666">+</span> <span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close(worker);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_ctx_destroy(context);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#008000">NULL</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>While this example runs in a single process, that is just to make<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>it easier to start and stop the example. Each thread has its own<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>context and conceptually acts as a separate process.</span></span></p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span>(<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zmq_ctx_new();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>broker <span style="color:#666666">=</span> zmq_socket(context, ZMQ_ROUTER);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zmq_bind(broker, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5671"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>srandom((<span style="color:#B00040">unsigned</span>)time(<span style="color:#008000">NULL</span>));</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> worker_nbr;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (worker_nbr <span style="color:#666666">=</span> <span style="color:#666666">0</span>; worker_nbr <span style="color:#666666">&lt;</span> NBR_WORKERS; worker_nbr<span style="color:#666666">++</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>pthread_t worker;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>pthread_create(<span style="color:#666666">&amp;</span>worker, <span style="color:#008000">NULL</span>, worker_task, (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>)(<span style="color:#B00040">intptr_t</span>)worker_nbr);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Run for five seconds and then tell workers to end</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int64_t</span> end_time <span style="color:#666666">=</span> s_clock() <span style="color:#666666">+</span> <span style="color:#666666">5000</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> workers_fired <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Next message gives us least recently used worker</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>identity <span style="color:#666666">=</span> s_recv(broker);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>s_sendmore(broker, identity);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free(identity);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free(s_recv(broker));<tt><span style="white-space: pre-wrap;">     </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Envelope delimiter</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free(s_recv(broker));<tt><span style="white-space: pre-wrap;">     </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Response from worker</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>s_sendmore(broker, <span style="color:#BA2121">""</span>);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Encourage workers until it's time to fire them</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (s_clock() <span style="color:#666666">&lt;</span> end_time)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>s_send(broker, <span style="color:#BA2121">"Work harder"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>s_send(broker, <span style="color:#BA2121">"Fired!"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">++</span>workers_fired <span style="color:#666666">==</span> NBR_WORKERS)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close(broker);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_ctx_destroy(context);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:rtdealer" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:rtdealer" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/clj:rtdealer" target="_blank">Clojure</a> | <a href="http://zguide.zeromq.org/lisp:rtdealer" target="_blank">CL</a> | <a href="http://zguide.zeromq.org/dpr:rtdealer" target="_blank">Delphi</a> | <a href="http://zguide.zeromq.org/es:rtdealer" target="_blank">Erlang</a> | <a href="http://zguide.zeromq.org/fsx:rtdealer" target="_blank">F#</a> | <a href="http://zguide.zeromq.org/go:rtdealer" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:rtdealer" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:rtdealer" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:rtdealer" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:rtdealer" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/js:rtdealer" target="_blank">Node.js</a> | <a href="http://zguide.zeromq.org/pl:rtdealer" target="_blank">Perl</a> | <a href="http://zguide.zeromq.org/php:rtdealer" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:rtdealer" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rb:rtdealer" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/scala:rtdealer" target="_blank">Scala</a> | <a href="http://zguide.zeromq.org/tcl:rtdealer" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | Felix | Objective-C | ooc | Q | Racket</a></span>
<p>The code is almost identical except that the worker uses a DEALER socket, and reads and writes that empty frame before the data frame. This is the approach I use when I want to keep compatibility with REQ workers.</p>
<p>However, remember the reason for that empty delimiter frame: it's to allow multihop extended requests that terminate in a REP socket, which uses that delimiter to split off the reply envelope so it can hand the data frames to its application.</p>
<p>If we never need to pass the message along to a REP socket, we can simply drop the empty delimiter frame at both sides, which makes things simpler. This is usually the design I use for pure DEALER to ROUTER protocols.</p>
<p><a name="A-Load-Balancing-Message-Broker"></a><a name="header-73"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc72"><span><a href="http://zguide.zeromq.org/page:all#A-Load-Balancing-Message-Broker">A Load Balancing Message Broker</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-72">prev</a> <a href="http://zguide.zeromq.org/page:all#header-74">next</a></td>
</tr>
</tbody></table>
<p>The previous example is half-complete. It can manage a set of workers with dummy requests and replies, but it has no way to talk to clients. If we add a second <em>frontend</em> ROUTER socket that accepts client requests, and turn our example into a proxy that can switch messages from frontend to backend, we get a useful and reusable tiny load balancing message broker.</p>
<p><strong>Figure 32 - Load Balancing Broker</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig32.png" alt="fig32.png" class="image"></div>
<p>This broker does the following:</p>
<ul>
<li>Accepts connections from a set of clients.</li>
<li>Accepts connections from a set of workers.</li>
<li>Accepts requests from clients and holds these in a single queue.</li>
<li>Sends these requests to workers using the load balancing pattern.</li>
<li>Receives replies back from workers.</li>
<li>Sends these replies back to the original requesting client.</li>
</ul>
<p>The broker code is fairly long, but worth understanding:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">lbbroker:&nbsp;Load&nbsp;balancing&nbsp;broker&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">lbbroker:&nbsp;Load&nbsp;balancing&nbsp;broker&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Load-balancing broker<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Clients and workers are shown here in-process</span></p>
<p>#include "zhelpers.h"<br>
#include &lt;pthread.h&gt;<br>
#define NBR_CLIENTS 10<br>
#define NBR_WORKERS 3</p>
<p><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Dequeue operation for queue implemented as array of anything<br>
#define DEQUEUE(q) memmove (&amp;(q)<span style="white-space: pre-wrap;">[</span>0<span style="white-space: pre-wrap;">]</span>, &amp;(q)<span style="white-space: pre-wrap;">[</span>1<span style="white-space: pre-wrap;">]</span>, sizeof (q) - sizeof (q <span style="white-space: pre-wrap;">[</span>0<span style="white-space: pre-wrap;">]</span>))</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Basic request-reply client using REQ socket<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Because s_send and s_recv can't handle 0MQ binary identities, we<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>set a printable text identity to allow routing.<br>
<span style="white-space: pre-wrap;">//</span></span></span><br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span> <span style="color:#666666">*</span><br>
<span style="color:#0000FF">client_task</span>(<span style="color:#B00040">void</span> <span style="color:#666666">*</span>args)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zmq_ctx_new();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>client <span style="color:#666666">=</span> zmq_socket(context, ZMQ_REQ);<br>
<span style="color:#BC7A00"><br>
#if (defined (WIN32))</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_set_id(client, (<span style="color:#B00040">intptr_t</span>)args);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_connect(client, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5672"</span>); <span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span> frontend</em></span><br>
<span style="color:#BC7A00">#else</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_set_id(client); <span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span> Set a printable identity</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_connect(client, <span style="color:#BA2121">"ipc:<span style="white-space: pre-wrap;">//</span>frontend.ipc"</span>);<br>
<span style="color:#BC7A00">#endif</span></p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send request, get reply</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_send(client, <span style="color:#BA2121">"HELLO"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>reply <span style="color:#666666">=</span> s_recv(client);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf(<span style="color:#BA2121">"Client: %s</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, reply);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>free(reply);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close(client);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_ctx_destroy(context);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#008000">NULL</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>While this example runs in a single process, that is just to make<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>it easier to start and stop the example. Each thread has its own<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>context and conceptually acts as a separate process.<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This is the worker task, using a REQ socket to do load-balancing.<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Because s_send and s_recv can't handle 0MQ binary identities, we<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>set a printable text identity to allow routing.</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span> <span style="color:#666666">*</span><br>
<span style="color:#0000FF">worker_task</span>(<span style="color:#B00040">void</span> <span style="color:#666666">*</span>args)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zmq_ctx_new();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>worker <span style="color:#666666">=</span> zmq_socket(context, ZMQ_REQ);<br>
<span style="color:#BC7A00"><br>
#if (defined (WIN32))</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_set_id(worker, (<span style="color:#B00040">intptr_t</span>)args);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_connect(worker, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5673"</span>); <span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span> backend</em></span><br>
<span style="color:#BC7A00">#else</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_set_id(worker);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_connect(worker, <span style="color:#BA2121">"ipc:<span style="white-space: pre-wrap;">//</span>backend.ipc"</span>);<br>
<span style="color:#BC7A00">#endif</span></p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Tell broker we're ready for work</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_send(worker, <span style="color:#BA2121">"READY"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Read and save all frames until we get an empty frame</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>In this example there is only 1, but there could be more</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>identity <span style="color:#666666">=</span> s_recv(worker);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>empty <span style="color:#666666">=</span> s_recv(worker);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>assert(<span style="color:#666666">*</span>empty <span style="color:#666666">==</span> <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free(empty);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Get request, send reply</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>request <span style="color:#666666">=</span> s_recv(worker);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf(<span style="color:#BA2121">"Worker: %s</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, request);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free(request);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt>s_sendmore(worker, identity);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>s_sendmore(worker, <span style="color:#BA2121">""</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>s_send(worker, <span style="color:#BA2121">"OK"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free(identity);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close(worker);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_ctx_destroy(context);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#008000">NULL</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This is the main task. It starts the clients and workers, and then<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>routes requests between the two layers. Workers signal READY when<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>they start; after that we treat them as ready when they reply with<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>a response back to a client. The load-balancing data structure is<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>just a queue of next available workers.</span></span></p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span>(<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Prepare our context and sockets</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zmq_ctx_new();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>frontend <span style="color:#666666">=</span> zmq_socket(context, ZMQ_ROUTER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>backend <span style="color:#666666">=</span> zmq_socket(context, ZMQ_ROUTER);<br>
<span style="color:#BC7A00"><br>
#if (defined (WIN32))</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_bind(frontend, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5672"</span>); <span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span> frontend</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_bind(backend, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5673"</span>); <span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span> backend</em></span><br>
<span style="color:#BC7A00">#else</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_bind(frontend, <span style="color:#BA2121">"ipc:<span style="white-space: pre-wrap;">//</span>frontend.ipc"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_bind(backend, <span style="color:#BA2121">"ipc:<span style="white-space: pre-wrap;">//</span>backend.ipc"</span>);<br>
<span style="color:#BC7A00">#endif</span></p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> client_nbr;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (client_nbr <span style="color:#666666">=</span> <span style="color:#666666">0</span>; client_nbr <span style="color:#666666">&lt;</span> NBR_CLIENTS; client_nbr<span style="color:#666666">++</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>pthread_t client;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>pthread_create(<span style="color:#666666">&amp;</span>client, <span style="color:#008000">NULL</span>, client_task, (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>)(<span style="color:#B00040">intptr_t</span>)client_nbr);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> worker_nbr;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (worker_nbr <span style="color:#666666">=</span> <span style="color:#666666">0</span>; worker_nbr <span style="color:#666666">&lt;</span> NBR_WORKERS; worker_nbr<span style="color:#666666">++</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>pthread_t worker;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>pthread_create(<span style="color:#666666">&amp;</span>worker, <span style="color:#008000">NULL</span>, worker_task, (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>)(<span style="color:#B00040">intptr_t</span>)worker_nbr);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Here is the main loop for the least-recently-used queue. It has two</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>sockets; a frontend for clients and a backend for workers. It polls</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>the backend in all cases, and polls the frontend only when there are</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>one or more workers ready. This is a neat way to use 0MQ's own queues</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>to hold messages we're not ready to process yet. When we get a client</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>reply, we pop the next available worker and send the request to it,</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>including the originating client identity. When a worker replies, we</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>requeue that worker and forward the reply to the original client</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>using the reply envelope.</em></span></p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Queue of available workers</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> available_workers <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>worker_queue<span style="white-space: pre-wrap;">[</span><span style="color:#666666">10</span><span style="white-space: pre-wrap;">]</span>;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_pollitem_t items<span style="white-space: pre-wrap;">[]</span> <span style="color:#666666">=</span> {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>{ backend, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> },<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>{ frontend, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> }<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Poll frontend only if we have available workers</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> rc <span style="color:#666666">=</span> zmq_poll(items, available_workers <span style="color:#666666">?</span> <span style="color:#666666">2</span> <span style="color:#666666">:</span> <span style="color:#666666">1</span>, <span style="color:#666666">-</span><span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (rc <span style="color:#666666">==</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span></p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Handle worker activity on backend</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items<span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Queue worker identity for load-balancing</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>worker_id <span style="color:#666666">=</span> s_recv(backend);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>assert(available_workers <span style="color:#666666">&lt;</span> NBR_WORKERS);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>worker_queue<span style="white-space: pre-wrap;">[</span>available_workers<span style="color:#666666">++</span><span style="white-space: pre-wrap;">]</span> <span style="color:#666666">=</span> worker_id;</p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Second frame is empty</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>empty <span style="color:#666666">=</span> s_recv(backend);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>assert(empty<span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span> <span style="color:#666666">==</span> <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>free(empty);</p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Third frame is READY or else a client reply identity</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>client_id <span style="color:#666666">=</span> s_recv(backend);</p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If client reply, send rest back to frontend</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (strcmp(client_id, <span style="color:#BA2121">"READY"</span>) <span style="color:#666666">!=</span> <span style="color:#666666">0</span>) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>empty <span style="color:#666666">=</span> s_recv(backend);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>assert(empty<span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span> <span style="color:#666666">==</span> <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>free(empty);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>reply <span style="color:#666666">=</span> s_recv(backend);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>s_sendmore(frontend, client_id);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>s_sendmore(frontend, <span style="color:#BA2121">""</span>);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>s_send(frontend, reply);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>free(reply);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666"><span style="white-space: pre-wrap;">--</span></span>client_nbr <span style="color:#666666">==</span> <span style="color:#666666">0</span>)<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">      </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Exit after N messages</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>free(client_id);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Here is how we handle a client request:</em></span></p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items<span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Now get next client request, route to last-used worker</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Client request is <span style="white-space: pre-wrap;">[</span>identity<span style="white-space: pre-wrap;">][</span>empty<span style="white-space: pre-wrap;">][</span>request<span style="white-space: pre-wrap;">]</span></span></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>client_id <span style="color:#666666">=</span> s_recv(frontend);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>empty <span style="color:#666666">=</span> s_recv(frontend);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>assert(empty<span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span> <span style="color:#666666">==</span> <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>free(empty);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>request <span style="color:#666666">=</span> s_recv(frontend);</p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt>s_sendmore(backend, worker_queue<span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>s_sendmore(backend, <span style="color:#BA2121">""</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>s_sendmore(backend, client_id);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>s_sendmore(backend, <span style="color:#BA2121">""</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>s_send(backend, request);</p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt>free(client_id);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>free(request);</p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Dequeue and drop the next worker identity</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>free(worker_queue<span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>DEQUEUE(worker_queue);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>available_workers<span style="color:#666666"><span style="white-space: pre-wrap;">--</span></span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close(frontend);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close(backend);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_ctx_destroy(context);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:lbbroker" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:lbbroker" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/clj:lbbroker" target="_blank">Clojure</a> | <a href="http://zguide.zeromq.org/lisp:lbbroker" target="_blank">CL</a> | <a href="http://zguide.zeromq.org/dpr:lbbroker" target="_blank">Delphi</a> | <a href="http://zguide.zeromq.org/es:lbbroker" target="_blank">Erlang</a> | <a href="http://zguide.zeromq.org/fsx:lbbroker" target="_blank">F#</a> | <a href="http://zguide.zeromq.org/go:lbbroker" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:lbbroker" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:lbbroker" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:lbbroker" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:lbbroker" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/js:lbbroker" target="_blank">Node.js</a> | <a href="http://zguide.zeromq.org/pl:lbbroker" target="_blank">Perl</a> | <a href="http://zguide.zeromq.org/php:lbbroker" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:lbbroker" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rb:lbbroker" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/scala:lbbroker" target="_blank">Scala</a> | <a href="http://zguide.zeromq.org/tcl:lbbroker" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | Felix | Objective-C | ooc | Q | Racket</a></span>
<p>The difficult part of this program is (a) the envelopes that each socket reads and writes, and (b) the load balancing algorithm. We'll take these in turn, starting with the message envelope formats.</p>
<p>Let's walk through a full request-reply chain from client to worker and back. In this code we set the identity of client and worker sockets to make it easier to trace the message frames. In reality, we'd allow the ROUTER sockets to invent identities for connections. Let's assume the client's identity is "CLIENT" and the worker's identity is "WORKER". The client application sends a single frame containing "Hello".</p>
<p><strong>Figure 33 - Message that Client Sends</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig33.png" alt="fig33.png" class="image"></div>
<p>Because the REQ socket adds its empty delimiter frame and the ROUTER socket adds its connection identity, the proxy reads off the frontend ROUTER socket the client address, empty delimiter frame, and the data part.</p>
<p><strong>Figure 34 - Message Coming in on Frontend</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig34.png" alt="fig34.png" class="image"></div>
<p>The broker sends this to the worker, prefixed by the address of the chosen worker, plus an additional empty part to keep the REQ at the other end happy.</p>
<p><strong>Figure 35 - Message Sent to Backend</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig35.png" alt="fig35.png" class="image"></div>
<p>This complex envelope stack gets chewed up first by the backend ROUTER socket, which removes the first frame. Then the REQ socket in the worker removes the empty part, and provides the rest to the worker application.</p>
<p><strong>Figure 36 - Message Delivered to Worker</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig36.png" alt="fig36.png" class="image"></div>
<p>The worker has to save the envelope (which is all the parts up to and including the empty message frame) and then it can do what's needed with the data part. Note that a REP socket would do this automatically, but we're using the REQ-ROUTER pattern so that we can get proper load balancing.</p>
<p>On the return path, the messages are the same as when they come in, i.e., the backend socket gives the broker a message in five parts, and the broker sends the frontend socket a message in three parts, and the client gets a message in one part.</p>
<p>Now let's look at the load balancing algorithm. It requires that both clients and workers use REQ sockets, and that workers correctly store and replay the envelope on messages they get. The algorithm is:</p>
<ul>
<li>Create a pollset that always polls the backend, and polls the frontend only if there are one or more workers available.</li>
</ul>
<ul>
<li>Poll for activity with infinite timeout.</li>
</ul>
<ul>
<li>If there is activity on the backend, we either have a "ready" message or a reply for a client. In either case, we store the worker address (the first part) on our worker queue, and if the rest is a client reply, we send it back to that client via the frontend.</li>
</ul>
<ul>
<li>If there is activity on the frontend, we take the client request, pop the next worker (which is the last used), and send the request to the backend. This means sending the worker address, empty part, and then the three parts of the client request.</li>
</ul>
<p>You should now see that you can reuse and extend the load balancing algorithm with variations based on the information the worker provides in its initial "ready" message. For example, workers might start up and do a performance self test, then tell the broker how fast they are. The broker can then choose the fastest available worker rather than the oldest.</p>
<p><a name="A-High-Level-API-for-ZeroMQ"></a><a name="header-74"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc73"><span><a href="http://zguide.zeromq.org/page:all#A-High-Level-API-for-ZeroMQ">A High-Level API for ZeroMQ</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-73">prev</a> <a href="http://zguide.zeromq.org/page:all#header-75">next</a></td>
</tr>
</tbody></table>
<p>We're going to push request-reply onto the stack and open a different area, which is the ZeroMQ API itself. There's a reason for this detour: as we write more complex examples, the low-level ZeroMQ API starts to look increasingly clumsy. Look at the core of the worker thread from our load balancing broker:</p>
<div class="code">
<p><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Get one address frame and empty delimiter</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>address <span style="color:#666666">=</span> s_recv (worker);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>empty <span style="color:#666666">=</span> s_recv (worker);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (<span style="color:#666666">*</span>empty <span style="color:#666666">==</span> <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>free (empty);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Get request, send reply</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>request <span style="color:#666666">=</span> s_recv (worker);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"Worker: %s</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, request);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>free (request);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>s_sendmore (worker, address);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_sendmore (worker, <span style="color:#BA2121">""</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_send<tt><span style="white-space: pre-wrap;">     </span></tt>(worker, <span style="color:#BA2121">"OK"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>free (address);<br>
}</p>
</div>
<p>That code isn't even reusable because it can only handle one reply address in the envelope, and it already does some wrapping around the ZeroMQ API. If we used the <tt>libzmq</tt> simple message API this is what we'd have to write:</p>
<div class="code">
<p><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Get one address frame and empty delimiter</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> address <span style="white-space: pre-wrap;">[</span><span style="color:#666666">255</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> address_size <span style="color:#666666">=</span> zmq_recv (worker, address, <span style="color:#666666">255</span>, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (address_size <span style="color:#666666">==</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>break</strong></span>;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> empty <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> empty_size <span style="color:#666666">=</span> zmq_recv (worker, empty, <span style="color:#666666">1</span>, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_recv (worker, <span style="color:#666666">&amp;</span>empty, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (empty_size <span style="color:#666666">&lt;=</span> <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (empty_size <span style="color:#666666">==</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>break</strong></span>;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Get request, send reply</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> request <span style="white-space: pre-wrap;">[</span><span style="color:#666666">256</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> request_size <span style="color:#666666">=</span> zmq_recv (worker, request, <span style="color:#666666">255</span>, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (request_size <span style="color:#666666">==</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#008000">NULL</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>request <span style="white-space: pre-wrap;">[</span>request_size<span style="white-space: pre-wrap;">]</span> <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"Worker: %s</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, request);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_send (worker, address, address_size, ZMQ_SNDMORE);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_send (worker, empty, <span style="color:#666666">0</span>, ZMQ_SNDMORE);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_send (worker, <span style="color:#BA2121">"OK"</span>, <span style="color:#666666">2</span>, <span style="color:#666666">0</span>);<br>
}</p>
</div>
<p>And when code is too long to write quickly, it's also too long to understand. Up until now, I've stuck to the native API because, as ZeroMQ users, we need to know that intimately. But when it gets in our way, we have to treat it as a problem to solve.</p>
<p>We can't of course just change the ZeroMQ API, which is a documented public contract on which thousands of people agree and depend. Instead, we construct a higher-level API on top based on our experience so far, and most specifically, our experience from writing more complex request-reply patterns.</p>
<p>What we want is an API that lets us receive and send an entire message in one shot, including the reply envelope with any number of reply addresses. One that lets us do what we want with the absolute least lines of code.</p>
<p>Making a good message API is fairly difficult. We have a problem of terminology: ZeroMQ uses "message" to describe both multipart messages, and individual message frames. We have a problem of expectations: sometimes it's natural to see message content as printable string data, sometimes as binary blobs. And we have technical challenges, especially if we want to avoid copying data around too much.</p>
<p>The challenge of making a good API affects all languages, though my specific use case is C. Whatever language you use, think about how you could contribute to your language binding to make it as good (or better) than the C binding I'm going to describe.</p>
<p><a name="Features-of-a-Higher-Level-API"></a><a name="header-75"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc74"><span><a href="http://zguide.zeromq.org/page:all#Features-of-a-Higher-Level-API">Features of a Higher-Level API</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-74">prev</a> <a href="http://zguide.zeromq.org/page:all#header-76">next</a></td>
</tr>
</tbody></table>
<p>My solution is to use three fairly natural and obvious concepts: <em>string</em> (already the basis for our <tt>s_send</tt> and <tt>s_recv</tt>) helpers, <em>frame</em> (a message frame), and <em>message</em> (a list of one or more frames). Here is the worker code, rewritten onto an API using these concepts:</p>
<div class="code">
<p><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_recv (worker);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zframe_reset (zmsg_last (msg), <span style="color:#BA2121">"OK"</span>, <span style="color:#666666">2</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>msg, worker);<br>
}</p>
</div>
<p>Cutting the amount of code we need to read and write complex messages is great: the results are easy to read and understand. Let's continue this process for other aspects of working with ZeroMQ. Here's a wish list of things I'd like in a higher-level API, based on my experience with ZeroMQ so far:</p>
<ul>
<li><em>Automatic handling of sockets.</em> I find it cumbersome to have to close sockets manually, and to have to explicitly define the linger timeout in some (but not all) cases. It'd be great to have a way to close sockets automatically when I close the context.</li>
</ul>
<ul>
<li><em>Portable thread management.</em> Every nontrivial ZeroMQ application uses threads, but POSIX threads aren't portable. So a decent high-level API should hide this under a portable layer.</li>
</ul>
<ul>
<li><em>Piping from parent to child threads.</em> It's a recurrent problem: how to signal between parent and child threads. Our API should provide a ZeroMQ message pipe (using PAIR sockets and <tt>inproc</tt> automatically.</li>
</ul>
<ul>
<li><em>Portable clocks.</em> Even getting the time to a millisecond resolution, or sleeping for some milliseconds, is not portable. Realistic ZeroMQ applications need portable clocks, so our API should provide them.</li>
</ul>
<ul>
<li><em>A reactor to replace <tt><a href="http://api.zeromq.org/3-2:zmq_poll">zmq_poll()</a></tt>.</em> The poll loop is simple, but clumsy. Writing a lot of these, we end up doing the same work over and over: calculating timers, and calling code when sockets are ready. A simple reactor with socket readers and timers would save a lot of repeated work.</li>
</ul>
<ul>
<li><em>Proper handling of Ctrl-C.</em> We already saw how to catch an interrupt. It would be useful if this happened in all applications.</li>
</ul>
<p><a name="The-CZMQ-High-Level-API"></a><a name="header-76"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc75"><span><a href="http://zguide.zeromq.org/page:all#The-CZMQ-High-Level-API">The CZMQ High-Level API</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-75">prev</a> <a href="http://zguide.zeromq.org/page:all#header-77">next</a></td>
</tr>
</tbody></table>
<p>Turning this wish list into reality for the C language gives us <a href="http://zero.mq/c">CZMQ</a>, a ZeroMQ language binding for C. This high-level binding, in fact, developed out of earlier versions of the examples. It combines nicer semantics for working with ZeroMQ with some portability layers, and (importantly for C, but less for other languages) containers like hashes and lists. CZMQ also uses an elegant object model that leads to frankly lovely code.</p>
<p>Here is the load balancing broker rewritten to use a higher-level API (CZMQ for the C case):</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">lbbroker2:&nbsp;Load&nbsp;balancing&nbsp;broker&nbsp;using&nbsp;high-level&nbsp;API&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">lbbroker2:&nbsp;Load&nbsp;balancing&nbsp;broker&nbsp;using&nbsp;high-level&nbsp;API&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Load-balancing broker<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Demonstrates use of the CZMQ API</span></span></p>
<p><span style="color:#BC7A00">#include "czmq.h"</span></p>
<p><span style="color:#BC7A00">#define NBR_CLIENTS 10<br>
#define NBR_WORKERS 3<br>
#define WORKER_READY<tt><span style="white-space: pre-wrap;">   </span></tt>"READY"<tt><span style="white-space: pre-wrap;">      </span></tt></span><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Signals worker is ready</em></span></p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Basic request-reply client using REQ socket<br>
<span style="white-space: pre-wrap;">//</span></span></span><br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span> <span style="color:#666666">*</span><br>
<span style="color:#0000FF">client_task</span>(<span style="color:#B00040">void</span> <span style="color:#666666">*</span>args)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">zctx_t</span> <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>client <span style="color:#666666">=</span> zsocket_new(ctx, ZMQ_REQ);</p>
<p><span style="color:#BC7A00">#if (defined (WIN32))</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect(client, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5672"</span>); <span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span> frontend</em></span><br>
<span style="color:#BC7A00">#else</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect(client, <span style="color:#BA2121">"ipc:<span style="white-space: pre-wrap;">//</span>frontend.ipc"</span>);<br>
<span style="color:#BC7A00">#endif</span></p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send request, get reply</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zstr_send(client, <span style="color:#BA2121">"HELLO"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>reply <span style="color:#666666">=</span> zstr_recv(client);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (reply) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf(<span style="color:#BA2121">"Client: %s</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, reply);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free(reply);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt></p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy(<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#008000">NULL</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Worker using REQ socket to do load-balancing<br>
<span style="white-space: pre-wrap;">//</span></span></span><br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span> <span style="color:#666666">*</span><br>
<span style="color:#0000FF">worker_task</span>(<span style="color:#B00040">void</span> <span style="color:#666666">*</span>args)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">zctx_t</span> <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>worker <span style="color:#666666">=</span> zsocket_new(ctx, ZMQ_REQ);</p>
<p><span style="color:#BC7A00">#if (defined (WIN32))</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect(worker, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5673"</span>); <span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span> backend</em></span><br>
<span style="color:#BC7A00">#else</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect(worker, <span style="color:#BA2121">"ipc:<span style="white-space: pre-wrap;">//</span>backend.ipc"</span>);<br>
<span style="color:#BC7A00">#endif</span></p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Tell broker we're ready for work</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">zframe_t</span> <span style="color:#666666">*</span>frame <span style="color:#666666">=</span> zframe_new(WORKER_READY, strlen(WORKER_READY));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zframe_send(<span style="color:#666666">&amp;</span>frame, worker, <span style="color:#666666">0</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Process messages as they arrive</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">zmsg_t</span> <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_recv(worker);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>msg)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_print(zmsg_last(msg), <span style="color:#BA2121">"Worker: "</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_reset(zmsg_last(msg), <span style="color:#BA2121">"OK"</span>, <span style="color:#666666">2</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_send(<span style="color:#666666">&amp;</span>msg, worker);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy(<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#008000">NULL</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Now we come to the main task. This has the identical functionality to<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>the previous <tt>lbbroker</tt> broker example, but uses CZMQ to start child<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>threads, to hold the list of workers, and to read and send messages:</span></span></p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span>(<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">zctx_t</span> <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>frontend <span style="color:#666666">=</span> zsocket_new(ctx, ZMQ_ROUTER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>backend <span style="color:#666666">=</span> zsocket_new(ctx, ZMQ_ROUTER);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span> IPC doesn't yet work on MS Windows.</em></span><br>
<span style="color:#BC7A00">#if (defined (WIN32))</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind(frontend, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5672"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind(backend, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5673"</span>);<br>
<span style="color:#BC7A00">#else</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind(frontend, <span style="color:#BA2121">"ipc:<span style="white-space: pre-wrap;">//</span>frontend.ipc"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind(backend, <span style="color:#BA2121">"ipc:<span style="white-space: pre-wrap;">//</span>backend.ipc"</span>);<br>
<span style="color:#BC7A00">#endif</span></p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> client_nbr;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (client_nbr <span style="color:#666666">=</span> <span style="color:#666666">0</span>; client_nbr <span style="color:#666666">&lt;</span> NBR_CLIENTS; client_nbr<span style="color:#666666">++</span>)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zthread_new(client_task, <span style="color:#008000">NULL</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> worker_nbr;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (worker_nbr <span style="color:#666666">=</span> <span style="color:#666666">0</span>; worker_nbr <span style="color:#666666">&lt;</span> NBR_WORKERS; worker_nbr<span style="color:#666666">++</span>)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zthread_new(worker_task, <span style="color:#008000">NULL</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Queue of available workers</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">zlist_t</span> <span style="color:#666666">*</span>workers <span style="color:#666666">=</span> zlist_new();</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Here is the main loop for the load balancer. It works the same way</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>as the previous example, but is a lot shorter because CZMQ gives</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>us an API that does more with fewer calls:</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">zmq_pollitem_t</span> items<span style="white-space: pre-wrap;">[]</span> <span style="color:#666666">=</span> {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>{ backend, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> },<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>{ frontend, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> }<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Poll frontend only if we have available workers</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> rc <span style="color:#666666">=</span> zmq_poll(items, zlist_size(workers) <span style="color:#666666">?</span> <span style="color:#666666">2</span> <span style="color:#666666">:</span> <span style="color:#666666">1</span>, <span style="color:#666666">-</span><span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (rc <span style="color:#666666">==</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span></p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Handle worker activity on backend</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items<span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Use worker identity for load-balancing</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">zmsg_t</span> <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_recv(backend);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>msg)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span></p>
<p><span style="color:#BC7A00">#if 0</span><span style="color:#408080"><span style="font-style:italic"><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="white-space: pre-wrap;">//</span> zmsg_unwrap is DEPRECATED as over-engineered, poor style<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_t *identity = zmsg_unwrap(msg);</span></span><br>
<span style="color:#BC7A00">#else</span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">zframe_t</span> <span style="color:#666666">*</span>identity <span style="color:#666666">=</span> zmsg_pop(msg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">zframe_t</span> <span style="color:#666666">*</span>delimiter <span style="color:#666666">=</span> zmsg_pop(msg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_destroy(<span style="color:#666666">&amp;</span>delimiter);<br>
<span style="color:#BC7A00">#endif</span></p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt>zlist_append(workers, identity);</p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Forward message to client if it's not a READY</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">zframe_t</span> <span style="color:#666666">*</span>frame <span style="color:#666666">=</span> zmsg_first(msg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (memcmp(zframe_data(frame), WORKER_READY, strlen(WORKER_READY)) <span style="color:#666666">==</span> <span style="color:#666666">0</span>) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_destroy(<span style="color:#666666">&amp;</span>msg);<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt> <span style="color:#008000"><strong>else</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_send(<span style="color:#666666">&amp;</span>msg, frontend);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666"><span style="white-space: pre-wrap;">--</span></span>client_nbr <span style="color:#666666">==</span> <span style="color:#666666">0</span>)<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt><span style="color:#008000"><strong>break</strong></span>; <span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span> Exit after N messages</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items<span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Get client request, route to first available worker</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">zmsg_t</span> <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_recv(frontend);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (msg) {<br>
<span style="color:#BC7A00">#if 0</span><span style="color:#408080"><span style="font-style:italic"><br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="white-space: pre-wrap;">//</span> zmsg_wrap is DEPRECATED as unsafe<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_wrap(msg, (zframe_t *)zlist_pop(workers));</span></span><br>
<span style="color:#BC7A00">#else</span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_pushmem(msg, <span style="color:#008000">NULL</span>, <span style="color:#666666">0</span>); <span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span> delimiter</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_push(msg, (<span style="color:#B00040">zframe_t</span> <span style="color:#666666">*</span>)zlist_pop(workers));<br>
<span style="color:#BC7A00">#endif</span></p>
<p><tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_send(<span style="color:#666666">&amp;</span>msg, backend);<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>When we're done, clean up properly</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (zlist_size(workers)) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">zframe_t</span> <span style="color:#666666">*</span>frame <span style="color:#666666">=</span> (<span style="color:#B00040">zframe_t</span> <span style="color:#666666">*</span>)zlist_pop(workers);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_destroy(<span style="color:#666666">&amp;</span>frame);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zlist_destroy(<span style="color:#666666">&amp;</span>workers);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy(<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:lbbroker2" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/dpr:lbbroker2" target="_blank">Delphi</a> | <a href="http://zguide.zeromq.org/hx:lbbroker2" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:lbbroker2" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:lbbroker2" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/php:lbbroker2" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:lbbroker2" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/scala:lbbroker2" target="_blank">Scala</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C# | Clojure | CL | Erlang | F# | Felix | Go | Haskell | Node.js | Objective-C | ooc | Perl | Q | Racket | Ruby | Tcl</a></span>
<p>One thing CZMQ provides is clean interrupt handling. This means that Ctrl-C will cause any blocking ZeroMQ call to exit with a return code -1 and errno set to <tt>EINTR</tt>. The high-level recv methods will return NULL in such cases. So, you can cleanly exit a loop like this:</p>
<div class="code">
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Shows how to handle Ctrl-C</em></span></p>
<p><span style="color:#BC7A00">#include &lt;stdlib.h&gt;<br>
#include &lt;stdio.h&gt;<br>
#include &lt;signal.h&gt;<br>
#include &lt;unistd.h&gt;<br>
#include &lt;fcntl.h&gt;</span></p>
<p><span style="color:#BC7A00">#include &lt;zmq.h&gt;</span></p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Signal handling<br>
<span style="white-space: pre-wrap;">//</span><br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Create a self-pipe and call s_catch_signals(pipe's writefd) in your application<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>at startup, and then exit your main loop if your pipe contains any data.<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Works especially well with zmq_poll.</span></span></p>
<p><span style="color:#BC7A00">#define S_NOTIFY_MSG " "<br>
#define S_ERROR_MSG "Error while writing to self-pipe.\n"</span><br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">int</span> s_fd;<br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span> <span style="color:#0000FF">s_signal_handler</span> (<span style="color:#B00040">int</span> signal_value)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> rc <span style="color:#666666">=</span> write (s_fd, S_NOTIFY_MSG, <span style="color:#008000"><strong>sizeof</strong></span>(S_NOTIFY_MSG));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (rc <span style="color:#666666">!=</span> <span style="color:#008000"><strong>sizeof</strong></span>(S_NOTIFY_MSG)) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>write (STDOUT_FILENO, S_ERROR_MSG, <span style="color:#008000"><strong>sizeof</strong></span>(S_ERROR_MSG)<span style="color:#666666">-</span><span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>exit(<span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
}</p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span> <span style="color:#0000FF">s_catch_signals</span> (<span style="color:#B00040">int</span> fd)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_fd <span style="color:#666666">=</span> fd;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>struct</strong></span> sigaction action;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>action.sa_handler <span style="color:#666666">=</span> s_signal_handler;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Doesn't matter if SA_RESTART set because self-pipe will wake up zmq_poll</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>But setting to 0 will allow zmq_read to be interrupted.</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>action.sa_flags <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>sigemptyset (<span style="color:#666666">&amp;</span>action.sa_mask);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>sigaction (SIGINT, <span style="color:#666666">&amp;</span>action, <span style="color:#008000">NULL</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>sigaction (SIGTERM, <span style="color:#666666">&amp;</span>action, <span style="color:#008000">NULL</span>);<br>
}</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> rc;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zmq_ctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>socket <span style="color:#666666">=</span> zmq_socket (context, ZMQ_REP);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_bind (socket, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5555"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> pipefds<span style="white-space: pre-wrap;">[</span><span style="color:#666666">2</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>rc <span style="color:#666666">=</span> pipe(pipefds);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (rc <span style="color:#666666">!=</span> <span style="color:#666666">0</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>perror(<span style="color:#BA2121">"Creating self-pipe"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>exit(<span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (<span style="color:#B00040">int</span> i <span style="color:#666666">=</span> <span style="color:#666666">0</span>; i <span style="color:#666666">&lt;</span> <span style="color:#666666">2</span>; i<span style="color:#666666">++</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> flags <span style="color:#666666">=</span> fcntl(pipefds<span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>, F_GETFL, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (flags <span style="color:#666666">&lt;</span> <span style="color:#666666">0</span>) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>perror (<span style="color:#BA2121">"fcntl(F_GETFL)"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>exit(<span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>rc <span style="color:#666666">=</span> fcntl (pipefds<span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>, F_SETFL, flags <span style="color:#666666">|</span> O_NONBLOCK);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (rc <span style="color:#666666">!=</span> <span style="color:#666666">0</span>) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>perror (<span style="color:#BA2121">"fcntl(F_SETFL)"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>exit(<span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt></p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>s_catch_signals (pipefds<span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">zmq_pollitem_t</span> items <span style="white-space: pre-wrap;">[]</span> <span style="color:#666666">=</span> {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>{ <span style="color:#666666">0</span>, pipefds<span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> },<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>{ socket, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> }<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt>;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>rc <span style="color:#666666">=</span> zmq_poll (items, <span style="color:#666666">2</span>, <span style="color:#666666">-</span><span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (rc <span style="color:#666666">==</span> <span style="color:#666666">0</span>) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>continue</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt> <span style="color:#008000"><strong>else</strong></span> <span style="color:#008000"><strong>if</strong></span> (rc <span style="color:#666666">&lt;</span> <span style="color:#666666">0</span>) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (errno <span style="color:#666666">==</span> EINTR) { <span style="color:#008000"><strong>continue</strong></span>; }<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>perror(<span style="color:#BA2121">"zmq_poll"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>exit(<span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt></p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span> Signal pipe FD</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">char</span> buffer <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>read (pipefds<span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>, buffer, <span style="color:#666666">1</span>);<tt><span style="white-space: pre-wrap;">  </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span> clear notifying byte</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"W: interrupt received, killing server…</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt></p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span> Read socket</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">char</span> buffer <span style="white-space: pre-wrap;">[</span><span style="color:#666666">255</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span> Use non-blocking so we can continue to check self-pipe via zmq_poll</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>rc <span style="color:#666666">=</span> zmq_recv (socket, buffer, <span style="color:#666666">255</span>, ZMQ_NOBLOCK);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (rc <span style="color:#666666">&lt;</span> <span style="color:#666666">0</span>) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>if</strong></span> (errno <span style="color:#666666">==</span> EAGAIN) { <span style="color:#008000"><strong>continue</strong></span>; }<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>if</strong></span> (errno <span style="color:#666666">==</span> EINTR) { <span style="color:#008000"><strong>continue</strong></span>; }<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>perror(<span style="color:#BA2121">"recv"</span>);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>exit(<span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"W: recv</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span> Now send message back.</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span> …</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt></p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"W: cleaning up</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (socket);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_ctx_destroy (context);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
<p>Or, if you're calling <tt><a href="http://api.zeromq.org/3-2:zmq_poll">zmq_poll()</a></tt>, test on the return code:</p>
<div class="code">
<p><span style="color:#008000"><strong>if</strong></span> (zmq_poll (items, <span style="color:#666666">2</span>, <span style="color:#666666">1000</span> <span style="color:#666666">*</span> <span style="color:#666666">1000</span>) <span style="color:#666666">==</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>)<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span></p>
</div>
<p>The previous example still uses <tt><a href="http://api.zeromq.org/3-2:zmq_poll">zmq_poll()</a></tt>. So how about reactors? The CZMQ <tt>zloop</tt> reactor is simple but functional. It lets you:</p>
<ul>
<li>Set a reader on any socket, i.e., code that is called whenever the socket has input.</li>
<li>Cancel a reader on a socket.</li>
<li>Set a timer that goes off once or multiple times at specific intervals.</li>
<li>Cancel a timer.</li>
</ul>
<p><tt>zloop</tt> of course uses <tt><a href="http://api.zeromq.org/3-2:zmq_poll">zmq_poll()</a></tt> internally. It rebuilds its poll set each time you add or remove readers, and it calculates the poll timeout to match the next timer. Then, it calls the reader and timer handlers for each socket and timer that need attention.</p>
<p>When we use a reactor pattern, our code turns inside out. The main logic looks like this:</p>
<div class="code">
<p>zloop_t <span style="color:#666666">*</span>reactor <span style="color:#666666">=</span> zloop_new ();<br>
zloop_reader (reactor, self<span style="color:#666666">-&gt;</span>backend, s_handle_backend, self);<br>
zloop_start (reactor);<br>
zloop_destroy (<span style="color:#666666">&amp;</span>reactor);</p>
</div>
<p>The actual handling of messages sits inside dedicated functions or methods. You may not like the style—it's a matter of taste. What it does help with is mixing timers and socket activity. In the rest of this text, we'll use <tt><a href="http://api.zeromq.org/3-2:zmq_poll">zmq_poll()</a></tt> in simpler cases, and <tt>zloop</tt> in more complex examples.</p>
<p>Here is the load balancing broker rewritten once again, this time to use <tt>zloop</tt>:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">lbbroker3:&nbsp;Load&nbsp;balancing&nbsp;broker&nbsp;using&nbsp;zloop&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">lbbroker3:&nbsp;Load&nbsp;balancing&nbsp;broker&nbsp;using&nbsp;zloop&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Load-balancing broker<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Demonstrates use of the CZMQ API and reactor style<br>
<span style="white-space: pre-wrap;">//</span><br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The client and worker tasks are identical from the previous example.</span></p>
<p>#include "czmq.h"<br>
#define NBR_CLIENTS 10<br>
#define NBR_WORKERS 3<br>
#define WORKER_READY<tt><span style="white-space: pre-wrap;">   </span></tt>"\001"<tt><span style="white-space: pre-wrap;">      </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Signals worker is ready</em></span></p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Basic request-reply client using REQ socket<br>
<span style="white-space: pre-wrap;">//</span></span></span><br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span> <span style="color:#666666">*</span><br>
<span style="color:#0000FF">client_task</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>args)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>client <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_REQ);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect (client, <span style="color:#BA2121">"ipc:<span style="white-space: pre-wrap;">//</span>frontend.ipc"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send request, get reply</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zstr_send (client, <span style="color:#BA2121">"HELLO"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>reply <span style="color:#666666">=</span> zstr_recv (client);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>reply)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"Client: %s</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, reply);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (reply);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>sleep (<span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#008000">NULL</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Worker using REQ socket to do load-balancing<br>
<span style="white-space: pre-wrap;">//</span></span></span><br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span> <span style="color:#666666">*</span><br>
<span style="color:#0000FF">worker_task</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>args)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>worker <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_REQ);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect (worker, <span style="color:#BA2121">"ipc:<span style="white-space: pre-wrap;">//</span>backend.ipc"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Tell broker we're ready for work</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zframe_t <span style="color:#666666">*</span>frame <span style="color:#666666">=</span> zframe_new (WORKER_READY, <span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zframe_send (<span style="color:#666666">&amp;</span>frame, worker, <span style="color:#666666">0</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Process messages as they arrive</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_recv (worker);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>msg)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span>zframe_print (zmsg_last (msg), "Worker: ");</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_reset (zmsg_last (msg), <span style="color:#BA2121">"OK"</span>, <span style="color:#666666">2</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>msg, worker);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#008000">NULL</span>;<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Our load-balancer structure, passed to reactor handlers</em></span><br>
<span style="color:#008000"><strong>typedef</strong></span> <span style="color:#008000"><strong>struct</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>frontend;<tt><span style="white-space: pre-wrap;">             </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Listen to clients</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>backend;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Listen to workers</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zlist_t <span style="color:#666666">*</span>workers;<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>List of ready workers</em></span><br>
} lbbroker_t;</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>In the reactor design, each time a message arrives on a socket, the<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>reactor passes it to a handler function. We have two handlers; one<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>for the frontend, one for the backend:</span></span></p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Handle input from client, on frontend</em></span><br>
<span style="color:#B00040">int</span> <span style="color:#0000FF">s_handle_frontend</span> (zloop_t <span style="color:#666666">*</span>loop, zmq_pollitem_t <span style="color:#666666">*</span>poller, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>arg)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>lbbroker_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> (lbbroker_t <span style="color:#666666">*</span>) arg;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_recv (self<span style="color:#666666">-&gt;</span>frontend);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (msg) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_wrap (msg, (zframe_t <span style="color:#666666">*</span>) zlist_pop (self<span style="color:#666666">-&gt;</span>workers));<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>msg, self<span style="color:#666666">-&gt;</span>backend);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Cancel reader on frontend if we went from 1 to 0 workers</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (zlist_size (self<span style="color:#666666">-&gt;</span>workers) <span style="color:#666666">==</span> <span style="color:#666666">0</span>) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmq_pollitem_t poller <span style="color:#666666">=</span> { self<span style="color:#666666">-&gt;</span>frontend, <span style="color:#666666">0</span>, ZMQ_POLLIN };<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zloop_poller_end (loop, <span style="color:#666666">&amp;</span>poller);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Handle input from worker, on backend</em></span><br>
<span style="color:#B00040">int</span> <span style="color:#0000FF">s_handle_backend</span> (zloop_t <span style="color:#666666">*</span>loop, zmq_pollitem_t <span style="color:#666666">*</span>poller, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>arg)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Use worker identity for load-balancing</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>lbbroker_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> (lbbroker_t <span style="color:#666666">*</span>) arg;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_recv (self<span style="color:#666666">-&gt;</span>backend);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (msg) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_t <span style="color:#666666">*</span>identity <span style="color:#666666">=</span> zmsg_unwrap (msg);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zlist_append (self<span style="color:#666666">-&gt;</span>workers, identity);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Enable reader on frontend if we went from 0 to 1 workers</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (zlist_size (self<span style="color:#666666">-&gt;</span>workers) <span style="color:#666666">==</span> <span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmq_pollitem_t poller <span style="color:#666666">=</span> { self<span style="color:#666666">-&gt;</span>frontend, <span style="color:#666666">0</span>, ZMQ_POLLIN };<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zloop_poller (loop, <span style="color:#666666">&amp;</span>poller, s_handle_frontend, self);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Forward message to client if it's not a READY</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_t <span style="color:#666666">*</span>frame <span style="color:#666666">=</span> zmsg_first (msg);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (memcmp (zframe_data (frame), WORKER_READY, <span style="color:#666666">1</span>) <span style="color:#666666">==</span> <span style="color:#666666">0</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>msg);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>msg, self<span style="color:#666666">-&gt;</span>frontend);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>And the main task now sets up child tasks, then starts its reactor.<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If you press Ctrl-C, the reactor exits and the main task shuts down.<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Because the reactor is a CZMQ class, this example may not translate<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>into all languages equally well.</span></span></p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>lbbroker_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> (lbbroker_t <span style="color:#666666">*</span>) zmalloc (<span style="color:#008000"><strong>sizeof</strong></span> (lbbroker_t));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>frontend <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_ROUTER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>backend <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_ROUTER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (self<span style="color:#666666">-&gt;</span>frontend, <span style="color:#BA2121">"ipc:<span style="white-space: pre-wrap;">//</span>frontend.ipc"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (self<span style="color:#666666">-&gt;</span>backend, <span style="color:#BA2121">"ipc:<span style="white-space: pre-wrap;">//</span>backend.ipc"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> client_nbr;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (client_nbr <span style="color:#666666">=</span> <span style="color:#666666">0</span>; client_nbr <span style="color:#666666">&lt;</span> NBR_CLIENTS; client_nbr<span style="color:#666666">++</span>)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zthread_new (client_task, <span style="color:#008000">NULL</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> worker_nbr;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (worker_nbr <span style="color:#666666">=</span> <span style="color:#666666">0</span>; worker_nbr <span style="color:#666666">&lt;</span> NBR_WORKERS; worker_nbr<span style="color:#666666">++</span>)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zthread_new (worker_task, <span style="color:#008000">NULL</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Queue of available workers</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>workers <span style="color:#666666">=</span> zlist_new ();</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Prepare reactor and fire it up</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zloop_t <span style="color:#666666">*</span>reactor <span style="color:#666666">=</span> zloop_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_pollitem_t poller <span style="color:#666666">=</span> { self<span style="color:#666666">-&gt;</span>backend, <span style="color:#666666">0</span>, ZMQ_POLLIN };<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zloop_poller (reactor, <span style="color:#666666">&amp;</span>poller, s_handle_backend, self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zloop_start<tt><span style="white-space: pre-wrap;">  </span></tt>(reactor);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zloop_destroy (<span style="color:#666666">&amp;</span>reactor);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>When we're done, clean up properly</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (zlist_size (self<span style="color:#666666">-&gt;</span>workers)) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_t <span style="color:#666666">*</span>frame <span style="color:#666666">=</span> (zframe_t <span style="color:#666666">*</span>) zlist_pop (self<span style="color:#666666">-&gt;</span>workers);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_destroy (<span style="color:#666666">&amp;</span>frame);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zlist_destroy (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>workers);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>free (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/hx:lbbroker3" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:lbbroker3" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/py:lbbroker3" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | C# | Clojure | CL | Delphi | Erlang | F# | Felix | Go | Haskell | Lua | Node.js | Objective-C | ooc | Perl | PHP | Q | Racket | Ruby | Scala | Tcl</a></span>
<p>Getting applications to properly shut down when you send them Ctrl-C can be tricky. If you use the <tt>zctx</tt> class it'll automatically set up signal handling, but your code still has to cooperate. You must break any loop if <tt>zmq_poll</tt> returns -1 or if any of the <tt>zstr_recv</tt>, <tt>zframe_recv</tt>, or <tt>zmsg_recv</tt> methods return NULL. If you have nested loops, it can be useful to make the outer ones conditional on <tt>!zctx_interrupted</tt>.</p>
<p>If you're using child threads, they won't receive the interrupt. To tell them to shutdown, you can either:</p>
<ul>
<li>Destroy the context, if they are sharing the same context, in which case any blocking calls they are waiting on will end with ETERM.</li>
<li>Send them shutdown messages, if they are using their own contexts. For this you'll need some socket plumbing.</li>
</ul>
<p><a name="The-Asynchronous-Client-Server-Pattern"></a><a name="header-77"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc76"><span><a href="http://zguide.zeromq.org/page:all#The-Asynchronous-Client-Server-Pattern">The Asynchronous Client/Server Pattern</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-76">prev</a> <a href="http://zguide.zeromq.org/page:all#header-78">next</a></td>
</tr>
</tbody></table>
<p>In the ROUTER to DEALER example, we saw a 1-to-N use case where one server talks asynchronously to multiple workers. We can turn this upside down to get a very useful N-to-1 architecture where various clients talk to a single server, and do this asynchronously.</p>
<p><strong>Figure 37 - Asynchronous Client/Server</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig37.png" alt="fig37.png" class="image"></div>
<p>Here's how it works:</p>
<ul>
<li>Clients connect to the server and send requests.</li>
<li>For each request, the server sends 0 or more replies.</li>
<li>Clients can send multiple requests without waiting for a reply.</li>
<li>Servers can send multiple replies without waiting for new requests.</li>
</ul>
<p>Here's code that shows how this works:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">asyncsrv:&nbsp;Asynchronous&nbsp;client/server&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">asyncsrv:&nbsp;Asynchronous&nbsp;client/server&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Asynchronous client-to-server (DEALER to ROUTER)<br>
<span style="white-space: pre-wrap;">//</span><br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>While this example runs in a single process, that is to make<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>it easier to start and stop the example. Each task has its own<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>context and conceptually acts as a separate process.</span></p>
<p>#include "czmq.h"</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This is our client task<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>It connects to the server, and then sends a request once per second<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>It collects responses as they arrive, and it prints them out. We will<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>run several client tasks in parallel, each with a different random ID.</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span> <span style="color:#666666">*</span><br>
<span style="color:#0000FF">client_task</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>args)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>client <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_DEALER);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Set random identity to make tracing easier</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> identity <span style="white-space: pre-wrap;">[</span><span style="color:#666666">10</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>sprintf (identity, <span style="color:#BA2121">"%04X-%04X"</span>, randof (<span style="color:#666666">0x10000</span>), randof (<span style="color:#666666">0x10000</span>));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_set_identity (client, identity);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect (client, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5570"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zmq_pollitem_t items <span style="white-space: pre-wrap;">[]</span> <span style="color:#666666">=</span> { { client, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> } };<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> request_nbr <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Tick once per second, pulling in arriving messages</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> centitick;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>for</strong></span> (centitick <span style="color:#666666">=</span> <span style="color:#666666">0</span>; centitick <span style="color:#666666">&lt;</span> <span style="color:#666666">100</span>; centitick<span style="color:#666666">++</span>) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmq_poll (items, <span style="color:#666666">1</span>, <span style="color:#666666">10</span> <span style="color:#666666">*</span> ZMQ_POLL_MSEC);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_recv (client);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zframe_print (zmsg_last (msg), identity);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>msg);<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zstr_sendf (client, <span style="color:#BA2121">"request #%d"</span>, <span style="color:#666666">++</span>request_nbr);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#008000">NULL</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This is our server task.<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>It uses the multithreaded server model to deal requests out to a pool<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>of workers and route replies back to clients. One worker can handle<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>one request at a time but one client can talk to multiple workers at<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>once.</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span> server_worker (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>args, zctx_t <span style="color:#666666">*</span>ctx, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>pipe);</p>
<p><span style="color:#B00040">void</span> <span style="color:#666666">*</span><span style="color:#0000FF">server_task</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>args)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Frontend socket talks to clients over TCP</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>frontend <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_ROUTER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (frontend, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5570"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Backend socket talks to workers over inproc</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>backend <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_DEALER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (backend, <span style="color:#BA2121">"inproc:<span style="white-space: pre-wrap;">//</span>backend"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Launch pool of worker threads, precise number is not critical</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> thread_nbr;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (thread_nbr <span style="color:#666666">=</span> <span style="color:#666666">0</span>; thread_nbr <span style="color:#666666">&lt;</span> <span style="color:#666666">5</span>; thread_nbr<span style="color:#666666">++</span>)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zthread_fork (ctx, server_worker, <span style="color:#008000">NULL</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Connect backend to frontend via a proxy</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_proxy (frontend, backend, <span style="color:#008000">NULL</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#008000">NULL</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Each worker task works on one request at a time and sends a random number<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>of replies back, with random delays between replies:</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<span style="color:#0000FF">server_worker</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>args, zctx_t <span style="color:#666666">*</span>ctx, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>pipe)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>worker <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_DEALER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect (worker, <span style="color:#BA2121">"inproc:<span style="white-space: pre-wrap;">//</span>backend"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The DEALER socket gives us the reply envelope and message</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_recv (worker);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_t <span style="color:#666666">*</span>identity <span style="color:#666666">=</span> zmsg_pop (msg);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_t <span style="color:#666666">*</span>content <span style="color:#666666">=</span> zmsg_pop (msg);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>assert (content);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>msg);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send 0..4 replies back</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> reply, replies <span style="color:#666666">=</span> randof (<span style="color:#666666">5</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>for</strong></span> (reply <span style="color:#666666">=</span> <span style="color:#666666">0</span>; reply <span style="color:#666666">&lt;</span> replies; reply<span style="color:#666666">++</span>) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Sleep for some fraction of a second</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zclock_sleep (randof (<span style="color:#666666">1000</span>) <span style="color:#666666">+</span> <span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_send (<span style="color:#666666">&amp;</span>identity, worker, ZFRAME_REUSE <span style="color:#666666">+</span> ZFRAME_MORE);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_send (<span style="color:#666666">&amp;</span>content, worker, ZFRAME_REUSE);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_destroy (<span style="color:#666666">&amp;</span>identity);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_destroy (<span style="color:#666666">&amp;</span>content);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The main thread simply starts several clients and a server, and then<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>waits for the server to finish.</span></span></p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zthread_new (client_task, <span style="color:#008000">NULL</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zthread_new (client_task, <span style="color:#008000">NULL</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zthread_new (client_task, <span style="color:#008000">NULL</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zthread_new (server_task, <span style="color:#008000">NULL</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zclock_sleep (<span style="color:#666666">5</span> <span style="color:#666666">*</span> <span style="color:#666666">1000</span>);<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Run for 5 seconds then quit</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:asyncsrv" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:asyncsrv" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/clj:asyncsrv" target="_blank">Clojure</a> | <a href="http://zguide.zeromq.org/dpr:asyncsrv" target="_blank">Delphi</a> | <a href="http://zguide.zeromq.org/es:asyncsrv" target="_blank">Erlang</a> | <a href="http://zguide.zeromq.org/fsx:asyncsrv" target="_blank">F#</a> | <a href="http://zguide.zeromq.org/go:asyncsrv" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:asyncsrv" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:asyncsrv" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:asyncsrv" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:asyncsrv" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/js:asyncsrv" target="_blank">Node.js</a> | <a href="http://zguide.zeromq.org/php:asyncsrv" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:asyncsrv" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rb:asyncsrv" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/scala:asyncsrv" target="_blank">Scala</a> | <a href="http://zguide.zeromq.org/tcl:asyncsrv" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | CL | Felix | Objective-C | ooc | Perl | Q | Racket</a></span>
<p>The example runs in one process, with multiple threads simulating a real multiprocess architecture. When you run the example, you'll see three clients (each with a random ID), printing out the replies they get from the server. Look carefully and you'll see each client task gets 0 or more replies per request.</p>
<p>Some comments on this code:</p>
<ul>
<li>The clients send a request once per second, and get zero or more replies back. To make this work using <tt><a href="http://api.zeromq.org/3-2:zmq_poll">zmq_poll()</a></tt>, we can't simply poll with a 1-second timeout, or we'd end up sending a new request only one second <em>after we received the last reply</em>. So we poll at a high frequency (100 times at 1/100th of a second per poll), which is approximately accurate.</li>
</ul>
<ul>
<li>The server uses a pool of worker threads, each processing one request synchronously. It connects these to its frontend socket using an internal queue. It connects the frontend and backend sockets using a <tt><a href="http://api.zeromq.org/3-2:zmq_proxy">zmq_proxy()</a></tt> call.</li>
</ul>
<p><strong>Figure 38 - Detail of Asynchronous Server</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig38.png" alt="fig38.png" class="image"></div>
<p>Note that we're doing DEALER to ROUTER dialog between client and server, but internally between the server main thread and workers, we're doing DEALER to DEALER. If the workers were strictly synchronous, we'd use REP. However, because we want to send multiple replies, we need an async socket. We do <em>not</em> want to route replies, they always go to the single server thread that sent us the request.</p>
<p>Let's think about the routing envelope. The client sends a message consisting of a single frame. The server thread receives a two-frame message (original message prefixed by client identity). We send these two frames on to the worker, which treats it as a normal reply envelope, returns that to us as a two frame message. We then use the first frame as an identity to route the second frame back to the client as a reply.</p>
<p>It looks something like this:</p>
<div class="code">
<pre><code>     client          server       frontend       worker
   [ DEALER ]&lt;----&gt;[ ROUTER &lt;----&gt; DEALER &lt;----&gt; DEALER ]
             1 part         2 parts       2 parts</code>
</pre></div>
<p>Now for the sockets: we could use the load balancing ROUTER to DEALER pattern to talk to workers, but it's extra work. In this case, a DEALER to DEALER pattern is probably fine: the trade-off is lower latency for each request, but higher risk of unbalanced work distribution. Simplicity wins in this case.</p>
<p>When you build servers that maintain stateful conversations with clients, you will run into a classic problem. If the server keeps some state per client, and clients keep coming and going, eventually it will run out of resources. Even if the same clients keep connecting, if you're using default identities, each connection will look like a new one.</p>
<p>We cheat in the above example by keeping state only for a very short time (the time it takes a worker to process a request) and then throwing away the state. But that's not practical for many cases. To properly manage client state in a stateful asynchronous server, you have to:</p>
<ul>
<li>Do heartbeating from client to server. In our example, we send a request once per second, which can reliably be used as a heartbeat.</li>
</ul>
<ul>
<li>Store state using the client identity (whether generated or explicit) as key.</li>
</ul>
<ul>
<li>Detect a stopped heartbeat. If there's no request from a client within, say, two seconds, the server can detect this and destroy any state it's holding for that client.</li>
</ul>
<p><a name="Worked-Example-Inter-Broker-Routing"></a><a name="header-78"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc77"><span><a href="http://zguide.zeromq.org/page:all#Worked-Example-Inter-Broker-Routing">Worked Example: Inter-Broker Routing</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-77">prev</a> <a href="http://zguide.zeromq.org/page:all#header-79">next</a></td>
</tr>
</tbody></table>
<p>Let's take everything we've seen so far, and scale things up to a real application. We'll build this step-by-step over several iterations. Our best client calls us urgently and asks for a design of a large cloud computing facility. He has this vision of a cloud that spans many data centers, each a cluster of clients and workers, and that works together as a whole. Because we're smart enough to know that practice always beats theory, we propose to make a working simulation using ZeroMQ. Our client, eager to lock down the budget before his own boss changes his mind, and having read great things about ZeroMQ on Twitter, agrees.</p>
<p><a name="Establishing-the-Details"></a><a name="header-79"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc78"><span><a href="http://zguide.zeromq.org/page:all#Establishing-the-Details">Establishing the Details</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-78">prev</a> <a href="http://zguide.zeromq.org/page:all#header-80">next</a></td>
</tr>
</tbody></table>
<p>Several espressos later, we want to jump into writing code, but a little voice tells us to get more details before making a sensational solution to entirely the wrong problem. "What kind of work is the cloud doing?", we ask.</p>
<p>The client explains:</p>
<ul>
<li>Workers run on various kinds of hardware, but they are all able to handle any task. There are several hundred workers per cluster, and as many as a dozen clusters in total.</li>
</ul>
<ul>
<li>Clients create tasks for workers. Each task is an independent unit of work and all the client wants is to find an available worker, and send it the task, as soon as possible. There will be a lot of clients and they'll come and go arbitrarily.</li>
</ul>
<ul>
<li>The real difficulty is to be able to add and remove clusters at any time. A cluster can leave or join the cloud instantly, bringing all its workers and clients with it.</li>
</ul>
<ul>
<li>If there are no workers in their own cluster, clients' tasks will go off to other available workers in the cloud.</li>
</ul>
<ul>
<li>Clients send out one task at a time, waiting for a reply. If they don't get an answer within X seconds, they'll just send out the task again. This isn't our concern; the client API does it already.</li>
</ul>
<ul>
<li>Workers process one task at a time; they are very simple beasts. If they crash, they get restarted by whatever script started them.</li>
</ul>
<p>So we double-check to make sure that we understood this correctly:</p>
<ul>
<li>"There will be some kind of super-duper network interconnect between clusters, right?", we ask. The client says, "Yes, of course, we're not idiots."</li>
</ul>
<ul>
<li>"What kind of volumes are we talking about?", we ask. The client replies, "Up to a thousand clients per cluster, each doing at most ten requests per second. Requests are small, and replies are also small, no more than 1K bytes each."</li>
</ul>
<p>So we do a little calculation and see that this will work nicely over plain TCP. 2,500 clients x 10/second x 1,000 bytes x 2 directions = 50MB/sec or 400Mb/sec, not a problem for a 1Gb network.</p>
<p>It's a straightforward problem that requires no exotic hardware or protocols, just some clever routing algorithms and careful design. We start by designing one cluster (one data center) and then we figure out how to connect clusters together.</p>
<p><a name="Architecture-of-a-Single-Cluster"></a><a name="header-80"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc79"><span><a href="http://zguide.zeromq.org/page:all#Architecture-of-a-Single-Cluster">Architecture of a Single Cluster</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-79">prev</a> <a href="http://zguide.zeromq.org/page:all#header-81">next</a></td>
</tr>
</tbody></table>
<p>Workers and clients are synchronous. We want to use the load balancing pattern to route tasks to workers. Workers are all identical; our facility has no notion of different services. Workers are anonymous; clients never address them directly. We make no attempt here to provide guaranteed delivery, retry, and so on.</p>
<p>For reasons we already examined, clients and workers won't speak to each other directly. It makes it impossible to add or remove nodes dynamically. So our basic model consists of the request-reply message broker we saw earlier.</p>
<p><strong>Figure 39 - Cluster Architecture</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig39.png" alt="fig39.png" class="image"></div>
<p><a name="Scaling-to-Multiple-Clusters"></a><a name="header-81"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc80"><span><a href="http://zguide.zeromq.org/page:all#Scaling-to-Multiple-Clusters">Scaling to Multiple Clusters</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-80">prev</a> <a href="http://zguide.zeromq.org/page:all#header-82">next</a></td>
</tr>
</tbody></table>
<p>Now we scale this out to more than one cluster. Each cluster has a set of clients and workers, and a broker that joins these together.</p>
<p><strong>Figure 40 - Multiple Clusters</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig40.png" alt="fig40.png" class="image"></div>
<p>The question is: how do we get the clients of each cluster talking to the workers of the other cluster? There are a few possibilities, each with pros and cons:</p>
<ul>
<li>Clients could connect directly to both brokers. The advantage is that we don't need to modify brokers or workers. But clients get more complex and become aware of the overall topology. If we want to add a third or forth cluster, for example, all the clients are affected. In effect we have to move routing and failover logic into the clients and that's not nice.</li>
</ul>
<ul>
<li>Workers might connect directly to both brokers. But REQ workers can't do that, they can only reply to one broker. We might use REPs but REPs don't give us customizable broker-to-worker routing like load balancing does, only the built-in load balancing. That's a fail; if we want to distribute work to idle workers, we precisely need load balancing. One solution would be to use ROUTER sockets for the worker nodes. Let's label this "Idea #1".</li>
</ul>
<ul>
<li>Brokers could connect to each other. This looks neatest because it creates the fewest additional connections. We can't add clusters on the fly, but that is probably out of scope. Now clients and workers remain ignorant of the real network topology, and brokers tell each other when they have spare capacity. Let's label this "Idea #2".</li>
</ul>
<p>Let's explore Idea #1. In this model, we have workers connecting to both brokers and accepting jobs from either one.</p>
<p><strong>Figure 41 - Idea 1: Cross-connected Workers</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig41.png" alt="fig41.png" class="image"></div>
<p>It looks feasible. However, it doesn't provide what we wanted, which was that clients get local workers if possible and remote workers only if it's better than waiting. Also workers will signal "ready" to both brokers and can get two jobs at once, while other workers remain idle. It seems this design fails because again we're putting routing logic at the edges.</p>
<p>So, idea #2 then. We interconnect the brokers and don't touch the clients or workers, which are REQs like we're used to.</p>
<p><strong>Figure 42 - Idea 2: Brokers Talking to Each Other</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig42.png" alt="fig42.png" class="image"></div>
<p>This design is appealing because the problem is solved in one place, invisible to the rest of the world. Basically, brokers open secret channels to each other and whisper, like camel traders, "Hey, I've got some spare capacity. If you have too many clients, give me a shout and we'll deal".</p>
<p>In effect it is just a more sophisticated routing algorithm: brokers become subcontractors for each other. There are other things to like about this design, even before we play with real code:</p>
<ul>
<li>It treats the common case (clients and workers on the same cluster) as default and does extra work for the exceptional case (shuffling jobs between clusters).</li>
</ul>
<ul>
<li>It lets us use different message flows for the different types of work. That means we can handle them differently, e.g., using different types of network connection.</li>
</ul>
<ul>
<li>It feels like it would scale smoothly. Interconnecting three or more brokers doesn't get overly complex. If we find this to be a problem, it's easy to solve by adding a super-broker.</li>
</ul>
<p>We'll now make a worked example. We'll pack an entire cluster into one process. That is obviously not realistic, but it makes it simple to simulate, and the simulation can accurately scale to real processes. This is the beauty of ZeroMQ—you can design at the micro-level and scale that up to the macro-level. Threads become processes, and then become boxes and the patterns and logic remain the same. Each of our "cluster" processes contains client threads, worker threads, and a broker thread.</p>
<p>We know the basic model well by now:</p>
<ul>
<li>The REQ client (REQ) threads create workloads and pass them to the broker (ROUTER).</li>
<li>The REQ worker (REQ) threads process workloads and return the results to the broker (ROUTER).</li>
<li>The broker queues and distributes workloads using the load balancing pattern.</li>
</ul>
<p><a name="Federation-Versus-Peering"></a><a name="header-82"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc81"><span><a href="http://zguide.zeromq.org/page:all#Federation-Versus-Peering">Federation Versus Peering</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-81">prev</a> <a href="http://zguide.zeromq.org/page:all#header-83">next</a></td>
</tr>
</tbody></table>
<p>There are several possible ways to interconnect brokers. What we want is to be able to tell other brokers, "we have capacity", and then receive multiple tasks. We also need to be able to tell other brokers, "stop, we're full". It doesn't need to be perfect; sometimes we may accept jobs we can't process immediately, then we'll do them as soon as possible.</p>
<p>The simplest interconnect is <em>federation</em>, in which brokers simulate clients and workers for each other. We would do this by connecting our frontend to the other broker's backend socket. Note that it is legal to both bind a socket to an endpoint and connect it to other endpoints.</p>
<p><strong>Figure 43 - Cross-connected Brokers in Federation Model</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig43.png" alt="fig43.png" class="image"></div>
<p>This would give us simple logic in both brokers and a reasonably good mechanism: when there are no workers, tell the other broker "ready", and accept one job from it. The problem is also that it is too simple for this problem. A federated broker would be able to handle only one task at a time. If the broker emulates a lock-step client and worker, it is by definition also going to be lock-step, and if it has lots of available workers they won't be used. Our brokers need to be connected in a fully asynchronous fashion.</p>
<p>The federation model is perfect for other kinds of routing, especially service-oriented architectures (SOAs), which route by service name and proximity rather than load balancing or round robin. So don't dismiss it as useless, it's just not right for all use cases.</p>
<p>Instead of federation, let's look at a <em>peering</em> approach in which brokers are explicitly aware of each other and talk over privileged channels. Let's break this down, assuming we want to interconnect N brokers. Each broker has (N - 1) peers, and all brokers are using exactly the same code and logic. There are two distinct flows of information between brokers:</p>
<ul>
<li>Each broker needs to tell its peers how many workers it has available at any time. This can be fairly simple information—just a quantity that is updated regularly. The obvious (and correct) socket pattern for this is pub-sub. So every broker opens a PUB socket and publishes state information on that, and every broker also opens a SUB socket and connects that to the PUB socket of every other broker to get state information from its peers.</li>
</ul>
<ul>
<li>Each broker needs a way to delegate tasks to a peer and get replies back, asynchronously. We'll do this using ROUTER sockets; no other combination works. Each broker has two such sockets: one for tasks it receives and one for tasks it delegates. If we didn't use two sockets, it would be more work to know whether we were reading a request or a reply each time. That would mean adding more information to the message envelope.</li>
</ul>
<p>And there is also the flow of information between a broker and its local clients and workers.</p>
<p><a name="The-Naming-Ceremony"></a><a name="header-83"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc82"><span><a href="http://zguide.zeromq.org/page:all#The-Naming-Ceremony">The Naming Ceremony</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-82">prev</a> <a href="http://zguide.zeromq.org/page:all#header-84">next</a></td>
</tr>
</tbody></table>
<p>Three flows x two sockets for each flow = six sockets that we have to manage in the broker. Choosing good names is vital to keeping a multisocket juggling act reasonably coherent in our minds. Sockets <em>do</em> something and what they do should form the basis for their names. It's about being able to read the code several weeks later on a cold Monday morning before coffee, and not feel any pain.</p>
<p>Let's do a shamanistic naming ceremony for the sockets. The three flows are:</p>
<ul>
<li>A <em>local</em> request-reply flow between the broker and its clients and workers.</li>
<li>A <em>cloud</em> request-reply flow between the broker and its peer brokers.</li>
<li>A <em>state</em> flow between the broker and its peer brokers.</li>
</ul>
<p>Finding meaningful names that are all the same length means our code will align nicely. It's not a big thing, but attention to details helps. For each flow the broker has two sockets that we can orthogonally call the <em>frontend</em> and <em>backend</em>. We've used these names quite often. A frontend receives information or tasks. A backend sends those out to other peers. The conceptual flow is from front to back (with replies going in the opposite direction from back to front).</p>
<p>So in all the code we write for this tutorial, we will use these socket names:</p>
<ul>
<li><em>localfe</em> and <em>localbe</em> for the local flow.</li>
<li><em>cloudfe</em> and <em>cloudbe</em> for the cloud flow.</li>
<li><em>statefe</em> and <em>statebe</em> for the state flow.</li>
</ul>
<p>For our transport and because we're simulating the whole thing on one box, we'll use <tt>ipc</tt> for everything. This has the advantage of working like <tt>tcp</tt> in terms of connectivity (i.e., it's a disconnected transport, unlike <tt>inproc</tt>), yet we don't need IP addresses or DNS names, which would be a pain here. Instead, we will use <tt>ipc</tt> endpoints called <em>something</em>-<tt>local</tt>, <em>something</em>-<tt>cloud</tt>, and <em>something</em>-<tt>state</tt>, where <em>something</em> is the name of our simulated cluster.</p>
<p>You might be thinking that this is a lot of work for some names. Why not call them s1, s2, s3, s4, etc.? The answer is that if your brain is not a perfect machine, you need a lot of help when reading code, and we'll see that these names do help. It's easier to remember "three flows, two directions" than "six different sockets".</p>
<p><strong>Figure 44 - Broker Socket Arrangement</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig44.png" alt="fig44.png" class="image"></div>
<p>Note that we connect the cloudbe in each broker to the cloudfe in every other broker, and likewise we connect the statebe in each broker to the statefe in every other broker.</p>
<p><a name="Prototyping-the-State-Flow"></a><a name="header-84"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc83"><span><a href="http://zguide.zeromq.org/page:all#Prototyping-the-State-Flow">Prototyping the State Flow</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-83">prev</a> <a href="http://zguide.zeromq.org/page:all#header-85">next</a></td>
</tr>
</tbody></table>
<p>Because each socket flow has its own little traps for the unwary, we will test them in real code one-by-one, rather than try to throw the whole lot into code in one go. When we're happy with each flow, we can put them together into a full program. We'll start with the state flow.</p>
<p><strong>Figure 45 - The State Flow</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig45.png" alt="fig45.png" class="image"></div>
<p>Here is how this works in code:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">peering1:&nbsp;Prototype&nbsp;state&nbsp;flow&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">peering1:&nbsp;Prototype&nbsp;state&nbsp;flow&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Broker peering simulation (part 1)<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Prototypes the state flow</span></p>
<p>#include "czmq.h"</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">int</span> argc, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>argv <span style="white-space: pre-wrap;">[]</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>First argument is this broker's name</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Other arguments are our peers' names</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span></em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (argc <span style="color:#666666">&lt;</span> <span style="color:#666666">2</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"syntax: peering1 me {you}…</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>self <span style="color:#666666">=</span> argv <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"I: preparing broker at %s…</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>srandom ((<span style="color:#B00040">unsigned</span>) time (<span style="color:#008000">NULL</span>));</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Bind state backend to endpoint</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>statebe <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_PUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (statebe, <span style="color:#BA2121">"ipc:<span style="white-space: pre-wrap;">//</span>%s-state.ipc"</span>, self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Connect statefe to all peers</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>statefe <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_SUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_set_subscribe (statefe, <span style="color:#BA2121">""</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> argn;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (argn <span style="color:#666666">=</span> <span style="color:#666666">2</span>; argn <span style="color:#666666">&lt;</span> argc; argn<span style="color:#666666">++</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>peer <span style="color:#666666">=</span> argv <span style="white-space: pre-wrap;">[</span>argn<span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"I: connecting to state backend at '%s'</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, peer);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zsocket_connect (statefe, <span style="color:#BA2121">"ipc:<span style="white-space: pre-wrap;">//</span>%s-state.ipc"</span>, peer);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The main loop sends out status messages to peers, and collects</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>status messages back from peers. The zmq_poll timeout defines</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>our own heartbeat:</em></span></p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Poll for activity, or 1 second timeout</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_pollitem_t items <span style="white-space: pre-wrap;">[]</span> <span style="color:#666666">=</span> { { statefe, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> } };<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> rc <span style="color:#666666">=</span> zmq_poll (items, <span style="color:#666666">1</span>, <span style="color:#666666">1000</span> <span style="color:#666666">*</span> ZMQ_POLL_MSEC);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (rc <span style="color:#666666">==</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span></p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Handle incoming status messages</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>peer_name <span style="color:#666666">=</span> zstr_recv (statefe);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>available <span style="color:#666666">=</span> zstr_recv (statefe);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"%s - %s workers free</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, peer_name, available);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>free (peer_name);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>free (available);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send random values for worker availability</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zstr_sendm (statebe, self);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zstr_sendf (statebe, <span style="color:#BA2121">"%d"</span>, randof (<span style="color:#666666">10</span>));<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> EXIT_SUCCESS;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cs:peering1" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/clj:peering1" target="_blank">Clojure</a> | <a href="http://zguide.zeromq.org/dpr:peering1" target="_blank">Delphi</a> | <a href="http://zguide.zeromq.org/fsx:peering1" target="_blank">F#</a> | <a href="http://zguide.zeromq.org/go:peering1" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:peering1" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:peering1" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:peering1" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:peering1" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/js:peering1" target="_blank">Node.js</a> | <a href="http://zguide.zeromq.org/php:peering1" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:peering1" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rkt:peering1" target="_blank">Racket</a> | <a href="http://zguide.zeromq.org/rb:peering1" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/scala:peering1" target="_blank">Scala</a> | <a href="http://zguide.zeromq.org/tcl:peering1" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | CL | Erlang | Felix | Objective-C | ooc | Perl | Q</a></span>
<p>Notes about this code:</p>
<ul>
<li>Each broker has an identity that we use to construct <tt>ipc</tt> endpoint names. A real broker would need to work with TCP and a more sophisticated configuration scheme. We'll look at such schemes later in this book, but for now, using generated <tt>ipc</tt> names lets us ignore the problem of where to get TCP/IP addresses or names.</li>
</ul>
<ul>
<li>We use a <tt><a href="http://api.zeromq.org/3-2:zmq_poll">zmq_poll()</a></tt> loop as the core of the program. This processes incoming messages and sends out state messages. We send a state message <em>only</em> if we did not get any incoming messages <em>and</em> we waited for a second. If we send out a state message each time we get one in, we'll get message storms.</li>
</ul>
<ul>
<li>We use a two-part pub-sub message consisting of sender address and data. Note that we will need to know the address of the publisher in order to send it tasks, and the only way is to send this explicitly as a part of the message.</li>
</ul>
<ul>
<li>We don't set identities on subscribers because if we did then we'd get outdated state information when connecting to running brokers.</li>
</ul>
<ul>
<li>We don't set a HWM on the publisher, but if we were using ZeroMQ v2.x that would be a wise idea.</li>
</ul>
<p>We can build this little program and run it three times to simulate three clusters. Let's call them DC1, DC2, and DC3 (the names are arbitrary). We run these three commands, each in a separate window:</p>
<div class="code">
<pre><code>peering1 DC1 DC2 DC3  #  Start DC1 and connect to DC2 and DC3
peering1 DC2 DC1 DC3  #  Start DC2 and connect to DC1 and DC3
peering1 DC3 DC1 DC2  #  Start DC3 and connect to DC1 and DC2</code>
</pre></div>
<p>You'll see each cluster report the state of its peers, and after a few seconds they will all happily be printing random numbers once per second. Try this and satisfy yourself that the three brokers all match up and synchronize to per-second state updates.</p>
<p>In real life, we'd not send out state messages at regular intervals, but rather whenever we had a state change, i.e., whenever a worker becomes available or unavailable. That may seem like a lot of traffic, but state messages are small and we've established that the inter-cluster connections are super fast.</p>
<p>If we wanted to send state messages at precise intervals, we'd create a child thread and open the <tt>statebe</tt> socket in that thread. We'd then send irregular state updates to that child thread from our main thread and allow the child thread to conflate them into regular outgoing messages. This is more work than we need here.</p>
<p><a name="Prototyping-the-Local-and-Cloud-Flows"></a><a name="header-85"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc84"><span><a href="http://zguide.zeromq.org/page:all#Prototyping-the-Local-and-Cloud-Flows">Prototyping the Local and Cloud Flows</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-84">prev</a> <a href="http://zguide.zeromq.org/page:all#header-86">next</a></td>
</tr>
</tbody></table>
<p>Let's now prototype the flow of tasks via the local and cloud sockets. This code pulls requests from clients and then distributes them to local workers and cloud peers on a random basis.</p>
<p><strong>Figure 46 - The Flow of Tasks</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig46.png" alt="fig46.png" class="image"></div>
<p>Before we jump into the code, which is getting a little complex, let's sketch the core routing logic and break it down into a simple yet robust design.</p>
<p>We need two queues, one for requests from local clients and one for requests from cloud clients. One option would be to pull messages off the local and cloud frontends, and pump these onto their respective queues. But this is kind of pointless because ZeroMQ sockets <em>are</em> queues already. So let's use the ZeroMQ socket buffers as queues.</p>
<p>This was the technique we used in the load balancing broker, and it worked nicely. We only read from the two frontends when there is somewhere to send the requests. We can always read from the backends, as they give us replies to route back. As long as the backends aren't talking to us, there's no point in even looking at the frontends.</p>
<p>So our main loop becomes:</p>
<ul>
<li>Poll the backends for activity. When we get a message, it may be "ready" from a worker or it may be a reply. If it's a reply, route back via the local or cloud frontend.</li>
</ul>
<ul>
<li>If a worker replied, it became available, so we queue it and count it.</li>
</ul>
<ul>
<li>While there are workers available, take a request, if any, from either frontend and route to a local worker, or randomly, to a cloud peer.</li>
</ul>
<p>Randomly sending tasks to a peer broker rather than a worker simulates work distribution across the cluster. It's dumb, but that is fine for this stage.</p>
<p>We use broker identities to route messages between brokers. Each broker has a name that we provide on the command line in this simple prototype. As long as these names don't overlap with the ZeroMQ-generated UUIDs used for client nodes, we can figure out whether to route a reply back to a client or to a broker.</p>
<p>Here is how this works in code. The interesting part starts around the comment "Interesting part".</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">peering2:&nbsp;Prototype&nbsp;local&nbsp;and&nbsp;cloud&nbsp;flow&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">peering2:&nbsp;Prototype&nbsp;local&nbsp;and&nbsp;cloud&nbsp;flow&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Broker peering simulation (part 2)<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Prototypes the request-reply flow</span></p>
<p>#include "czmq.h"<br>
#define NBR_CLIENTS 10<br>
#define NBR_WORKERS 3<br>
#define WORKER_READY<tt><span style="white-space: pre-wrap;">   </span></tt>"\001"<tt><span style="white-space: pre-wrap;">      </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Signals worker is ready</em></span></p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Our own name; in practice this would be configured per node</em></span><br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">char</span> <span style="color:#666666">*</span>self;</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The client task does a request-reply dialog using a standard<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>synchronous REQ socket:</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span> <span style="color:#666666">*</span><br>
<span style="color:#0000FF">client_task</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>args)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>client <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_REQ);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect (client, <span style="color:#BA2121">"ipc:<span style="white-space: pre-wrap;">//</span>%s-localfe.ipc"</span>, self);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send request, get reply</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zstr_send (client, <span style="color:#BA2121">"HELLO"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>reply <span style="color:#666666">=</span> zstr_recv (client);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>reply)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"Client: %s</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, reply);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (reply);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>sleep (<span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#008000">NULL</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The worker task plugs into the load-balancer using a REQ<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>socket:</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span> <span style="color:#666666">*</span><br>
<span style="color:#0000FF">worker_task</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>args)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>worker <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_REQ);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect (worker, <span style="color:#BA2121">"ipc:<span style="white-space: pre-wrap;">//</span>%s-localbe.ipc"</span>, self);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Tell broker we're ready for work</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zframe_t <span style="color:#666666">*</span>frame <span style="color:#666666">=</span> zframe_new (WORKER_READY, <span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zframe_send (<span style="color:#666666">&amp;</span>frame, worker, <span style="color:#666666">0</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Process messages as they arrive</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_recv (worker);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>msg)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span></p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt>zframe_print (zmsg_last (msg), <span style="color:#BA2121">"Worker: "</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_reset (zmsg_last (msg), <span style="color:#BA2121">"OK"</span>, <span style="color:#666666">2</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>msg, worker);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#008000">NULL</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The main task begins by setting-up its frontend and backend sockets<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>and then starting its client and worker tasks:</span></span></p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">int</span> argc, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>argv <span style="white-space: pre-wrap;">[]</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>First argument is this broker's name</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Other arguments are our peers' names</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span></em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (argc <span style="color:#666666">&lt;</span> <span style="color:#666666">2</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"syntax: peering2 me {you}…</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self <span style="color:#666666">=</span> argv <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"I: preparing broker at %s…</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>srandom ((<span style="color:#B00040">unsigned</span>) time (<span style="color:#008000">NULL</span>));</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Bind cloud frontend to endpoint</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>cloudfe <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_ROUTER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_set_identity (cloudfe, self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (cloudfe, <span style="color:#BA2121">"ipc:<span style="white-space: pre-wrap;">//</span>%s-cloud.ipc"</span>, self);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Connect cloud backend to all peers</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>cloudbe <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_ROUTER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_set_identity (cloudbe, self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> argn;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (argn <span style="color:#666666">=</span> <span style="color:#666666">2</span>; argn <span style="color:#666666">&lt;</span> argc; argn<span style="color:#666666">++</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>peer <span style="color:#666666">=</span> argv <span style="white-space: pre-wrap;">[</span>argn<span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"I: connecting to cloud frontend at '%s'</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, peer);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zsocket_connect (cloudbe, <span style="color:#BA2121">"ipc:<span style="white-space: pre-wrap;">//</span>%s-cloud.ipc"</span>, peer);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Prepare local frontend and backend</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>localfe <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_ROUTER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (localfe, <span style="color:#BA2121">"ipc:<span style="white-space: pre-wrap;">//</span>%s-localfe.ipc"</span>, self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>localbe <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_ROUTER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (localbe, <span style="color:#BA2121">"ipc:<span style="white-space: pre-wrap;">//</span>%s-localbe.ipc"</span>, self);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Get user to tell us when we can start…</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"Press Enter when all brokers are started: "</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>getchar ();</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Start local workers</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> worker_nbr;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (worker_nbr <span style="color:#666666">=</span> <span style="color:#666666">0</span>; worker_nbr <span style="color:#666666">&lt;</span> NBR_WORKERS; worker_nbr<span style="color:#666666">++</span>)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zthread_new (worker_task, <span style="color:#008000">NULL</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Start local clients</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> client_nbr;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (client_nbr <span style="color:#666666">=</span> <span style="color:#666666">0</span>; client_nbr <span style="color:#666666">&lt;</span> NBR_CLIENTS; client_nbr<span style="color:#666666">++</span>)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zthread_new (client_task, <span style="color:#008000">NULL</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span> Interesting part</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Here, we handle the request-reply flow. We're using load-balancing</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>to poll workers at all times, and clients only when there are one //</em><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>or more workers available.//</span></p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Least recently used queue of available workers</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> capacity <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zlist_t <span style="color:#666666">*</span>workers <span style="color:#666666">=</span> zlist_new ();</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>First, route any waiting replies from workers</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_pollitem_t backends <span style="white-space: pre-wrap;">[]</span> <span style="color:#666666">=</span> {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>{ localbe, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> },<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>{ cloudbe, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> }<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If we have no workers, wait indefinitely</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> rc <span style="color:#666666">=</span> zmq_poll (backends, <span style="color:#666666">2</span>,<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>capacity<span style="color:#666666">?</span> <span style="color:#666666">1000</span> <span style="color:#666666">*</span> ZMQ_POLL_MSEC<span style="color:#666666">:</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (rc <span style="color:#666666">==</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span></p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Handle reply from local worker</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> <span style="color:#008000">NULL</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (backends <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>msg <span style="color:#666666">=</span> zmsg_recv (localbe);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>msg)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_t <span style="color:#666666">*</span>identity <span style="color:#666666">=</span> zmsg_unwrap (msg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zlist_append (workers, identity);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>capacity<span style="color:#666666">++</span>;</p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If it's READY, don't route the message any further</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_t <span style="color:#666666">*</span>frame <span style="color:#666666">=</span> zmsg_first (msg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (memcmp (zframe_data (frame), WORKER_READY, <span style="color:#666666">1</span>) <span style="color:#666666">==</span> <span style="color:#666666">0</span>)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>msg);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Or handle reply from peer broker</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (backends <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>msg <span style="color:#666666">=</span> zmsg_recv (cloudbe);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>msg)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We don't use peer broker identity for anything</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_t <span style="color:#666666">*</span>identity <span style="color:#666666">=</span> zmsg_unwrap (msg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_destroy (<span style="color:#666666">&amp;</span>identity);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Route reply to cloud if it's addressed to a broker</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>for</strong></span> (argn <span style="color:#666666">=</span> <span style="color:#666666">2</span>; msg <span style="color:#666666">&amp;&amp;</span> argn <span style="color:#666666">&lt;</span> argc; argn<span style="color:#666666">++</span>) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>data <span style="color:#666666">=</span> (<span style="color:#B00040">char</span> <span style="color:#666666">*</span>) zframe_data (zmsg_first (msg));<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">size_t</span> size <span style="color:#666666">=</span> zframe_size (zmsg_first (msg));<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (size <span style="color:#666666">==</span> strlen (argv <span style="white-space: pre-wrap;">[</span>argn<span style="white-space: pre-wrap;">]</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#666666">&amp;&amp;</span><tt><span style="white-space: pre-wrap;">  </span></tt>memcmp (data, argv <span style="white-space: pre-wrap;">[</span>argn<span style="white-space: pre-wrap;">]</span>, size) <span style="color:#666666">==</span> <span style="color:#666666">0</span>)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>msg, cloudfe);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Route reply to client if we still need to</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (msg)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>msg, localfe);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Now we route as many client requests as we have worker capacity</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>for. We may reroute requests from our local frontend, but not from //</em><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>the cloud frontend. We reroute randomly now, just to test things<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>out. In the next version, we'll do this properly by calculating<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>cloud capacity://</span></p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>while</strong></span> (capacity) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmq_pollitem_t frontends <span style="white-space: pre-wrap;">[]</span> <span style="color:#666666">=</span> {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>{ localfe, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> },<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>{ cloudfe, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> }<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt>;<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>rc <span style="color:#666666">=</span> zmq_poll (frontends, <span style="color:#666666">2</span>, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>assert (rc <span style="color:#666666">&gt;=</span> <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">int</span> reroutable <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We'll do peer brokers first, to prevent starvation</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (frontends <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>msg <span style="color:#666666">=</span> zmsg_recv (cloudfe);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>reroutable <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (frontends <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>msg <span style="color:#666666">=</span> zmsg_recv (localfe);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>reroutable <span style="color:#666666">=</span> <span style="color:#666666">1</span>;<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">      </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>No work, go back to backends</em></span></p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If reroutable, send to cloud 20% of the time</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Here we'd normally use cloud status information</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span></em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (reroutable <span style="color:#666666">&amp;&amp;</span> argc <span style="color:#666666">&gt;</span> <span style="color:#666666">2</span> <span style="color:#666666">&amp;&amp;</span> randof (<span style="color:#666666">5</span>) <span style="color:#666666">==</span> <span style="color:#666666">0</span>) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Route to random broker peer</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#B00040">int</span> peer <span style="color:#666666">=</span> randof (argc <span style="color:#666666">-</span> <span style="color:#666666">2</span>) <span style="color:#666666">+</span> <span style="color:#666666">2</span>;<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_pushmem (msg, argv <span style="white-space: pre-wrap;">[</span>peer<span style="white-space: pre-wrap;">]</span>, strlen (argv <span style="white-space: pre-wrap;">[</span>peer<span style="white-space: pre-wrap;">]</span>));<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>msg, cloudbe);<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>else</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zframe_t <span style="color:#666666">*</span>frame <span style="color:#666666">=</span> (zframe_t <span style="color:#666666">*</span>) zlist_pop (workers);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_wrap (msg, frame);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>msg, localbe);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>capacity<span style="color:#666666"><span style="white-space: pre-wrap;">--</span></span>;<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>When we're done, clean up properly</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (zlist_size (workers)) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_t <span style="color:#666666">*</span>frame <span style="color:#666666">=</span> (zframe_t <span style="color:#666666">*</span>) zlist_pop (workers);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_destroy (<span style="color:#666666">&amp;</span>frame);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zlist_destroy (<span style="color:#666666">&amp;</span>workers);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> EXIT_SUCCESS;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cs:peering2" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/dpr:peering2" target="_blank">Delphi</a> | <a href="http://zguide.zeromq.org/fsx:peering2" target="_blank">F#</a> | <a href="http://zguide.zeromq.org/go:peering2" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:peering2" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:peering2" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:peering2" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:peering2" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/php:peering2" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:peering2" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rb:peering2" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/scala:peering2" target="_blank">Scala</a> | <a href="http://zguide.zeromq.org/tcl:peering2" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | Clojure | CL | Erlang | Felix | Node.js | Objective-C | ooc | Perl | Q | Racket</a></span>
<p>Run this by, for instance, starting two instances of the broker in two windows:</p>
<div class="code">
<pre><code>peering2 me you
peering2 you me</code>
</pre></div>
<p>Some comments on this code:</p>
<ul>
<li>In the C code at least, using the zmsg class makes life much easier, and our code much shorter. It's obviously an abstraction that works. If you build ZeroMQ applications in C, you should use CZMQ.</li>
</ul>
<ul>
<li>Because we're not getting any state information from peers, we naively assume they are running. The code prompts you to confirm when you've started all the brokers. In the real case, we'd not send anything to brokers who had not told us they exist.</li>
</ul>
<p>You can satisfy yourself that the code works by watching it run forever. If there were any misrouted messages, clients would end up blocking, and the brokers would stop printing trace information. You can prove that by killing either of the brokers. The other broker tries to send requests to the cloud, and one-by-one its clients block, waiting for an answer.</p>
<p><a name="Putting-it-All-Together"></a><a name="header-86"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc85"><span><a href="http://zguide.zeromq.org/page:all#Putting-it-All-Together">Putting it All Together</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-85">prev</a> <a href="http://zguide.zeromq.org/page:all#header-87">next</a></td>
</tr>
</tbody></table>
<p>Let's put this together into a single package. As before, we'll run an entire cluster as one process. We're going to take the two previous examples and merge them into one properly working design that lets you simulate any number of clusters.</p>
<p>This code is the size of both previous prototypes together, at 270 LoC. That's pretty good for a simulation of a cluster that includes clients and workers and cloud workload distribution. Here is the code:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">peering3:&nbsp;Full&nbsp;cluster&nbsp;simulation&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">peering3:&nbsp;Full&nbsp;cluster&nbsp;simulation&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Broker peering simulation (part 3)<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Prototypes the full flow of status and tasks</span></p>
<p>#include "czmq.h"<br>
#define NBR_CLIENTS 10<br>
#define NBR_WORKERS 5<br>
#define WORKER_READY<tt><span style="white-space: pre-wrap;">   </span></tt>"\001"<tt><span style="white-space: pre-wrap;">      </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Signals worker is ready</em></span></p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Our own name; in practice, this would be configured per node</em></span><br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">char</span> <span style="color:#666666">*</span>self;</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This is the client task. It issues a burst of requests and then<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>sleeps for a few seconds. This simulates sporadic activity; when<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>a number of clients are active at once, the local workers should<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>be overloaded. The client uses a REQ socket for requests and also<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>pushes statistics to the monitor socket:</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span> <span style="color:#666666">*</span><br>
<span style="color:#0000FF">client_task</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>args)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>client <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_REQ);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect (client, <span style="color:#BA2121">"ipc:<span style="white-space: pre-wrap;">//</span>%s-localfe.ipc"</span>, self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>monitor <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_PUSH);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect (monitor, <span style="color:#BA2121">"ipc:<span style="white-space: pre-wrap;">//</span>%s-monitor.ipc"</span>, self);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>sleep (randof (<span style="color:#666666">5</span>));<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> burst <span style="color:#666666">=</span> randof (<span style="color:#666666">15</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>while</strong></span> (burst<span style="color:#666666"><span style="white-space: pre-wrap;">--</span></span>) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">char</span> task_id <span style="white-space: pre-wrap;">[</span><span style="color:#666666">5</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>sprintf (task_id, <span style="color:#BA2121">"%04X"</span>, randof (<span style="color:#666666">0x10000</span>));</p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send request with random hex ID</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zstr_send (client, task_id);</p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Wait max ten seconds for a reply, then complain</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmq_pollitem_t pollset <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span> <span style="color:#666666">=</span> { { client, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> } };<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">int</span> rc <span style="color:#666666">=</span> zmq_poll (pollset, <span style="color:#666666">1</span>, <span style="color:#666666">10</span> <span style="color:#666666">*</span> <span style="color:#666666">1000</span> <span style="color:#666666">*</span> ZMQ_POLL_MSEC);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (rc <span style="color:#666666">==</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span></p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (pollset <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>reply <span style="color:#666666">=</span> zstr_recv (client);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>reply)<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Worker is supposed to answer us with our task id</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt>assert (streq (reply, task_id));<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zstr_sendf (monitor, <span style="color:#BA2121">"%s"</span>, reply);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>free (reply);<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>else</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zstr_sendf (monitor,<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt><span style="color:#BA2121">"E: CLIENT EXIT - lost task %s"</span>, task_id);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#008000">NULL</span>;<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#008000">NULL</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This is the worker task, which uses a REQ socket to plug into the<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>load-balancer. It's the same stub worker task that you've seen in<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>other examples:</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span> <span style="color:#666666">*</span><br>
<span style="color:#0000FF">worker_task</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>args)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>worker <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_REQ);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect (worker, <span style="color:#BA2121">"ipc:<span style="white-space: pre-wrap;">//</span>%s-localbe.ipc"</span>, self);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Tell broker we're ready for work</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zframe_t <span style="color:#666666">*</span>frame <span style="color:#666666">=</span> zframe_new (WORKER_READY, <span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zframe_send (<span style="color:#666666">&amp;</span>frame, worker, <span style="color:#666666">0</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Process messages as they arrive</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_recv (worker);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>msg)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span></p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Workers are busy for 0/1 seconds</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>sleep (randof (<span style="color:#666666">2</span>));<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>msg, worker);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#008000">NULL</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The main task begins by setting up all its sockets. The local frontend<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>talks to clients, and our local backend talks to workers. The cloud<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>frontend talks to peer brokers as if they were clients, and the cloud<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>backend talks to peer brokers as if they were workers. The state<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>backend publishes regular state messages, and the state frontend<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>subscribes to all state backends to collect these messages. Finally,<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>we use a PULL monitor socket to collect printable messages from tasks:</span></span></p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">int</span> argc, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>argv <span style="white-space: pre-wrap;">[]</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>First argument is this broker's name</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Other arguments are our peers' names</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (argc <span style="color:#666666">&lt;</span> <span style="color:#666666">2</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"syntax: peering3 me {you}…</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self <span style="color:#666666">=</span> argv <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"I: preparing broker at %s…</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>srandom ((<span style="color:#B00040">unsigned</span>) time (<span style="color:#008000">NULL</span>));</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Prepare local frontend and backend</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>localfe <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_ROUTER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (localfe, <span style="color:#BA2121">"ipc:<span style="white-space: pre-wrap;">//</span>%s-localfe.ipc"</span>, self);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>localbe <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_ROUTER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (localbe, <span style="color:#BA2121">"ipc:<span style="white-space: pre-wrap;">//</span>%s-localbe.ipc"</span>, self);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Bind cloud frontend to endpoint</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>cloudfe <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_ROUTER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_set_identity (cloudfe, self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (cloudfe, <span style="color:#BA2121">"ipc:<span style="white-space: pre-wrap;">//</span>%s-cloud.ipc"</span>, self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Connect cloud backend to all peers</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>cloudbe <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_ROUTER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_set_identity (cloudbe, self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> argn;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (argn <span style="color:#666666">=</span> <span style="color:#666666">2</span>; argn <span style="color:#666666">&lt;</span> argc; argn<span style="color:#666666">++</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>peer <span style="color:#666666">=</span> argv <span style="white-space: pre-wrap;">[</span>argn<span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"I: connecting to cloud frontend at '%s'</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, peer);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zsocket_connect (cloudbe, <span style="color:#BA2121">"ipc:<span style="white-space: pre-wrap;">//</span>%s-cloud.ipc"</span>, peer);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Bind state backend to endpoint</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>statebe <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_PUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (statebe, <span style="color:#BA2121">"ipc:<span style="white-space: pre-wrap;">//</span>%s-state.ipc"</span>, self);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Connect state frontend to all peers</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>statefe <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_SUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_set_subscribe (statefe, <span style="color:#BA2121">""</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (argn <span style="color:#666666">=</span> <span style="color:#666666">2</span>; argn <span style="color:#666666">&lt;</span> argc; argn<span style="color:#666666">++</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>peer <span style="color:#666666">=</span> argv <span style="white-space: pre-wrap;">[</span>argn<span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"I: connecting to state backend at '%s'</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, peer);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zsocket_connect (statefe, <span style="color:#BA2121">"ipc:<span style="white-space: pre-wrap;">//</span>%s-state.ipc"</span>, peer);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Prepare monitor socket</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>monitor <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_PULL);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (monitor, <span style="color:#BA2121">"ipc:<span style="white-space: pre-wrap;">//</span>%s-monitor.ipc"</span>, self);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>After binding and connecting all our sockets, we start our child</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>tasks - workers and clients:</em></span></p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> worker_nbr;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (worker_nbr <span style="color:#666666">=</span> <span style="color:#666666">0</span>; worker_nbr <span style="color:#666666">&lt;</span> NBR_WORKERS; worker_nbr<span style="color:#666666">++</span>)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zthread_new (worker_task, <span style="color:#008000">NULL</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Start local clients</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> client_nbr;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (client_nbr <span style="color:#666666">=</span> <span style="color:#666666">0</span>; client_nbr <span style="color:#666666">&lt;</span> NBR_CLIENTS; client_nbr<span style="color:#666666">++</span>)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zthread_new (client_task, <span style="color:#008000">NULL</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Queue of available workers</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> local_capacity <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> cloud_capacity <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zlist_t <span style="color:#666666">*</span>workers <span style="color:#666666">=</span> zlist_new ();</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The main loop has two parts. First, we poll workers and our two service</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>sockets (statefe and monitor), in any case. If we have no ready workers,</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>then there's no point in looking at incoming requests. These can remain //</em><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>on their internal 0MQ queues://</span></p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_pollitem_t primary <span style="white-space: pre-wrap;">[]</span> <span style="color:#666666">=</span> {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>{ localbe, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> },<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>{ cloudbe, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> },<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>{ statefe, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> },<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>{ monitor, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> }<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If we have no workers ready, wait indefinitely</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> rc <span style="color:#666666">=</span> zmq_poll (primary, <span style="color:#666666">4</span>,<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>local_capacity<span style="color:#666666">?</span> <span style="color:#666666">1000</span> <span style="color:#666666">*</span> ZMQ_POLL_MSEC<span style="color:#666666">:</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (rc <span style="color:#666666">==</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span></p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Track if capacity changes during this iteration</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> previous <span style="color:#666666">=</span> local_capacity;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> <span style="color:#008000">NULL</span>;<tt><span style="white-space: pre-wrap;">     </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Reply from local worker</em></span></p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (primary <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>msg <span style="color:#666666">=</span> zmsg_recv (localbe);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>msg)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_t <span style="color:#666666">*</span>identity <span style="color:#666666">=</span> zmsg_unwrap (msg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zlist_append (workers, identity);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>local_capacity<span style="color:#666666">++</span>;</p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If it's READY, don't route the message any further</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_t <span style="color:#666666">*</span>frame <span style="color:#666666">=</span> zmsg_first (msg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (memcmp (zframe_data (frame), WORKER_READY, <span style="color:#666666">1</span>) <span style="color:#666666">==</span> <span style="color:#666666">0</span>)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>msg);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Or handle reply from peer broker</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (primary <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>msg <span style="color:#666666">=</span> zmsg_recv (cloudbe);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>msg)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We don't use peer broker identity for anything</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_t <span style="color:#666666">*</span>identity <span style="color:#666666">=</span> zmsg_unwrap (msg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_destroy (<span style="color:#666666">&amp;</span>identity);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Route reply to cloud if it's addressed to a broker</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>for</strong></span> (argn <span style="color:#666666">=</span> <span style="color:#666666">2</span>; msg <span style="color:#666666">&amp;&amp;</span> argn <span style="color:#666666">&lt;</span> argc; argn<span style="color:#666666">++</span>) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>data <span style="color:#666666">=</span> (<span style="color:#B00040">char</span> <span style="color:#666666">*</span>) zframe_data (zmsg_first (msg));<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">size_t</span> size <span style="color:#666666">=</span> zframe_size (zmsg_first (msg));<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (size <span style="color:#666666">==</span> strlen (argv <span style="white-space: pre-wrap;">[</span>argn<span style="white-space: pre-wrap;">]</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#666666">&amp;&amp;</span><tt><span style="white-space: pre-wrap;">  </span></tt>memcmp (data, argv <span style="white-space: pre-wrap;">[</span>argn<span style="white-space: pre-wrap;">]</span>, size) <span style="color:#666666">==</span> <span style="color:#666666">0</span>)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>msg, cloudfe);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Route reply to client if we still need to</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (msg)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>msg, localfe);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If we have input messages on our statefe or monitor sockets, we</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>can process these immediately:</em></span></p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (primary <span style="white-space: pre-wrap;">[</span><span style="color:#666666">2</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>peer <span style="color:#666666">=</span> zstr_recv (statefe);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>status <span style="color:#666666">=</span> zstr_recv (statefe);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>cloud_capacity <span style="color:#666666">=</span> atoi (status);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>free (peer);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>free (status);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (primary <span style="white-space: pre-wrap;">[</span><span style="color:#666666">3</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>status <span style="color:#666666">=</span> zstr_recv (monitor);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"%s</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, status);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>free (status);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Now route as many clients requests as we can handle. If we have</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>local capacity, we poll both localfe and cloudfe. If we have cloud</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>capacity only, we poll just localfe. We route any request locally</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>if we can, else we route to the cloud.</em></span></p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>while</strong></span> (local_capacity <span style="color:#666666">+</span> cloud_capacity) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmq_pollitem_t secondary <span style="white-space: pre-wrap;">[]</span> <span style="color:#666666">=</span> {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>{ localfe, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> },<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>{ cloudfe, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> }<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt>;<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (local_capacity)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>rc <span style="color:#666666">=</span> zmq_poll (secondary, <span style="color:#666666">2</span>, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt>rc <span style="color:#666666">=</span> zmq_poll (secondary, <span style="color:#666666">1</span>, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>assert (rc <span style="color:#666666">&gt;=</span> <span style="color:#666666">0</span>);</p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (secondary <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>msg <span style="color:#666666">=</span> zmsg_recv (localfe);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (secondary <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>msg <span style="color:#666666">=</span> zmsg_recv (cloudfe);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">      </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>No work, go back to primary</em></span></p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (local_capacity) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zframe_t <span style="color:#666666">*</span>frame <span style="color:#666666">=</span> (zframe_t <span style="color:#666666">*</span>) zlist_pop (workers);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_wrap (msg, frame);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>msg, localbe);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>local_capacity<span style="color:#666666"><span style="white-space: pre-wrap;">--</span></span>;<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>else</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Route to random broker peer</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#B00040">int</span> peer <span style="color:#666666">=</span> randof (argc <span style="color:#666666">-</span> <span style="color:#666666">2</span>) <span style="color:#666666">+</span> <span style="color:#666666">2</span>;<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_pushmem (msg, argv <span style="white-space: pre-wrap;">[</span>peer<span style="white-space: pre-wrap;">]</span>, strlen (argv <span style="white-space: pre-wrap;">[</span>peer<span style="white-space: pre-wrap;">]</span>));<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>msg, cloudbe);<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We broadcast capacity messages to other peers; to reduce chatter,</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>we do this only if our capacity changed.</em></span></p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (local_capacity <span style="color:#666666">!=</span> previous) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We stick our own identity onto the envelope</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zstr_sendm (statebe, self);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Broadcast new capacity</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zstr_sendf (statebe, <span style="color:#BA2121">"%d"</span>, local_capacity);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>When we're done, clean up properly</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (zlist_size (workers)) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_t <span style="color:#666666">*</span>frame <span style="color:#666666">=</span> (zframe_t <span style="color:#666666">*</span>) zlist_pop (workers);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_destroy (<span style="color:#666666">&amp;</span>frame);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zlist_destroy (<span style="color:#666666">&amp;</span>workers);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> EXIT_SUCCESS;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/dpr:peering3" target="_blank">Delphi</a> | <a href="http://zguide.zeromq.org/fsx:peering3" target="_blank">F#</a> | <a href="http://zguide.zeromq.org/go:peering3" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:peering3" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:peering3" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:peering3" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:peering3" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/php:peering3" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:peering3" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rb:peering3" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/tcl:peering3" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | C# | Clojure | CL | Erlang | Felix | Node.js | Objective-C | ooc | Perl | Q | Racket | Scala</a></span>
<p>It's a nontrivial program and took about a day to get working. These are the highlights:</p>
<ul>
<li>The client threads detect and report a failed request. They do this by polling for a response and if none arrives after a while (10 seconds), printing an error message.</li>
</ul>
<ul>
<li>Client threads don't print directly, but instead send a message to a monitor socket (PUSH) that the main loop collects (PULL) and prints off. This is the first case we've seen of using ZeroMQ sockets for monitoring and logging; this is a big use case that we'll come back to later.</li>
</ul>
<ul>
<li>Clients simulate varying loads to get the cluster 100% at random moments, so that tasks are shifted over to the cloud. The number of clients and workers, and delays in the client and worker threads control this. Feel free to play with them to see if you can make a more realistic simulation.</li>
</ul>
<ul>
<li>The main loop uses two pollsets. It could in fact use three: information, backends, and frontends. As in the earlier prototype, there is no point in taking a frontend message if there is no backend capacity.</li>
</ul>
<p>These are some of the problems that arose during development of this program:</p>
<ul>
<li>Clients would freeze, due to requests or replies getting lost somewhere. Recall that the ROUTER socket drops messages it can't route. The first tactic here was to modify the client thread to detect and report such problems. Secondly, I put <tt>zmsg_dump()</tt> calls after every receive and before every send in the main loop, until the origin of the problems was clear.</li>
</ul>
<ul>
<li>The main loop was mistakenly reading from more than one ready socket. This caused the first message to be lost. I fixed that by reading only from the first ready socket.</li>
</ul>
<ul>
<li>The <tt>zmsg</tt> class was not properly encoding UUIDs as C strings. This caused UUIDs that contain 0 bytes to be corrupted. I fixed that by modifying <tt>zmsg</tt> to encode UUIDs as printable hex strings.</li>
</ul>
<p>This simulation does not detect disappearance of a cloud peer. If you start several peers and stop one, and it was broadcasting capacity to the others, they will continue to send it work even if it's gone. You can try this, and you will get clients that complain of lost requests. The solution is twofold: first, only keep the capacity information for a short time so that if a peer does disappear, its capacity is quickly set to zero. Second, add reliability to the request-reply chain. We'll look at reliability in the next chapter.</p>
<p><a name="reliable-request-reply"></a><br>
<a name="Chapter-Reliable-Request-Reply-Patterns"></a><a name="header-87"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h2 id="toc86"><span><a href="http://zguide.zeromq.org/page:all#Chapter-Reliable-Request-Reply-Patterns">Chapter 4 - Reliable Request-Reply Patterns</a></span></h2>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-86">prev</a> <a href="http://zguide.zeromq.org/page:all#header-88">next</a></td>
</tr>
</tbody></table>
<p><a href="http://zguide.zeromq.org/page:all#advanced-request-reply">Chapter 3 - Advanced Request-Reply Patterns</a> covered advanced uses of ZeroMQ's request-reply pattern with working examples. This chapter looks at the general question of reliability and builds a set of reliable messaging patterns on top of ZeroMQ's core request-reply pattern.</p>
<p>In this chapter, we focus heavily on user-space request-reply <em>patterns</em>, reusable models that help you design your own ZeroMQ architectures:</p>
<ul>
<li>The <em>Lazy Pirate</em> pattern: reliable request-reply from the client side</li>
<li>The <em>Simple Pirate</em> pattern: reliable request-reply using load balancing</li>
<li>The <em>Paranoid Pirate</em> pattern: reliable request-reply with heartbeating</li>
<li>The <em>Majordomo</em> pattern: service-oriented reliable queuing</li>
<li>The <em>Titanic</em> pattern: disk-based/disconnected reliable queuing</li>
<li>The <em>Binary Star</em> pattern: primary-backup server failover</li>
<li>The <em>Freelance</em> pattern: brokerless reliable request-reply</li>
</ul>
<p><a name="What-is-Reliability"></a><a name="header-88"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc87"><span><a href="http://zguide.zeromq.org/page:all#What-is-Reliability">What is "Reliability"?</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-87">prev</a> <a href="http://zguide.zeromq.org/page:all#header-89">next</a></td>
</tr>
</tbody></table>
<p>Most people who speak of "reliability" don't really know what they mean. We can only define reliability in terms of failure. That is, if we can handle a certain set of well-defined and understood failures, then we are reliable with respect to those failures. No more, no less. So let's look at the possible causes of failure in a distributed ZeroMQ application, in roughly descending order of probability:</p>
<ul>
<li>Application code is the worst offender. It can crash and exit, freeze and stop responding to input, run too slowly for its input, exhaust all memory, and so on.</li>
</ul>
<ul>
<li>System code—such as brokers we write using ZeroMQ—can die for the same reasons as application code. System code <em>should</em> be more reliable than application code, but it can still crash and burn, and especially run out of memory if it tries to queue messages for slow clients.</li>
</ul>
<ul>
<li>Message queues can overflow, typically in system code that has learned to deal brutally with slow clients. When a queue overflows, it starts to discard messages. So we get "lost" messages.</li>
</ul>
<ul>
<li>Networks can fail (e.g., WiFi gets switched off or goes out of range). ZeroMQ will automatically reconnect in such cases, but in the meantime, messages may get lost.</li>
</ul>
<ul>
<li>Hardware can fail and take with it all the processes running on that box.</li>
</ul>
<ul>
<li>Networks can fail in exotic ways, e.g., some ports on a switch may die and those parts of the network become inaccessible.</li>
</ul>
<ul>
<li>Entire data centers can be struck by lightning, earthquakes, fire, or more mundane power or cooling failures.</li>
</ul>
<p>To make a software system fully reliable against <em>all</em> of these possible failures is an enormously difficult and expensive job and goes beyond the scope of this book.</p>
<p>Because the first five cases in the above list cover 99.9% of real world requirements outside large companies (according to a highly scientific study I just ran, which also told me that 78% of statistics are made up on the spot, and moreover never to trust a statistic that we didn't falsify ourselves), that's what we'll examine. If you're a large company with money to spend on the last two cases, contact my company immediately! There's a large hole behind my beach house waiting to be converted into an executive swimming pool.</p>
<p><a name="Designing-Reliability"></a><a name="header-89"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc88"><span><a href="http://zguide.zeromq.org/page:all#Designing-Reliability">Designing Reliability</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-88">prev</a> <a href="http://zguide.zeromq.org/page:all#header-90">next</a></td>
</tr>
</tbody></table>
<p>So to make things brutally simple, reliability is "keeping things working properly when code freezes or crashes", a situation we'll shorten to "dies". However, the things we want to keep working properly are more complex than just messages. We need to take each core ZeroMQ messaging pattern and see how to make it work (if we can) even when code dies.</p>
<p>Let's take them one-by-one:</p>
<ul>
<li>Request-reply: if the server dies (while processing a request), the client can figure that out because it won't get an answer back. Then it can give up in a huff, wait and try again later, find another server, and so on. As for the client dying, we can brush that off as "someone else's problem" for now.</li>
</ul>
<ul>
<li>Pub-sub: if the client dies (having gotten some data), the server doesn't know about it. Pub-sub doesn't send any information back from client to server. But the client can contact the server out-of-band, e.g., via request-reply, and ask, "please resend everything I missed". As for the server dying, that's out of scope for here. Subscribers can also self-verify that they're not running too slowly, and take action (e.g., warn the operator and die) if they are.</li>
</ul>
<ul>
<li>Pipeline: if a worker dies (while working), the ventilator doesn't know about it. Pipelines, like the grinding gears of time, only work in one direction. But the downstream collector can detect that one task didn't get done, and send a message back to the ventilator saying, "hey, resend task 324!" If the ventilator or collector dies, whatever upstream client originally sent the work batch can get tired of waiting and resend the whole lot. It's not elegant, but system code should really not die often enough to matter.</li>
</ul>
<p>In this chapter we'll focus just on request-reply, which is the low-hanging fruit of reliable messaging.</p>
<p>The basic request-reply pattern (a REQ client socket doing a blocking send/receive to a REP server socket) scores low on handling the most common types of failure. If the server crashes while processing the request, the client just hangs forever. If the network loses the request or the reply, the client hangs forever.</p>
<p>Request-reply is still much better than TCP, thanks to ZeroMQ's ability to reconnect peers silently, to load balance messages, and so on. But it's still not good enough for real work. The only case where you can really trust the basic request-reply pattern is between two threads in the same process where there's no network or separate server process to die.</p>
<p>However, with a little extra work, this humble pattern becomes a good basis for real work across a distributed network, and we get a set of reliable request-reply (RRR) patterns that I like to call the <em>Pirate</em> patterns (you'll eventually get the joke, I hope).</p>
<p>There are, in my experience, roughly three ways to connect clients to servers. Each needs a specific approach to reliability:</p>
<ul>
<li>Multiple clients talking directly to a single server. Use case: a single well-known server to which clients need to talk. Types of failure we aim to handle: server crashes and restarts, and network disconnects.</li>
</ul>
<ul>
<li>Multiple clients talking to a broker proxy that distributes work to multiple workers. Use case: service-oriented transaction processing. Types of failure we aim to handle: worker crashes and restarts, worker busy looping, worker overload, queue crashes and restarts, and network disconnects.</li>
</ul>
<ul>
<li>Multiple clients talking to multiple servers with no intermediary proxies. Use case: distributed services such as name resolution. Types of failure we aim to handle: service crashes and restarts, service busy looping, service overload, and network disconnects.</li>
</ul>
<p>Each of these approaches has its trade-offs and often you'll mix them. We'll look at all three in detail.</p>
<p><a name="Client-Side-Reliability-Lazy-Pirate-Pattern"></a><a name="header-90"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc89"><span><a href="http://zguide.zeromq.org/page:all#Client-Side-Reliability-Lazy-Pirate-Pattern">Client-Side Reliability (Lazy Pirate Pattern)</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-89">prev</a> <a href="http://zguide.zeromq.org/page:all#header-91">next</a></td>
</tr>
</tbody></table>
<p>We can get very simple reliable request-reply with some changes to the client. We call this the Lazy Pirate pattern. Rather than doing a blocking receive, we:</p>
<ul>
<li>Poll the REQ socket and receive from it only when it's sure a reply has arrived.</li>
<li>Resend a request, if no reply has arrived within a timeout period.</li>
<li>Abandon the transaction if there is still no reply after several requests.</li>
</ul>
<p>If you try to use a REQ socket in anything other than a strict send/receive fashion, you'll get an error (technically, the REQ socket implements a small finite-state machine to enforce the send/receive ping-pong, and so the error code is called "EFSM"). This is slightly annoying when we want to use REQ in a pirate pattern, because we may send several requests before getting a reply.</p>
<p>The pretty good brute force solution is to close and reopen the REQ socket after an error:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">lpclient:&nbsp;Lazy&nbsp;Pirate&nbsp;client&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">lpclient:&nbsp;Lazy&nbsp;Pirate&nbsp;client&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Lazy Pirate client<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Use zmq_poll to do a safe request-reply<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>To run, start lpserver and then randomly kill/restart it</span></p>
<p>#include "czmq.h"<br>
#define REQUEST_TIMEOUT<tt><span style="white-space: pre-wrap;">     </span></tt>2500<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>msecs, (&gt; 1000!)</em></span><br>
<span style="color:#BC7A00">#define REQUEST_RETRIES<tt><span style="white-space: pre-wrap;">     </span></tt>3<tt><span style="white-space: pre-wrap;">       </span></tt></span><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Before we abandon</em></span><br>
<span style="color:#BC7A00">#define SERVER_ENDPOINT<tt><span style="white-space: pre-wrap;">     </span></tt>"tcp:</span><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span>localhost:5555"</em></span></p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"I: connecting to server…</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>client <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_REQ);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (client);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect (client, SERVER_ENDPOINT);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> sequence <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> retries_left <span style="color:#666666">=</span> REQUEST_RETRIES;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (retries_left <span style="color:#666666">&amp;&amp;</span> <span style="color:#666666">!</span>zctx_interrupted) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We send a request, then we work to get a reply</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> request <span style="white-space: pre-wrap;">[</span><span style="color:#666666">10</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>sprintf (request, <span style="color:#BA2121">"%d"</span>, <span style="color:#666666">++</span>sequence);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zstr_send (client, request);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> expect_reply <span style="color:#666666">=</span> <span style="color:#666666">1</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>while</strong></span> (expect_reply) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Poll socket for a reply, with timeout</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmq_pollitem_t items <span style="white-space: pre-wrap;">[]</span> <span style="color:#666666">=</span> { { client, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> } };<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">int</span> rc <span style="color:#666666">=</span> zmq_poll (items, <span style="color:#666666">1</span>, REQUEST_TIMEOUT <span style="color:#666666">*</span> ZMQ_POLL_MSEC);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (rc <span style="color:#666666">==</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span></p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Here we process a server reply and exit our loop if the</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>reply is valid. If we didn't a reply we close the client</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>socket and resend the request. We try a number of times</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>before finally abandoning:</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We got a reply from the server, must match sequence</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>reply <span style="color:#666666">=</span> zstr_recv (client);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>reply)<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">      </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>if</strong></span> (atoi (reply) <span style="color:#666666">==</span> sequence) {<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>printf (<span style="color:#BA2121">"I: server replied OK (%s)</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, reply);<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>retries_left <span style="color:#666666">=</span> REQUEST_RETRIES;<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>expect_reply <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">                </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>printf (<span style="color:#BA2121">"E: malformed reply from server: %s</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>,<br>
<tt><span style="white-space: pre-wrap;">                        </span></tt>reply);</p>
<p><tt><span style="white-space: pre-wrap;">                </span></tt>free (reply);<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666"><span style="white-space: pre-wrap;">--</span></span>retries_left <span style="color:#666666">==</span> <span style="color:#666666">0</span>) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>printf (<span style="color:#BA2121">"E: server seems to be offline, abandoning</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>else</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>printf (<span style="color:#BA2121">"W: no response from server, retrying…</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Old socket is confused; close it and open a new one</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zsocket_destroy (ctx, client);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>printf (<span style="color:#BA2121">"I: reconnecting to server…</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>client <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_REQ);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zsocket_connect (client, SERVER_ENDPOINT);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send request again, on new socket</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zstr_send (client, request);<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:lpclient" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:lpclient" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/clj:lpclient" target="_blank">Clojure</a> | <a href="http://zguide.zeromq.org/dpr:lpclient" target="_blank">Delphi</a> | <a href="http://zguide.zeromq.org/go:lpclient" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:lpclient" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:lpclient" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:lpclient" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:lpclient" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/pl:lpclient" target="_blank">Perl</a> | <a href="http://zguide.zeromq.org/php:lpclient" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:lpclient" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rb:lpclient" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/tcl:lpclient" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | CL | Erlang | F# | Felix | Node.js | Objective-C | ooc | Q | Racket | Scala</a></span>
<p>Run this together with the matching server:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">lpserver:&nbsp;Lazy&nbsp;Pirate&nbsp;server&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">lpserver:&nbsp;Lazy&nbsp;Pirate&nbsp;server&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Lazy Pirate server<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Binds REQ socket to tcp:<span style="white-space: pre-wrap;">//</span>*:5555<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Like hwserver except:<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">   </span></tt>- echoes request as-is<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">   </span></tt>- randomly runs slowly, or exits to simulate a crash.</span></span></p>
<p><span style="color:#BC7A00">#include "zhelpers.h"<br>
#include &lt;unistd.h&gt;</span></p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>srandom ((<span style="color:#B00040">unsigned</span>) time (<span style="color:#008000">NULL</span>));</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zmq_ctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>server <span style="color:#666666">=</span> zmq_socket (context, ZMQ_REP);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_bind (server, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5555"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> cycles <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>request <span style="color:#666666">=</span> s_recv (server);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>cycles<span style="color:#666666">++</span>;</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Simulate various problems, after a few cycles</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (cycles <span style="color:#666666">&gt;</span> <span style="color:#666666">3</span> <span style="color:#666666">&amp;&amp;</span> randof (<span style="color:#666666">3</span>) <span style="color:#666666">==</span> <span style="color:#666666">0</span>) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"I: simulating a crash</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (cycles <span style="color:#666666">&gt;</span> <span style="color:#666666">3</span> <span style="color:#666666">&amp;&amp;</span> randof (<span style="color:#666666">3</span>) <span style="color:#666666">==</span> <span style="color:#666666">0</span>) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"I: simulating CPU overload</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>sleep (<span style="color:#666666">2</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"I: normal request (%s)</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, request);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>sleep (<span style="color:#666666">1</span>);<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Do some heavy work</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>s_send (server, request);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (request);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_close (server);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_ctx_destroy (context);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:lpserver" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:lpserver" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/clj:lpserver" target="_blank">Clojure</a> | <a href="http://zguide.zeromq.org/dpr:lpserver" target="_blank">Delphi</a> | <a href="http://zguide.zeromq.org/go:lpserver" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:lpserver" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:lpserver" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:lpserver" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:lpserver" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/pl:lpserver" target="_blank">Perl</a> | <a href="http://zguide.zeromq.org/php:lpserver" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:lpserver" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rb:lpserver" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/scala:lpserver" target="_blank">Scala</a> | <a href="http://zguide.zeromq.org/tcl:lpserver" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | CL | Erlang | F# | Felix | Node.js | Objective-C | ooc | Q | Racket</a></span>
<p><strong>Figure 47 - The Lazy Pirate Pattern</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig47.png" alt="fig47.png" class="image"></div>
<p>To run this test case, start the client and the server in two console windows. The server will randomly misbehave after a few messages. You can check the client's response. Here is typical output from the server:</p>
<div class="code">
<pre><code>I: normal request (1)
I: normal request (2)
I: normal request (3)
I: simulating CPU overload
I: normal request (4)
I: simulating a crash</code>
</pre></div>
<p>And here is the client's response:</p>
<div class="code">
<pre><code>I: connecting to server...
I: server replied OK (1)
I: server replied OK (2)
I: server replied OK (3)
W: no response from server, retrying...
I: connecting to server...
W: no response from server, retrying...
I: connecting to server...
E: server seems to be offline, abandoning</code>
</pre></div>
<p>The client sequences each message and checks that replies come back exactly in order: that no requests or replies are lost, and no replies come back more than once, or out of order. Run the test a few times until you're convinced that this mechanism actually works. You don't need sequence numbers in a production application; they just help us trust our design.</p>
<p>The client uses a REQ socket, and does the brute force close/reopen because REQ sockets impose that strict send/receive cycle. You might be tempted to use a DEALER instead, but it would not be a good decision. First, it would mean emulating the secret sauce that REQ does with envelopes (if you've forgotten what that is, it's a good sign you don't want to have to do it). Second, it would mean potentially getting back replies that you didn't expect.</p>
<p>Handling failures only at the client works when we have a set of clients talking to a single server. It can handle a server crash, but only if recovery means restarting that same server. If there's a permanent error, such as a dead power supply on the server hardware, this approach won't work. Because the application code in servers is usually the biggest source of failures in any architecture, depending on a single server is not a great idea.</p>
<p>So, pros and cons:</p>
<ul>
<li>Pro: simple to understand and implement.</li>
<li>Pro: works easily with existing client and server application code.</li>
<li>Pro: ZeroMQ automatically retries the actual reconnection until it works.</li>
<li>Con: doesn't failover to backup or alternate servers.</li>
</ul>
<p><a name="Basic-Reliable-Queuing-Simple-Pirate-Pattern"></a><a name="header-91"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc90"><span><a href="http://zguide.zeromq.org/page:all#Basic-Reliable-Queuing-Simple-Pirate-Pattern">Basic Reliable Queuing (Simple Pirate Pattern)</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-90">prev</a> <a href="http://zguide.zeromq.org/page:all#header-92">next</a></td>
</tr>
</tbody></table>
<p>Our second approach extends the Lazy Pirate pattern with a queue proxy that lets us talk, transparently, to multiple servers, which we can more accurately call "workers". We'll develop this in stages, starting with a minimal working model, the Simple Pirate pattern.</p>
<p>In all these Pirate patterns, workers are stateless. If the application requires some shared state, such as a shared database, we don't know about it as we design our messaging framework. Having a queue proxy means workers can come and go without clients knowing anything about it. If one worker dies, another takes over. This is a nice, simple topology with only one real weakness, namely the central queue itself, which can become a problem to manage, and a single point of failure.</p>
<p><strong>Figure 48 - The Simple Pirate Pattern</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig48.png" alt="fig48.png" class="image"></div>
<p>The basis for the queue proxy is the load balancing broker from <a href="http://zguide.zeromq.org/page:all#advanced-request-reply">Chapter 3 - Advanced Request-Reply Patterns</a>. What is the very <em>minimum</em> we need to do to handle dead or blocked workers? Turns out, it's surprisingly little. We already have a retry mechanism in the client. So using the load balancing pattern will work pretty well. This fits with ZeroMQ's philosophy that we can extend a peer-to-peer pattern like request-reply by plugging naive proxies in the middle.</p>
<p>We don't need a special client; we're still using the Lazy Pirate client. Here is the queue, which is identical to the main task of the load balancing broker:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">spqueue:&nbsp;Simple&nbsp;Pirate&nbsp;queue&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">spqueue:&nbsp;Simple&nbsp;Pirate&nbsp;queue&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Simple Pirate broker<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This is identical to load-balancing pattern, with no reliability<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>mechanisms. It depends on the client for recovery. Runs forever.</span></p>
<p>#include "czmq.h"<br>
#define WORKER_READY<tt><span style="white-space: pre-wrap;">   </span></tt>"\001"<tt><span style="white-space: pre-wrap;">      </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Signals worker is ready</em></span></p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>frontend <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_ROUTER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>backend <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_ROUTER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (frontend, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5555"</span>);<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>For clients</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (backend,<tt><span style="white-space: pre-wrap;">  </span></tt><span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5556"</span>);<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>For workers</em></span></p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Queue of available workers</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zlist_t <span style="color:#666666">*</span>workers <span style="color:#666666">=</span> zlist_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The body of this example is exactly the same as lbbroker2.</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_pollitem_t items <span style="white-space: pre-wrap;">[]</span> <span style="color:#666666">=</span> {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>{ backend,<tt><span style="white-space: pre-wrap;">  </span></tt><span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> },<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>{ frontend, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> }<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Poll frontend only if we have available workers</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> rc <span style="color:#666666">=</span> zmq_poll (items, zlist_size (workers)<span style="color:#666666">?</span> <span style="color:#666666">2</span><span style="color:#666666">:</span> <span style="color:#666666">1</span>, <span style="color:#666666">-</span><span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (rc <span style="color:#666666">==</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span></p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Handle worker activity on backend</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Use worker identity for load-balancing</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_recv (backend);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>msg)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_t <span style="color:#666666">*</span>identity <span style="color:#666666">=</span> zmsg_unwrap (msg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zlist_append (workers, identity);</p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Forward message to client if it's not a READY</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_t <span style="color:#666666">*</span>frame <span style="color:#666666">=</span> zmsg_first (msg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (memcmp (zframe_data (frame), WORKER_READY, <span style="color:#666666">1</span>) <span style="color:#666666">==</span> <span style="color:#666666">0</span>)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>msg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>msg, frontend);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Get client request, route to first available worker</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_recv (frontend);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (msg) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_wrap (msg, (zframe_t <span style="color:#666666">*</span>) zlist_pop (workers));<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>msg, backend);<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>When we're done, clean up properly</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (zlist_size (workers)) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_t <span style="color:#666666">*</span>frame <span style="color:#666666">=</span> (zframe_t <span style="color:#666666">*</span>) zlist_pop (workers);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_destroy (<span style="color:#666666">&amp;</span>frame);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zlist_destroy (<span style="color:#666666">&amp;</span>workers);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:spqueue" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:spqueue" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/clj:spqueue" target="_blank">Clojure</a> | <a href="http://zguide.zeromq.org/dpr:spqueue" target="_blank">Delphi</a> | <a href="http://zguide.zeromq.org/go:spqueue" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:spqueue" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:spqueue" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:spqueue" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:spqueue" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/php:spqueue" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:spqueue" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/tcl:spqueue" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | CL | Erlang | F# | Felix | Node.js | Objective-C | ooc | Perl | Q | Racket | Ruby | Scala</a></span>
<p>Here is the worker, which takes the Lazy Pirate server and adapts it for the load balancing pattern (using the REQ "ready" signaling):</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">spworker:&nbsp;Simple&nbsp;Pirate&nbsp;worker&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">spworker:&nbsp;Simple&nbsp;Pirate&nbsp;worker&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Simple Pirate worker<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Connects REQ socket to tcp:<span style="white-space: pre-wrap;">//</span>*:5556<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Implements worker part of load-balancing</span></p>
<p>#include "czmq.h"<br>
#define WORKER_READY<tt><span style="white-space: pre-wrap;">   </span></tt>"\001"<tt><span style="white-space: pre-wrap;">      </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Signals worker is ready</em></span></p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>worker <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_REQ);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Set random identity to make tracing easier</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>srandom ((<span style="color:#B00040">unsigned</span>) time (<span style="color:#008000">NULL</span>));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> identity <span style="white-space: pre-wrap;">[</span><span style="color:#666666">10</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>sprintf (identity, <span style="color:#BA2121">"%04X-%04X"</span>, randof (<span style="color:#666666">0x10000</span>), randof (<span style="color:#666666">0x10000</span>));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_setsockopt (worker, ZMQ_IDENTITY, identity, strlen (identity));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect (worker, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5556"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Tell broker we're ready for work</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"I: (%s) worker ready</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, identity);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zframe_t <span style="color:#666666">*</span>frame <span style="color:#666666">=</span> zframe_new (WORKER_READY, <span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zframe_send (<span style="color:#666666">&amp;</span>frame, worker, <span style="color:#666666">0</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> cycles <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_recv (worker);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>msg)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span></p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Simulate various problems, after a few cycles</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>cycles<span style="color:#666666">++</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (cycles <span style="color:#666666">&gt;</span> <span style="color:#666666">3</span> <span style="color:#666666">&amp;&amp;</span> randof (<span style="color:#666666">5</span>) <span style="color:#666666">==</span> <span style="color:#666666">0</span>) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"I: (%s) simulating a crash</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, identity);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>msg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (cycles <span style="color:#666666">&gt;</span> <span style="color:#666666">3</span> <span style="color:#666666">&amp;&amp;</span> randof (<span style="color:#666666">5</span>) <span style="color:#666666">==</span> <span style="color:#666666">0</span>) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"I: (%s) simulating CPU overload</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, identity);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>sleep (<span style="color:#666666">3</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (zctx_interrupted)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"I: (%s) normal reply</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, identity);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>sleep (<span style="color:#666666">1</span>);<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Do some heavy work</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>msg, worker);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:spworker" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:spworker" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/clj:spworker" target="_blank">Clojure</a> | <a href="http://zguide.zeromq.org/dpr:spworker" target="_blank">Delphi</a> | <a href="http://zguide.zeromq.org/go:spworker" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:spworker" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:spworker" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:spworker" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:spworker" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/php:spworker" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:spworker" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/tcl:spworker" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | CL | Erlang | F# | Felix | Node.js | Objective-C | ooc | Perl | Q | Racket | Ruby | Scala</a></span>
<p>To test this, start a handful of workers, a Lazy Pirate client, and the queue, in any order. You'll see that the workers eventually all crash and burn, and the client retries and then gives up. The queue never stops, and you can restart workers and clients ad nauseam. This model works with any number of clients and workers.</p>
<p><a name="Robust-Reliable-Queuing-Paranoid-Pirate-Pattern"></a><a name="header-92"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc91"><span><a href="http://zguide.zeromq.org/page:all#Robust-Reliable-Queuing-Paranoid-Pirate-Pattern">Robust Reliable Queuing (Paranoid Pirate Pattern)</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-91">prev</a> <a href="http://zguide.zeromq.org/page:all#header-93">next</a></td>
</tr>
</tbody></table>
<p><strong>Figure 49 - The Paranoid Pirate Pattern</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig49.png" alt="fig49.png" class="image"></div>
<p>The Simple Pirate Queue pattern works pretty well, especially because it's just a combination of two existing patterns. Still, it does have some weaknesses:</p>
<ul>
<li>It's not robust in the face of a queue crash and restart. The client will recover, but the workers won't. While ZeroMQ will reconnect workers' sockets automatically, as far as the newly started queue is concerned, the workers haven't signaled ready, so don't exist. To fix this, we have to do heartbeating from queue to worker so that the worker can detect when the queue has gone away.</li>
</ul>
<ul>
<li>The queue does not detect worker failure, so if a worker dies while idle, the queue can't remove it from its worker queue until the queue sends it a request. The client waits and retries for nothing. It's not a critical problem, but it's not nice. To make this work properly, we do heartbeating from worker to queue, so that the queue can detect a lost worker at any stage.</li>
</ul>
<p>We'll fix these in a properly pedantic Paranoid Pirate Pattern.</p>
<p>We previously used a REQ socket for the worker. For the Paranoid Pirate worker, we'll switch to a DEALER socket. This has the advantage of letting us send and receive messages at any time, rather than the lock-step send/receive that REQ imposes. The downside of DEALER is that we have to do our own envelope management (re-read <a href="http://zguide.zeromq.org/page:all#advanced-request-reply">Chapter 3 - Advanced Request-Reply Patterns</a> for background on this concept).</p>
<p>We're still using the Lazy Pirate client. Here is the Paranoid Pirate queue proxy:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">ppqueue:&nbsp;Paranoid&nbsp;Pirate&nbsp;queue&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">ppqueue:&nbsp;Paranoid&nbsp;Pirate&nbsp;queue&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Paranoid Pirate queue</span></p>
<p>#include "czmq.h"<br>
#define HEARTBEAT_LIVENESS<tt><span style="white-space: pre-wrap;">  </span></tt>3<tt><span style="white-space: pre-wrap;">       </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>3-5 is reasonable</em></span><br>
<span style="color:#BC7A00">#define HEARTBEAT_INTERVAL<tt><span style="white-space: pre-wrap;">  </span></tt>1000<tt><span style="white-space: pre-wrap;">    </span></tt></span><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>msecs</em></span><br>
<span style="color:#BC7A00"><br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Paranoid Pirate Protocol constants<br>
#define PPP_READY<tt><span style="white-space: pre-wrap;">       </span></tt>"\001"<tt><span style="white-space: pre-wrap;">      </span></tt></span><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Signals worker is ready</em></span><br>
<span style="color:#BC7A00">#define PPP_HEARTBEAT<tt><span style="white-space: pre-wrap;">   </span></tt>"\002"<tt><span style="white-space: pre-wrap;">      </span></tt></span><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Signals worker heartbeat</em></span></p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Here we define the worker class; a structure and a set of functions that<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>act as constructor, destructor, and methods on worker objects:</span></span></p>
<p><span style="color:#008000"><strong>typedef</strong></span> <span style="color:#008000"><strong>struct</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zframe_t <span style="color:#666666">*</span>identity;<tt><span style="white-space: pre-wrap;">         </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Identity of worker</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>id_string;<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Printable identity</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int64_t</span> expiry;<tt><span style="white-space: pre-wrap;">             </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Expires at this time</em></span><br>
} worker_t;</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Construct new worker</em></span><br>
<span style="color:#008000"><strong>static</strong></span> worker_t <span style="color:#666666">*</span><br>
<span style="color:#0000FF">s_worker_new</span> (zframe_t <span style="color:#666666">*</span>identity)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>worker_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> (worker_t <span style="color:#666666">*</span>) zmalloc (<span style="color:#008000"><strong>sizeof</strong></span> (worker_t));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>identity <span style="color:#666666">=</span> identity;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>id_string <span style="color:#666666">=</span> zframe_strhex (identity);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>expiry <span style="color:#666666">=</span> zclock_time ()<br>
<tt><span style="white-space: pre-wrap;">                 </span></tt><span style="color:#666666">+</span> HEARTBEAT_INTERVAL <span style="color:#666666">*</span> HEARTBEAT_LIVENESS;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> self;<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Destroy specified worker object, including identity frame.</em></span><br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<span style="color:#0000FF">s_worker_destroy</span> (worker_t <span style="color:#666666"><span style="white-space: pre-wrap;">**</span></span>self_p)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self_p);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">*</span>self_p) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>worker_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> <span style="color:#666666">*</span>self_p;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_destroy (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>identity);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (self<span style="color:#666666">-&gt;</span>id_string);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (self);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#666666">*</span>self_p <span style="color:#666666">=</span> <span style="color:#008000">NULL</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The ready method puts a worker to the end of the ready list:</em></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<span style="color:#0000FF">s_worker_ready</span> (worker_t <span style="color:#666666">*</span>self, zlist_t <span style="color:#666666">*</span>workers)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>worker_t <span style="color:#666666">*</span>worker <span style="color:#666666">=</span> (worker_t <span style="color:#666666">*</span>) zlist_first (workers);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (worker) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (streq (self<span style="color:#666666">-&gt;</span>id_string, worker<span style="color:#666666">-&gt;</span>id_string)) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zlist_remove (workers, worker);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>s_worker_destroy (<span style="color:#666666">&amp;</span>worker);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>worker <span style="color:#666666">=</span> (worker_t <span style="color:#666666">*</span>) zlist_next (workers);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zlist_append (workers, self);<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The next method returns the next available worker identity:</em></span></p>
<p><span style="color:#008000"><strong>static</strong></span> zframe_t <span style="color:#666666">*</span><br>
<span style="color:#0000FF">s_workers_next</span> (zlist_t <span style="color:#666666">*</span>workers)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>worker_t <span style="color:#666666">*</span>worker <span style="color:#666666">=</span> zlist_pop (workers);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (worker);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zframe_t <span style="color:#666666">*</span>frame <span style="color:#666666">=</span> worker<span style="color:#666666">-&gt;</span>identity;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>worker<span style="color:#666666">-&gt;</span>identity <span style="color:#666666">=</span> <span style="color:#008000">NULL</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_worker_destroy (<span style="color:#666666">&amp;</span>worker);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> frame;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The purge method looks for and kills expired workers. We hold workers<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>from oldest to most recent, so we stop at the first alive worker:</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<span style="color:#0000FF">s_workers_purge</span> (zlist_t <span style="color:#666666">*</span>workers)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>worker_t <span style="color:#666666">*</span>worker <span style="color:#666666">=</span> (worker_t <span style="color:#666666">*</span>) zlist_first (workers);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (worker) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (zclock_time () <span style="color:#666666">&lt;</span> worker<span style="color:#666666">-&gt;</span>expiry)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Worker is alive, we're done here</em></span></p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt>zlist_remove (workers, worker);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>s_worker_destroy (<span style="color:#666666">&amp;</span>worker);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>worker <span style="color:#666666">=</span> (worker_t <span style="color:#666666">*</span>) zlist_first (workers);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The main task is a load-balancer with heartbeating on workers so we<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>can detect crashed or blocked worker tasks:</span></span></p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>frontend <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_ROUTER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>backend <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_ROUTER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (frontend, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5555"</span>);<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>For clients</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (backend,<tt><span style="white-space: pre-wrap;">  </span></tt><span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5556"</span>);<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>For workers</em></span></p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>List of available workers</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zlist_t <span style="color:#666666">*</span>workers <span style="color:#666666">=</span> zlist_new ();</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send out heartbeats at regular intervals</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">uint64_t</span> heartbeat_at <span style="color:#666666">=</span> zclock_time () <span style="color:#666666">+</span> HEARTBEAT_INTERVAL;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_pollitem_t items <span style="white-space: pre-wrap;">[]</span> <span style="color:#666666">=</span> {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>{ backend,<tt><span style="white-space: pre-wrap;">  </span></tt><span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> },<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>{ frontend, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> }<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Poll frontend only if we have available workers</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> rc <span style="color:#666666">=</span> zmq_poll (items, zlist_size (workers)<span style="color:#666666">?</span> <span style="color:#666666">2</span><span style="color:#666666">:</span> <span style="color:#666666">1</span>,<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>HEARTBEAT_INTERVAL <span style="color:#666666">*</span> ZMQ_POLL_MSEC);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (rc <span style="color:#666666">==</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span></p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Handle worker activity on backend</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Use worker identity for load-balancing</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_recv (backend);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>msg)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span></p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Any sign of life from worker means it's ready</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_t <span style="color:#666666">*</span>identity <span style="color:#666666">=</span> zmsg_unwrap (msg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>worker_t <span style="color:#666666">*</span>worker <span style="color:#666666">=</span> s_worker_new (identity);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>s_worker_ready (worker, workers);</p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Validate control message, or return reply to client</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (zmsg_size (msg) <span style="color:#666666">==</span> <span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zframe_t <span style="color:#666666">*</span>frame <span style="color:#666666">=</span> zmsg_first (msg);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>if</strong></span> (memcmp (zframe_data (frame), PPP_READY, <span style="color:#666666">1</span>)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#666666">&amp;&amp;</span><tt><span style="white-space: pre-wrap;">  </span></tt>memcmp (zframe_data (frame), PPP_HEARTBEAT, <span style="color:#666666">1</span>)) {<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>printf (<span style="color:#BA2121">"E: invalid message from worker"</span>);<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>zmsg_dump (msg);<br>
<tt><span style="white-space: pre-wrap;">                </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>msg);<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>msg, frontend);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Now get next client request, route to next worker</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_recv (frontend);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>msg)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_t <span style="color:#666666">*</span>identity <span style="color:#666666">=</span> s_workers_next (workers);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_prepend (msg, <span style="color:#666666">&amp;</span>identity);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>msg, backend);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We handle heartbeating after any socket activity. First, we send</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>heartbeats to any idle workers if it's time. Then, we purge any</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>dead workers:</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (zclock_time () <span style="color:#666666">&gt;=</span> heartbeat_at) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>worker_t <span style="color:#666666">*</span>worker <span style="color:#666666">=</span> (worker_t <span style="color:#666666">*</span>) zlist_first (workers);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>while</strong></span> (worker) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zframe_send (<span style="color:#666666">&amp;</span>worker<span style="color:#666666">-&gt;</span>identity, backend,<br>
<tt><span style="white-space: pre-wrap;">                             </span></tt>ZFRAME_REUSE <span style="color:#666666">+</span> ZFRAME_MORE);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zframe_t <span style="color:#666666">*</span>frame <span style="color:#666666">=</span> zframe_new (PPP_HEARTBEAT, <span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zframe_send (<span style="color:#666666">&amp;</span>frame, backend, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>worker <span style="color:#666666">=</span> (worker_t <span style="color:#666666">*</span>) zlist_next (workers);<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>heartbeat_at <span style="color:#666666">=</span> zclock_time () <span style="color:#666666">+</span> HEARTBEAT_INTERVAL;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>s_workers_purge (workers);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>When we're done, clean up properly</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (zlist_size (workers)) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>worker_t <span style="color:#666666">*</span>worker <span style="color:#666666">=</span> (worker_t <span style="color:#666666">*</span>) zlist_pop (workers);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>s_worker_destroy (<span style="color:#666666">&amp;</span>worker);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zlist_destroy (<span style="color:#666666">&amp;</span>workers);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:ppqueue" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:ppqueue" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/go:ppqueue" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:ppqueue" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:ppqueue" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:ppqueue" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:ppqueue" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/php:ppqueue" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:ppqueue" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/tcl:ppqueue" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | Clojure | CL | Delphi | Erlang | F# | Felix | Node.js | Objective-C | ooc | Perl | Q | Racket | Ruby | Scala</a></span>
<p>The queue extends the load balancing pattern with heartbeating of workers. Heartbeating is one of those "simple" things that can be difficult to get right. I'll explain more about that in a second.</p>
<p>Here is the Paranoid Pirate worker:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">ppworker:&nbsp;Paranoid&nbsp;Pirate&nbsp;worker&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">ppworker:&nbsp;Paranoid&nbsp;Pirate&nbsp;worker&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Paranoid Pirate worker</span></p>
<p>#include "czmq.h"<br>
#define HEARTBEAT_LIVENESS<tt><span style="white-space: pre-wrap;">  </span></tt>3<tt><span style="white-space: pre-wrap;">       </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>3-5 is reasonable</em></span><br>
<span style="color:#BC7A00">#define HEARTBEAT_INTERVAL<tt><span style="white-space: pre-wrap;">  </span></tt>1000<tt><span style="white-space: pre-wrap;">    </span></tt></span><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>msecs</em></span><br>
<span style="color:#BC7A00">#define INTERVAL_INIT<tt><span style="white-space: pre-wrap;">       </span></tt>1000<tt><span style="white-space: pre-wrap;">    </span></tt></span><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Initial reconnect</em></span><br>
<span style="color:#BC7A00">#define INTERVAL_MAX<tt><span style="white-space: pre-wrap;">       </span></tt>32000<tt><span style="white-space: pre-wrap;">    </span></tt></span><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>After exponential backoff</em></span><br>
<span style="color:#BC7A00"><br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Paranoid Pirate Protocol constants<br>
#define PPP_READY<tt><span style="white-space: pre-wrap;">       </span></tt>"\001"<tt><span style="white-space: pre-wrap;">      </span></tt></span><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Signals worker is ready</em></span><br>
<span style="color:#BC7A00">#define PPP_HEARTBEAT<tt><span style="white-space: pre-wrap;">   </span></tt>"\002"<tt><span style="white-space: pre-wrap;">      </span></tt></span><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Signals worker heartbeat</em></span></p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Helper function that returns a new configured socket<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>connected to the Paranoid Pirate queue</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span> <span style="color:#666666">*</span><br>
<span style="color:#0000FF">s_worker_socket</span> (zctx_t <span style="color:#666666">*</span>ctx) {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>worker <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_DEALER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect (worker, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5556"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Tell queue we're ready for work</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"I: worker ready</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zframe_t <span style="color:#666666">*</span>frame <span style="color:#666666">=</span> zframe_new (PPP_READY, <span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zframe_send (<span style="color:#666666">&amp;</span>frame, worker, <span style="color:#666666">0</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> worker;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We have a single task that implements the worker side of the<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Paranoid Pirate Protocol (PPP). The interesting parts here are<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>the heartbeating, which lets the worker detect if the queue has<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>died, and vice versa:</span></span></p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>worker <span style="color:#666666">=</span> s_worker_socket (ctx);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If liveness hits zero, queue is considered disconnected</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">size_t</span> liveness <span style="color:#666666">=</span> HEARTBEAT_LIVENESS;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">size_t</span> interval <span style="color:#666666">=</span> INTERVAL_INIT;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send out heartbeats at regular intervals</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">uint64_t</span> heartbeat_at <span style="color:#666666">=</span> zclock_time () <span style="color:#666666">+</span> HEARTBEAT_INTERVAL;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>srandom ((<span style="color:#B00040">unsigned</span>) time (<span style="color:#008000">NULL</span>));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> cycles <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_pollitem_t items <span style="white-space: pre-wrap;">[]</span> <span style="color:#666666">=</span> { { worker,<tt><span style="white-space: pre-wrap;">  </span></tt><span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> } };<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> rc <span style="color:#666666">=</span> zmq_poll (items, <span style="color:#666666">1</span>, HEARTBEAT_INTERVAL <span style="color:#666666">*</span> ZMQ_POLL_MSEC);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (rc <span style="color:#666666">==</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span></p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Get message</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>- 3-part envelope + content -&gt; request</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>- 1-part HEARTBEAT -&gt; heartbeat</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_recv (worker);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>msg)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span></p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>To test the robustness of the queue implementation we //</em><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>simulate various typical problems, such as the worker<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>crashing or running very slowly. We do this after a few<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>cycles so that the architecture can get up and running<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>first:<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (zmsg_size (msg) <span style="color:#666666">==</span> <span style="color:#666666">3</span>) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>cycles<span style="color:#666666">++</span>;<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>if</strong></span> (cycles <span style="color:#666666">&gt;</span> <span style="color:#666666">3</span> <span style="color:#666666">&amp;&amp;</span> randof (<span style="color:#666666">5</span>) <span style="color:#666666">==</span> <span style="color:#666666">0</span>) {<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>printf (<span style="color:#BA2121">"I: simulating a crash</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>msg);<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">                </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>if</strong></span> (cycles <span style="color:#666666">&gt;</span> <span style="color:#666666">3</span> <span style="color:#666666">&amp;&amp;</span> randof (<span style="color:#666666">5</span>) <span style="color:#666666">==</span> <span style="color:#666666">0</span>) {<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>printf (<span style="color:#BA2121">"I: simulating CPU overload</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>sleep (<span style="color:#666666">3</span>);<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt><span style="color:#008000"><strong>if</strong></span> (zctx_interrupted)<br>
<tt><span style="white-space: pre-wrap;">                        </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">                </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">                </span></tt>printf (<span style="color:#BA2121">"I: normal reply</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>msg, worker);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>liveness <span style="color:#666666">=</span> HEARTBEAT_LIVENESS;<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>sleep (<span style="color:#666666">1</span>);<tt><span style="white-space: pre-wrap;">              </span></tt><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Do some heavy work<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>if</strong></span> (zctx_interrupted)<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>When we get a heartbeat message from the queue, it means the<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>queue was (recently) alive, so we must reset our liveness<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>indicator:<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (zmsg_size (msg) <span style="color:#666666">==</span> <span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zframe_t <span style="color:#666666">*</span>frame <span style="color:#666666">=</span> zmsg_first (msg);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>if</strong></span> (memcmp (zframe_data (frame), PPP_HEARTBEAT, <span style="color:#666666">1</span>) <span style="color:#666666">==</span> <span style="color:#666666">0</span>)<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>liveness <span style="color:#666666">=</span> HEARTBEAT_LIVENESS;<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>else</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>printf (<span style="color:#BA2121">"E: invalid message</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>zmsg_dump (msg);<br>
<tt><span style="white-space: pre-wrap;">                </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>msg);<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>else</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>printf (<span style="color:#BA2121">"E: invalid message</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_dump (msg);<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>interval <span style="color:#666666">=</span> INTERVAL_INIT;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If the queue hasn't sent us heartbeats in a while, destroy the<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>socket and reconnect. This is the simplest most brutal way of<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>discarding any messages we might have sent in the meantime://</span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666"><span style="white-space: pre-wrap;">--</span></span>liveness <span style="color:#666666">==</span> <span style="color:#666666">0</span>) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"W: heartbeat failure, can't reach queue</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"W: reconnecting in %zd msec…</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, interval);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zclock_sleep (interval);</p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (interval <span style="color:#666666">&lt;</span> INTERVAL_MAX)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>interval <span style="color:#666666">*=</span> <span style="color:#666666">2</span>;<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zsocket_destroy (ctx, worker);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>worker <span style="color:#666666">=</span> s_worker_socket (ctx);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>liveness <span style="color:#666666">=</span> HEARTBEAT_LIVENESS;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send heartbeat to queue if it's time</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (zclock_time () <span style="color:#666666">&gt;</span> heartbeat_at) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>heartbeat_at <span style="color:#666666">=</span> zclock_time () <span style="color:#666666">+</span> HEARTBEAT_INTERVAL;<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"I: worker heartbeat</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_t <span style="color:#666666">*</span>frame <span style="color:#666666">=</span> zframe_new (PPP_HEARTBEAT, <span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_send (<span style="color:#666666">&amp;</span>frame, worker, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:ppworker" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:ppworker" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/go:ppworker" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:ppworker" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:ppworker" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:ppworker" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:ppworker" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/php:ppworker" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:ppworker" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/tcl:ppworker" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | Clojure | CL | Delphi | Erlang | F# | Felix | Node.js | Objective-C | ooc | Perl | Q | Racket | Ruby | Scala</a></span>
<p>Some comments about this example:</p>
<ul>
<li>The code includes simulation of failures, as before. This makes it (a) very hard to debug, and (b) dangerous to reuse. When you want to debug this, disable the failure simulation.</li>
</ul>
<ul>
<li>The worker uses a reconnect strategy similar to the one we designed for the Lazy Pirate client, with two major differences: (a) it does an exponential back-off, and (b) it retries indefinitely (whereas the client retries a few times before reporting a failure).</li>
</ul>
<p>Try the client, queue, and workers, such as by using a script like this:</p>
<div class="code">
<pre><code>ppqueue &amp;
for i in 1 2 3 4; do
    ppworker &amp;
    sleep 1
done
lpclient &amp;</code>
</pre></div>
<p>You should see the workers die one-by-one as they simulate a crash, and the client eventually give up. You can stop and restart the queue and both client and workers will reconnect and carry on. And no matter what you do to queues and workers, the client will never get an out-of-order reply: the whole chain either works, or the client abandons.</p>
<p><a name="Heartbeating"></a><a name="header-93"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc92"><span><a href="http://zguide.zeromq.org/page:all#Heartbeating">Heartbeating</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-92">prev</a> <a href="http://zguide.zeromq.org/page:all#header-94">next</a></td>
</tr>
</tbody></table>
<p>Heartbeating solves the problem of knowing whether a peer is alive or dead. This is not an issue specific to ZeroMQ. TCP has a long timeout (30 minutes or so), that means that it can be impossible to know whether a peer has died, been disconnected, or gone on a weekend to Prague with a case of vodka, a redhead, and a large expense account.</p>
<p>It's is not easy to get heartbeating right. When writing the Paranoid Pirate examples, it took about five hours to get the heartbeating working properly. The rest of the request-reply chain took perhaps ten minutes. It is especially easy to create "false failures", i.e., when peers decide that they are disconnected because the heartbeats aren't sent properly.</p>
<p>We'll look at the three main answers people use for heartbeating with ZeroMQ.</p>
<p><a name="Shrugging-It-Off"></a><a name="header-94"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc93"><span><a href="http://zguide.zeromq.org/page:all#Shrugging-It-Off">Shrugging It Off</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-93">prev</a> <a href="http://zguide.zeromq.org/page:all#header-95">next</a></td>
</tr>
</tbody></table>
<p>The most common approach is to do no heartbeating at all and hope for the best. Many if not most ZeroMQ applications do this. ZeroMQ encourages this by hiding peers in many cases. What problems does this approach cause?</p>
<ul>
<li>When we use a ROUTER socket in an application that tracks peers, as peers disconnect and reconnect, the application will leak memory (resources that the application holds for each peer) and get slower and slower.</li>
</ul>
<ul>
<li>When we use SUB- or DEALER-based data recipients, we can't tell the difference between good silence (there's no data) and bad silence (the other end died). When a recipient knows the other side died, it can for example switch over to a backup route.</li>
</ul>
<ul>
<li>If we use a TCP connection that stays silent for a long while, it will, in some networks, just die. Sending something (technically, a "keep-alive" more than a heartbeat), will keep the network alive.</li>
</ul>
<p><a name="One-Way-Heartbeats"></a><a name="header-95"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc94"><span><a href="http://zguide.zeromq.org/page:all#One-Way-Heartbeats">One-Way Heartbeats</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-94">prev</a> <a href="http://zguide.zeromq.org/page:all#header-96">next</a></td>
</tr>
</tbody></table>
<p>A second option is to send a heartbeat message from each node to its peers every second or so. When one node hears nothing from another within some timeout (several seconds, typically), it will treat that peer as dead. Sounds good, right? Sadly, no. This works in some cases but has nasty edge cases in others.</p>
<p>For pub-sub, this does work, and it's the only model you can use. SUB sockets cannot talk back to PUB sockets, but PUB sockets can happily send "I'm alive" messages to their subscribers.</p>
<p>As an optimization, you can send heartbeats only when there is no real data to send. Furthermore, you can send heartbeats progressively slower and slower, if network activity is an issue (e.g., on mobile networks where activity drains the battery). As long as the recipient can detect a failure (sharp stop in activity), that's fine.</p>
<p>Here are the typical problems with this design:</p>
<ul>
<li>It can be inaccurate when we send large amounts of data, as heartbeats will be delayed behind that data. If heartbeats are delayed, you can get false timeouts and disconnections due to network congestion. Thus, always treat <em>any</em> incoming data as a heartbeat, whether or not the sender optimizes out heartbeats.</li>
</ul>
<ul>
<li>While the pub-sub pattern will drop messages for disappeared recipients, PUSH and DEALER sockets will queue them. So if you send heartbeats to a dead peer and it comes back, it will get all the heartbeats you sent, which can be thousands. Whoa, whoa!</li>
</ul>
<ul>
<li>This design assumes that heartbeat timeouts are the same across the whole network. But that won't be accurate. Some peers will want very aggressive heartbeating in order to detect faults rapidly. And some will want very relaxed heartbeating, in order to let sleeping networks lie and save power.</li>
</ul>
<p><a name="Ping-Pong-Heartbeats"></a><a name="header-96"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc95"><span><a href="http://zguide.zeromq.org/page:all#Ping-Pong-Heartbeats">Ping-Pong Heartbeats</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-95">prev</a> <a href="http://zguide.zeromq.org/page:all#header-97">next</a></td>
</tr>
</tbody></table>
<p>The third option is to use a ping-pong dialog. One peer sends a ping command to the other, which replies with a pong command. Neither command has any payload. Pings and pongs are not correlated. Because the roles of "client" and "server" are arbitrary in some networks, we usually specify that either peer can in fact send a ping and expect a pong in response. However, because the timeouts depend on network topologies known best to dynamic clients, it is usually the client that pings the server.</p>
<p>This works for all ROUTER-based brokers. The same optimizations we used in the second model make this work even better: treat any incoming data as a pong, and only send a ping when not otherwise sending data.</p>
<p><a name="Heartbeating-for-Paranoid-Pirate"></a><a name="header-97"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc96"><span><a href="http://zguide.zeromq.org/page:all#Heartbeating-for-Paranoid-Pirate">Heartbeating for Paranoid Pirate</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-96">prev</a> <a href="http://zguide.zeromq.org/page:all#header-98">next</a></td>
</tr>
</tbody></table>
<p>For Paranoid Pirate, we chose the second approach. It might not have been the simplest option: if designing this today, I'd probably try a ping-pong approach instead. However the principles are similar. The heartbeat messages flow asynchronously in both directions, and either peer can decide the other is "dead" and stop talking to it.</p>
<p>In the worker, this is how we handle heartbeats from the queue:</p>
<ul>
<li>We calculate a <em>liveness</em>, which is how many heartbeats we can still miss before deciding the queue is dead. It starts at three and we decrement it each time we miss a heartbeat.</li>
<li>We wait, in the <tt>zmq_poll</tt> loop, for one second each time, which is our heartbeat interval.</li>
<li>If there's any message from the queue during that time, we reset our liveness to three.</li>
<li>If there's no message during that time, we count down our liveness.</li>
<li>If the liveness reaches zero, we consider the queue dead.</li>
<li>If the queue is dead, we destroy our socket, create a new one, and reconnect.</li>
<li>To avoid opening and closing too many sockets, we wait for a certain interval before reconnecting, and we double the interval each time until it reaches 32 seconds.</li>
</ul>
<p>And this is how we handle heartbeats <em>to</em> the queue:</p>
<ul>
<li>We calculate when to send the next heartbeat; this is a single variable because we're talking to one peer, the queue.</li>
<li>In the <tt>zmq_poll</tt> loop, whenever we pass this time, we send a heartbeat to the queue.</li>
</ul>
<p>Here's the essential heartbeating code for the worker:</p>
<div class="code">
<p><span style="color:#BC7A00">#define HEARTBEAT_LIVENESS<tt><span style="white-space: pre-wrap;">  </span></tt>3<tt><span style="white-space: pre-wrap;">       </span></tt></span><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>3-5 is reasonable</em></span><br>
<span style="color:#BC7A00">#define HEARTBEAT_INTERVAL<tt><span style="white-space: pre-wrap;">  </span></tt>1000<tt><span style="white-space: pre-wrap;">    </span></tt></span><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>msecs</em></span><br>
<span style="color:#BC7A00">#define INTERVAL_INIT<tt><span style="white-space: pre-wrap;">       </span></tt>1000<tt><span style="white-space: pre-wrap;">    </span></tt></span><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Initial reconnect</em></span><br>
<span style="color:#BC7A00">#define INTERVAL_MAX<tt><span style="white-space: pre-wrap;">       </span></tt>32000<tt><span style="white-space: pre-wrap;">    </span></tt></span><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>After exponential backoff</em></span></p>
<p>…<br>
<span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If liveness hits zero, queue is considered disconnected</em></span><br>
<span style="color:#B00040">size_t</span> liveness <span style="color:#666666">=</span> HEARTBEAT_LIVENESS;<br>
<span style="color:#B00040">size_t</span> interval <span style="color:#666666">=</span> INTERVAL_INIT;</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send out heartbeats at regular intervals</em></span><br>
<span style="color:#B00040">uint64_t</span> heartbeat_at <span style="color:#666666">=</span> zclock_time () <span style="color:#666666">+</span> HEARTBEAT_INTERVAL;</p>
<p><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_pollitem_t items <span style="white-space: pre-wrap;">[]</span> <span style="color:#666666">=</span> { { worker,<tt><span style="white-space: pre-wrap;">  </span></tt><span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> } };<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> rc <span style="color:#666666">=</span> zmq_poll (items, <span style="color:#666666">1</span>, HEARTBEAT_INTERVAL <span style="color:#666666">*</span> ZMQ_POLL_MSEC);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Receive any message from queue</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>liveness <span style="color:#666666">=</span> HEARTBEAT_LIVENESS;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>interval <span style="color:#666666">=</span> INTERVAL_INIT;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666"><span style="white-space: pre-wrap;">--</span></span>liveness <span style="color:#666666">==</span> <span style="color:#666666">0</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zclock_sleep (interval);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (interval <span style="color:#666666">&lt;</span> INTERVAL_MAX)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>interval <span style="color:#666666">*=</span> <span style="color:#666666">2</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zsocket_destroy (ctx, worker);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>…<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>liveness <span style="color:#666666">=</span> HEARTBEAT_LIVENESS;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send heartbeat to queue if it's time</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (zclock_time () <span style="color:#666666">&gt;</span> heartbeat_at) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>heartbeat_at <span style="color:#666666">=</span> zclock_time () <span style="color:#666666">+</span> HEARTBEAT_INTERVAL;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send heartbeat message to queue</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
}</p>
</div>
<p>The queue does the same, but manages an expiration time for each worker.</p>
<p>Here are some tips for your own heartbeating implementation:</p>
<ul>
<li>Use <tt>zmq_poll</tt> or a reactor as the core of your application's main task.</li>
</ul>
<ul>
<li>Start by building the heartbeating between peers, test it by simulating failures, and <em>then</em> build the rest of the message flow. Adding heartbeating afterwards is much trickier.</li>
</ul>
<ul>
<li>Use simple tracing, i.e., print to console, to get this working. To help you trace the flow of messages between peers, use a dump method such as zmsg offers, and number your messages incrementally so you can see if there are gaps.</li>
</ul>
<ul>
<li>In a real application, heartbeating must be configurable and usually negotiated with the peer. Some peers will want aggressive heartbeating, as low as 10 msecs. Other peers will be far away and want heartbeating as high as 30 seconds.</li>
</ul>
<ul>
<li>If you have different heartbeat intervals for different peers, your poll timeout should be the lowest (shortest time) of these. Do not use an infinite timeout.</li>
</ul>
<ul>
<li>Do heartbeating on the same socket you use for messages, so your heartbeats also act as a <em>keep-alive</em> to stop the network connection from going stale (some firewalls can be unkind to silent connections).</li>
</ul>
<p><a name="Contracts-and-Protocols"></a><a name="header-98"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc97"><span><a href="http://zguide.zeromq.org/page:all#Contracts-and-Protocols">Contracts and Protocols</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-97">prev</a> <a href="http://zguide.zeromq.org/page:all#header-99">next</a></td>
</tr>
</tbody></table>
<p>If you're paying attention, you'll realize that Paranoid Pirate is not interoperable with Simple Pirate, because of the heartbeats. But how do we define "interoperable"? To guarantee interoperability, we need a kind of contract, an agreement that lets different teams in different times and places write code that is guaranteed to work together. We call this a "protocol".</p>
<p>It's fun to experiment without specifications, but that's not a sensible basis for real applications. What happens if we want to write a worker in another language? Do we have to read code to see how things work? What if we want to change the protocol for some reason? Even a simple protocol will, if it's successful, evolve and become more complex.</p>
<p>Lack of contracts is a sure sign of a disposable application. So let's write a contract for this protocol. How do we do that?</p>
<p>There's a wiki at <a href="http://rfc.zeromq.org/">rfc.zeromq.org</a> that we made especially as a home for public ZeroMQ contracts.<br>
To create a new specification, register on the wiki if needed, and follow the instructions. It's fairly straightforward, though writing technical texts is not everyone's cup of tea.</p>
<p>It took me about fifteen minutes to draft the new <a href="http://rfc.zeromq.org/spec:6">Pirate Pattern Protocol</a>. It's not a big specification, but it does capture enough to act as the basis for arguments ("your queue isn't PPP compatible; please fix it!").</p>
<p>Turning PPP into a real protocol would take more work:</p>
<ul>
<li>There should be a protocol version number in the READY command so that it's possible to distinguish between different versions of PPP.</li>
</ul>
<ul>
<li>Right now, READY and HEARTBEAT are not entirely distinct from requests and replies. To make them distinct, we would need a message structure that includes a "message type" part.</li>
</ul>
<p><a name="Service-Oriented-Reliable-Queuing-Majordomo-Pattern"></a><a name="header-99"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc98"><span><a href="http://zguide.zeromq.org/page:all#Service-Oriented-Reliable-Queuing-Majordomo-Pattern">Service-Oriented Reliable Queuing (Majordomo Pattern)</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-98">prev</a> <a href="http://zguide.zeromq.org/page:all#header-100">next</a></td>
</tr>
</tbody></table>
<p><strong>Figure 50 - The Majordomo Pattern</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig50.png" alt="fig50.png" class="image"></div>
<p>The nice thing about progress is how fast it happens when lawyers and committees aren't involved. The <a href="http://rfc.zeromq.org/spec:7">one-page MDP specification</a> turns PPP into something more solid. This is how we should design complex architectures: start by writing down the contracts, and only <em>then</em> write software to implement them.</p>
<p>The Majordomo Protocol (MDP) extends and improves on PPP in one interesting way: it adds a "service name" to requests that the client sends, and asks workers to register for specific services. Adding service names turns our Paranoid Pirate queue into a service-oriented broker. The nice thing about MDP is that it came out of working code, a simpler ancestor protocol (PPP), and a precise set of improvements that each solved a clear problem. This made it easy to draft.</p>
<p>To implement Majordomo, we need to write a framework for clients and workers. It's really not sane to ask every application developer to read the spec and make it work, when they could be using a simpler API that does the work for them.</p>
<p>So while our first contract (MDP itself) defines how the pieces of our distributed architecture talk to each other, our second contract defines how user applications talk to the technical framework we're going to design.</p>
<p>Majordomo has two halves, a client side and a worker side. Because we'll write both client and worker applications, we will need two APIs. Here is a sketch for the client API, using a simple object-oriented approach:</p>
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Majordomo Protocol client example<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Uses the mdcli API to hide all MDP aspects</span></p>
<p><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Lets us build this source without creating a library<br>
#include "mdcliapi.c"</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">int</span> argc, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>argv <span style="white-space: pre-wrap;">[]</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> verbose <span style="color:#666666">=</span> (argc <span style="color:#666666">&gt;</span> <span style="color:#666666">1</span> <span style="color:#666666">&amp;&amp;</span> streq (argv <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>, <span style="color:#BA2121">"-v"</span>));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>mdcli_t <span style="color:#666666">*</span>session <span style="color:#666666">=</span> mdcli_new (<span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5555"</span>, verbose);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> count;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (count <span style="color:#666666">=</span> <span style="color:#666666">0</span>; count <span style="color:#666666">&lt;</span> <span style="color:#666666">100000</span>; count<span style="color:#666666">++</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_t <span style="color:#666666">*</span>request <span style="color:#666666">=</span> zmsg_new ();<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_pushstr (request, <span style="color:#BA2121">"Hello world"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_t <span style="color:#666666">*</span>reply <span style="color:#666666">=</span> mdcli_send (session, <span style="color:#BA2121">"echo"</span>, <span style="color:#666666">&amp;</span>request);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (reply)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>reply);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupt or failure</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"%d requests/replies processed</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, count);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>mdcli_destroy (<span style="color:#666666">&amp;</span>session);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
<p>That's it. We open a session to the broker, send a request message, get a reply message back, and eventually close the connection. Here's a sketch for the worker API:</p>
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Majordomo Protocol worker example<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Uses the mdwrk API to hide all MDP aspects</span></p>
<p><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Lets us build this source without creating a library<br>
#include "mdwrkapi.c"</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">int</span> argc, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>argv <span style="white-space: pre-wrap;">[]</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> verbose <span style="color:#666666">=</span> (argc <span style="color:#666666">&gt;</span> <span style="color:#666666">1</span> <span style="color:#666666">&amp;&amp;</span> streq (argv <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>, <span style="color:#BA2121">"-v"</span>));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>mdwrk_t <span style="color:#666666">*</span>session <span style="color:#666666">=</span> mdwrk_new (<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5555"</span>, <span style="color:#BA2121">"echo"</span>, verbose);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>reply <span style="color:#666666">=</span> <span style="color:#008000">NULL</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_t <span style="color:#666666">*</span>request <span style="color:#666666">=</span> mdwrk_recv (session, <span style="color:#666666">&amp;</span>reply);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (request <span style="color:#666666">==</span> <span style="color:#008000">NULL</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Worker was interrupted</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>reply <span style="color:#666666">=</span> request;<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Echo is complex… :-)</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>mdwrk_destroy (<span style="color:#666666">&amp;</span>session);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
<p>It's more or less symmetrical, but the worker dialog is a little different. The first time a worker does a recv(), it passes a null reply. Thereafter, it passes the current reply, and gets a new request.</p>
<p>The client and worker APIs were fairly simple to construct because they're heavily based on the Paranoid Pirate code we already developed. Here is the client API:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">mdcliapi:&nbsp;Majordomo&nbsp;client&nbsp;API&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">mdcliapi:&nbsp;Majordomo&nbsp;client&nbsp;API&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>mdcliapi class - Majordomo Protocol Client API<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Implements the MDP/Worker spec at http:<span style="white-space: pre-wrap;">//</span>rfc.zeromq.org/spec:7.</span></p>
<p>#include "mdcliapi.h"</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Structure of our class<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We access these properties only via class methods</span></span></p>
<p><span style="color:#008000"><strong>struct</strong></span> _mdcli_t {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx;<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Our context</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>broker;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>client;<tt><span style="white-space: pre-wrap;">               </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Socket to broker</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> verbose;<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Print activity to stdout</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> timeout;<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Request timeout</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> retries;<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Request retries</em></span><br>
};</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Connect or reconnect to broker</em></span></p>
<p><span style="color:#B00040">void</span> <span style="color:#0000FF">s_mdcli_connect_to_broker</span> (mdcli_t <span style="color:#666666">*</span>self)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>client)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zsocket_destroy (self<span style="color:#666666">-&gt;</span>ctx, self<span style="color:#666666">-&gt;</span>client);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>client <span style="color:#666666">=</span> zsocket_new (self<span style="color:#666666">-&gt;</span>ctx, ZMQ_REQ);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_connect (self<span style="color:#666666">-&gt;</span>client, self<span style="color:#666666">-&gt;</span>broker);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>verbose)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zclock_log (<span style="color:#BA2121">"I: connecting to broker at %s…"</span>, self<span style="color:#666666">-&gt;</span>broker);<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Here we have the constructor and destructor for our class:</em></span></p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Constructor</em></span></p>
<p>mdcli_t <span style="color:#666666">*</span><br>
<span style="color:#0000FF">mdcli_new</span> (<span style="color:#B00040">char</span> <span style="color:#666666">*</span>broker, <span style="color:#B00040">int</span> verbose)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (broker);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>mdcli_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> (mdcli_t <span style="color:#666666">*</span>) zmalloc (<span style="color:#008000"><strong>sizeof</strong></span> (mdcli_t));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>broker <span style="color:#666666">=</span> strdup (broker);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>verbose <span style="color:#666666">=</span> verbose;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>timeout <span style="color:#666666">=</span> <span style="color:#666666">2500</span>;<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>msecs</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>retries <span style="color:#666666">=</span> <span style="color:#666666">3</span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Before we abandon</em></span></p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>s_mdcli_connect_to_broker (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> self;<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Destructor</em></span></p>
<p><span style="color:#B00040">void</span><br>
<span style="color:#0000FF">mdcli_destroy</span> (mdcli_t <span style="color:#666666"><span style="white-space: pre-wrap;">**</span></span>self_p)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self_p);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">*</span>self_p) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>mdcli_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> <span style="color:#666666">*</span>self_p;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (self<span style="color:#666666">-&gt;</span>broker);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (self);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#666666">*</span>self_p <span style="color:#666666">=</span> <span style="color:#008000">NULL</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>These are the class methods. We can set the request timeout and number<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>of retry attempts before sending requests:</span></span></p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Set request timeout</em></span></p>
<p><span style="color:#B00040">void</span><br>
<span style="color:#0000FF">mdcli_set_timeout</span> (mdcli_t <span style="color:#666666">*</span>self, <span style="color:#B00040">int</span> timeout)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>timeout <span style="color:#666666">=</span> timeout;<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Set request retries</em></span></p>
<p><span style="color:#B00040">void</span><br>
<span style="color:#0000FF">mdcli_set_retries</span> (mdcli_t <span style="color:#666666">*</span>self, <span style="color:#B00040">int</span> retries)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>retries <span style="color:#666666">=</span> retries;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Here is the <tt>send</tt> method. It sends a request to the broker and gets<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>a reply even if it has to retry several times. It takes ownership of<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>the request message, and destroys it when sent. It returns the reply<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>message, or NULL if there was no reply after multiple attempts:</span></span></p>
<p>zmsg_t <span style="color:#666666">*</span><br>
<span style="color:#0000FF">mdcli_send</span> (mdcli_t <span style="color:#666666">*</span>self, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>service, zmsg_t <span style="color:#666666"><span style="white-space: pre-wrap;">**</span></span>request_p)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (request_p);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>request <span style="color:#666666">=</span> <span style="color:#666666">*</span>request_p;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Prefix request with protocol frames</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Frame 1: "MDPCxy" (six bytes, MDP/Client x.y)</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Frame 2: Service name (printable string)</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_pushstr (request, service);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_pushstr (request, MDPC_CLIENT);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>verbose) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zclock_log (<span style="color:#BA2121">"I: send request to '%s' service:"</span>, service);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_dump (request);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> retries_left <span style="color:#666666">=</span> self<span style="color:#666666">-&gt;</span>retries;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (retries_left <span style="color:#666666">&amp;&amp;</span> <span style="color:#666666">!</span>zctx_interrupted) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_dup (request);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>msg, self<span style="color:#666666">-&gt;</span>client);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt>zmq_pollitem_t items <span style="white-space: pre-wrap;">[]</span> <span style="color:#666666">=</span> {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>{ self<span style="color:#666666">-&gt;</span>client, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> }<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>On any blocking call, <tt>libzmq</tt> will return -1 if there was</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>an error; we could in theory check for different error codes,</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>but in practice it's OK to assume it was <tt>EINTR</tt> (Ctrl-C):</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> rc <span style="color:#666666">=</span> zmq_poll (items, <span style="color:#666666">1</span>, self<span style="color:#666666">-&gt;</span>timeout <span style="color:#666666">*</span> ZMQ_POLL_MSEC);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (rc <span style="color:#666666">==</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span></p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If we got a reply, process it</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_recv (self<span style="color:#666666">-&gt;</span>client);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>verbose) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zclock_log (<span style="color:#BA2121">"I: received reply:"</span>);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_dump (msg);<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We would handle malformed replies better in real code</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>assert (zmsg_size (msg) <span style="color:#666666">&gt;=</span> <span style="color:#666666">3</span>);</p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt>zframe_t <span style="color:#666666">*</span>header <span style="color:#666666">=</span> zmsg_pop (msg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>assert (zframe_streq (header, MDPC_CLIENT));<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_destroy (<span style="color:#666666">&amp;</span>header);</p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt>zframe_t <span style="color:#666666">*</span>reply_service <span style="color:#666666">=</span> zmsg_pop (msg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>assert (zframe_streq (reply_service, service));<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_destroy (<span style="color:#666666">&amp;</span>reply_service);</p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>request);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>return</strong></span> msg;<tt><span style="white-space: pre-wrap;">     </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Success</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666"><span style="white-space: pre-wrap;">--</span></span>retries_left) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>verbose)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zclock_log (<span style="color:#BA2121">"W: no reply, reconnecting…"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>s_mdcli_connect_to_broker (self);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>verbose)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zclock_log (<span style="color:#BA2121">"W: permanent error, abandoning"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Give up</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (zctx_interrupted)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"W: interrupt received, killing client…</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>request);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#008000">NULL</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cs:mdcliapi" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/go:mdcliapi" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hx:mdcliapi" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:mdcliapi" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:mdcliapi" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/php:mdcliapi" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:mdcliapi" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/tcl:mdcliapi" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | Clojure | CL | Delphi | Erlang | F# | Felix | Haskell | Node.js | Objective-C | ooc | Perl | Q | Racket | Ruby | Scala</a></span>
<p>Let's see how the client API looks in action, with an example test program that does 100K request-reply cycles:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">mdclient:&nbsp;Majordomo&nbsp;client&nbsp;application&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">mdclient:&nbsp;Majordomo&nbsp;client&nbsp;application&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Majordomo Protocol client example<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Uses the mdcli API to hide all MDP aspects</span></p>
<p><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Lets us build this source without creating a library<br>
#include "mdcliapi.c"</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">int</span> argc, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>argv <span style="white-space: pre-wrap;">[]</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> verbose <span style="color:#666666">=</span> (argc <span style="color:#666666">&gt;</span> <span style="color:#666666">1</span> <span style="color:#666666">&amp;&amp;</span> streq (argv <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>, <span style="color:#BA2121">"-v"</span>));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>mdcli_t <span style="color:#666666">*</span>session <span style="color:#666666">=</span> mdcli_new (<span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5555"</span>, verbose);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> count;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (count <span style="color:#666666">=</span> <span style="color:#666666">0</span>; count <span style="color:#666666">&lt;</span> <span style="color:#666666">100000</span>; count<span style="color:#666666">++</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_t <span style="color:#666666">*</span>request <span style="color:#666666">=</span> zmsg_new ();<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_pushstr (request, <span style="color:#BA2121">"Hello world"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_t <span style="color:#666666">*</span>reply <span style="color:#666666">=</span> mdcli_send (session, <span style="color:#BA2121">"echo"</span>, <span style="color:#666666">&amp;</span>request);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (reply)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>reply);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupt or failure</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"%d requests/replies processed</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, count);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>mdcli_destroy (<span style="color:#666666">&amp;</span>session);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:mdclient" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:mdclient" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/go:mdclient" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:mdclient" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:mdclient" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:mdclient" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:mdclient" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/php:mdclient" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:mdclient" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/tcl:mdclient" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | Clojure | CL | Delphi | Erlang | F# | Felix | Node.js | Objective-C | ooc | Perl | Q | Racket | Ruby | Scala</a></span>
<p>And here is the worker API:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">mdwrkapi:&nbsp;Majordomo&nbsp;worker&nbsp;API&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">mdwrkapi:&nbsp;Majordomo&nbsp;worker&nbsp;API&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>mdwrkapi class - Majordomo Protocol Worker API<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Implements the MDP/Worker spec at http:<span style="white-space: pre-wrap;">//</span>rfc.zeromq.org/spec:7.</span></p>
<p>#include "mdwrkapi.h"</p>
<p><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Reliability parameters<br>
#define HEARTBEAT_LIVENESS<tt><span style="white-space: pre-wrap;">  </span></tt>3<tt><span style="white-space: pre-wrap;">       </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>3-5 is reasonable</em></span></p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This is the structure of a worker API instance. We use a pseudo-OO<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>approach in a lot of the C examples, as well as the CZMQ binding:</span></span></p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Structure of our class<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We access these properties only via class methods</span></span></p>
<p><span style="color:#008000"><strong>struct</strong></span> _mdwrk_t {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx;<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Our context</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>broker;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>service;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>worker;<tt><span style="white-space: pre-wrap;">               </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Socket to broker</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> verbose;<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Print activity to stdout</em></span></p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Heartbeat management</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">uint64_t</span> heartbeat_at;<tt><span style="white-space: pre-wrap;">      </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>When to send HEARTBEAT</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">size_t</span> liveness;<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>How many attempts left</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> heartbeat;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Heartbeat delay, msecs</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> reconnect;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Reconnect delay, msecs</em></span></p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> expect_reply;<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Zero only at start</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zframe_t <span style="color:#666666">*</span>reply_to;<tt><span style="white-space: pre-wrap;">         </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Return identity, if any</em></span><br>
};</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We have two utility functions; to send a message to the broker and<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>to (re)connect to the broker:</span></span></p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send message to broker<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If no msg is provided, creates one internally</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<span style="color:#0000FF">s_mdwrk_send_to_broker</span> (mdwrk_t <span style="color:#666666">*</span>self, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>command, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>option,<br>
<tt><span style="white-space: pre-wrap;">                        </span></tt>zmsg_t <span style="color:#666666">*</span>msg)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>msg <span style="color:#666666">=</span> msg<span style="color:#666666">?</span> zmsg_dup (msg)<span style="color:#666666">:</span> zmsg_new ();</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Stack protocol envelope to start of message</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (option)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_pushstr (msg, option);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_pushstr (msg, command);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_pushstr (msg, MDPW_WORKER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_pushstr (msg, <span style="color:#BA2121">""</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>verbose) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zclock_log (<span style="color:#BA2121">"I: sending %s to broker"</span>,<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>mdps_commands <span style="white-space: pre-wrap;">[</span>(<span style="color:#B00040">int</span>) <span style="color:#666666">*</span>command<span style="white-space: pre-wrap;">]</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_dump (msg);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>msg, self<span style="color:#666666">-&gt;</span>worker);<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Connect or reconnect to broker</em></span></p>
<p><span style="color:#B00040">void</span> <span style="color:#0000FF">s_mdwrk_connect_to_broker</span> (mdwrk_t <span style="color:#666666">*</span>self)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>worker)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zsocket_destroy (self<span style="color:#666666">-&gt;</span>ctx, self<span style="color:#666666">-&gt;</span>worker);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>worker <span style="color:#666666">=</span> zsocket_new (self<span style="color:#666666">-&gt;</span>ctx, ZMQ_DEALER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_connect (self<span style="color:#666666">-&gt;</span>worker, self<span style="color:#666666">-&gt;</span>broker);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>verbose)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zclock_log (<span style="color:#BA2121">"I: connecting to broker at %s…"</span>, self<span style="color:#666666">-&gt;</span>broker);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Register service with broker</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_mdwrk_send_to_broker (self, MDPW_READY, self<span style="color:#666666">-&gt;</span>service, <span style="color:#008000">NULL</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If liveness hits zero, queue is considered disconnected</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>liveness <span style="color:#666666">=</span> HEARTBEAT_LIVENESS;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>heartbeat_at <span style="color:#666666">=</span> zclock_time () <span style="color:#666666">+</span> self<span style="color:#666666">-&gt;</span>heartbeat;<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Here we have the constructor and destructor for our mdwrk class:</em></span></p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Constructor</em></span></p>
<p>mdwrk_t <span style="color:#666666">*</span><br>
<span style="color:#0000FF">mdwrk_new</span> (<span style="color:#B00040">char</span> <span style="color:#666666">*</span>broker,<span style="color:#B00040">char</span> <span style="color:#666666">*</span>service, <span style="color:#B00040">int</span> verbose)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (broker);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (service);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>mdwrk_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> (mdwrk_t <span style="color:#666666">*</span>) zmalloc (<span style="color:#008000"><strong>sizeof</strong></span> (mdwrk_t));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>broker <span style="color:#666666">=</span> strdup (broker);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>service <span style="color:#666666">=</span> strdup (service);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>verbose <span style="color:#666666">=</span> verbose;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>heartbeat <span style="color:#666666">=</span> <span style="color:#666666">2500</span>;<tt><span style="white-space: pre-wrap;">     </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>msecs</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>reconnect <span style="color:#666666">=</span> <span style="color:#666666">2500</span>;<tt><span style="white-space: pre-wrap;">     </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>msecs</em></span></p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>s_mdwrk_connect_to_broker (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> self;<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Destructor</em></span></p>
<p><span style="color:#B00040">void</span><br>
<span style="color:#0000FF">mdwrk_destroy</span> (mdwrk_t <span style="color:#666666"><span style="white-space: pre-wrap;">**</span></span>self_p)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self_p);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">*</span>self_p) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>mdwrk_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> <span style="color:#666666">*</span>self_p;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (self<span style="color:#666666">-&gt;</span>broker);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (self<span style="color:#666666">-&gt;</span>service);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (self);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#666666">*</span>self_p <span style="color:#666666">=</span> <span style="color:#008000">NULL</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We provide two methods to configure the worker API. You can set the<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>heartbeat interval and retries to match the expected network performance.</span></span></p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Set heartbeat delay</em></span></p>
<p><span style="color:#B00040">void</span><br>
<span style="color:#0000FF">mdwrk_set_heartbeat</span> (mdwrk_t <span style="color:#666666">*</span>self, <span style="color:#B00040">int</span> heartbeat)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>heartbeat <span style="color:#666666">=</span> heartbeat;<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Set reconnect delay</em></span></p>
<p><span style="color:#B00040">void</span><br>
<span style="color:#0000FF">mdwrk_set_reconnect</span> (mdwrk_t <span style="color:#666666">*</span>self, <span style="color:#B00040">int</span> reconnect)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>reconnect <span style="color:#666666">=</span> reconnect;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This is the <tt>recv</tt> method; it's a little misnamed because it first sends<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>any reply and then waits for a new request. If you have a better name<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>for this, let me know.</span></span></p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send reply, if any, to broker and wait for next request.</em></span></p>
<p>zmsg_t <span style="color:#666666">*</span><br>
<span style="color:#0000FF">mdwrk_recv</span> (mdwrk_t <span style="color:#666666">*</span>self, zmsg_t <span style="color:#666666"><span style="white-space: pre-wrap;">**</span></span>reply_p)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Format and send the reply if we were provided one</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (reply_p);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>reply <span style="color:#666666">=</span> <span style="color:#666666">*</span>reply_p;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (reply <span style="color:#666666">||</span> <span style="color:#666666">!</span>self<span style="color:#666666">-&gt;</span>expect_reply);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (reply) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>assert (self<span style="color:#666666">-&gt;</span>reply_to);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_wrap (reply, self<span style="color:#666666">-&gt;</span>reply_to);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>s_mdwrk_send_to_broker (self, MDPW_REPLY, <span style="color:#008000">NULL</span>, reply);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_destroy (reply_p);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>expect_reply <span style="color:#666666">=</span> <span style="color:#666666">1</span>;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_pollitem_t items <span style="white-space: pre-wrap;">[]</span> <span style="color:#666666">=</span> {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>{ self<span style="color:#666666">-&gt;</span>worker,<tt><span style="white-space: pre-wrap;">  </span></tt><span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> } };<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> rc <span style="color:#666666">=</span> zmq_poll (items, <span style="color:#666666">1</span>, self<span style="color:#666666">-&gt;</span>heartbeat <span style="color:#666666">*</span> ZMQ_POLL_MSEC);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (rc <span style="color:#666666">==</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span></p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_recv (self<span style="color:#666666">-&gt;</span>worker);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>msg)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>verbose) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zclock_log (<span style="color:#BA2121">"I: received message from broker:"</span>);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_dump (msg);<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>self<span style="color:#666666">-&gt;</span>liveness <span style="color:#666666">=</span> HEARTBEAT_LIVENESS;</p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Don't try to handle errors, just assert noisily</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>assert (zmsg_size (msg) <span style="color:#666666">&gt;=</span> <span style="color:#666666">3</span>);</p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt>zframe_t <span style="color:#666666">*</span>empty <span style="color:#666666">=</span> zmsg_pop (msg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>assert (zframe_streq (empty, <span style="color:#BA2121">""</span>));<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_destroy (<span style="color:#666666">&amp;</span>empty);</p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt>zframe_t <span style="color:#666666">*</span>header <span style="color:#666666">=</span> zmsg_pop (msg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>assert (zframe_streq (header, MDPW_WORKER));<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_destroy (<span style="color:#666666">&amp;</span>header);</p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt>zframe_t <span style="color:#666666">*</span>command <span style="color:#666666">=</span> zmsg_pop (msg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (zframe_streq (command, MDPW_REQUEST)) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We should pop and save as many addresses as there are</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>up to a null part, but for now, just save one…</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt>self<span style="color:#666666">-&gt;</span>reply_to <span style="color:#666666">=</span> zmsg_unwrap (msg);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zframe_destroy (<span style="color:#666666">&amp;</span>command);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Here is where we actually have a message to process; we</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>return it to the caller application:</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt><br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>return</strong></span> msg;<tt><span style="white-space: pre-wrap;">     </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We have a request to process</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (zframe_streq (command, MDPW_HEARTBEAT))<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>;<tt><span style="white-space: pre-wrap;">               </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Do nothing for heartbeats</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (zframe_streq (command, MDPW_DISCONNECT))<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>s_mdwrk_connect_to_broker (self);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>else</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zclock_log (<span style="color:#BA2121">"E: invalid input message"</span>);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_dump (msg);<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_destroy (<span style="color:#666666">&amp;</span>command);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>msg);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666"><span style="white-space: pre-wrap;">--</span></span>self<span style="color:#666666">-&gt;</span>liveness <span style="color:#666666">==</span> <span style="color:#666666">0</span>) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>verbose)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zclock_log (<span style="color:#BA2121">"W: disconnected from broker - retrying…"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zclock_sleep (self<span style="color:#666666">-&gt;</span>reconnect);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>s_mdwrk_connect_to_broker (self);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send HEARTBEAT if it's time</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (zclock_time () <span style="color:#666666">&gt;</span> self<span style="color:#666666">-&gt;</span>heartbeat_at) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>s_mdwrk_send_to_broker (self, MDPW_HEARTBEAT, <span style="color:#008000">NULL</span>, <span style="color:#008000">NULL</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>self<span style="color:#666666">-&gt;</span>heartbeat_at <span style="color:#666666">=</span> zclock_time () <span style="color:#666666">+</span> self<span style="color:#666666">-&gt;</span>heartbeat;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (zctx_interrupted)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"W: interrupt received, killing worker…</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#008000">NULL</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cs:mdwrkapi" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/go:mdwrkapi" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hx:mdwrkapi" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:mdwrkapi" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:mdwrkapi" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/php:mdwrkapi" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:mdwrkapi" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rb:mdwrkapi" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/tcl:mdwrkapi" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | Clojure | CL | Delphi | Erlang | F# | Felix | Haskell | Node.js | Objective-C | ooc | Perl | Q | Racket | Scala</a></span>
<p>Let's see how the worker API looks in action, with an example test program that implements an echo service:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">mdworker:&nbsp;Majordomo&nbsp;worker&nbsp;application&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">mdworker:&nbsp;Majordomo&nbsp;worker&nbsp;application&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Majordomo Protocol worker example<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Uses the mdwrk API to hide all MDP aspects</span></p>
<p><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Lets us build this source without creating a library<br>
#include "mdwrkapi.c"</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">int</span> argc, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>argv <span style="white-space: pre-wrap;">[]</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> verbose <span style="color:#666666">=</span> (argc <span style="color:#666666">&gt;</span> <span style="color:#666666">1</span> <span style="color:#666666">&amp;&amp;</span> streq (argv <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>, <span style="color:#BA2121">"-v"</span>));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>mdwrk_t <span style="color:#666666">*</span>session <span style="color:#666666">=</span> mdwrk_new (<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5555"</span>, <span style="color:#BA2121">"echo"</span>, verbose);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>reply <span style="color:#666666">=</span> <span style="color:#008000">NULL</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_t <span style="color:#666666">*</span>request <span style="color:#666666">=</span> mdwrk_recv (session, <span style="color:#666666">&amp;</span>reply);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (request <span style="color:#666666">==</span> <span style="color:#008000">NULL</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Worker was interrupted</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>reply <span style="color:#666666">=</span> request;<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Echo is complex… :-)</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>mdwrk_destroy (<span style="color:#666666">&amp;</span>session);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:mdworker" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:mdworker" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/go:mdworker" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:mdworker" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:mdworker" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:mdworker" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:mdworker" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/php:mdworker" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:mdworker" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rb:mdworker" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/tcl:mdworker" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | Clojure | CL | Delphi | Erlang | F# | Felix | Node.js | Objective-C | ooc | Perl | Q | Racket | Scala</a></span>
<p>Here are some things to note about the worker API code:</p>
<ul>
<li>The APIs are single-threaded. This means, for example, that the worker won't send heartbeats in the background. Happily, this is exactly what we want: if the worker application gets stuck, heartbeats will stop and the broker will stop sending requests to the worker.</li>
</ul>
<ul>
<li>The worker API doesn't do an exponential back-off; it's not worth the extra complexity.</li>
</ul>
<ul>
<li>The APIs don't do any error reporting. If something isn't as expected, they raise an assertion (or exception depending on the language). This is ideal for a reference implementation, so any protocol errors show immediately. For real applications, the API should be robust against invalid messages.</li>
</ul>
<p>You might wonder why the worker API is manually closing its socket and opening a new one, when ZeroMQ will automatically reconnect a socket if the peer disappears and comes back. Look back at the Simple Pirate and Paranoid Pirate workers to understand. Although ZeroMQ will automatically reconnect workers if the broker dies and comes back up, this isn't sufficient to re-register the workers with the broker. I know of at least two solutions. The simplest, which we use here, is for the worker to monitor the connection using heartbeats, and if it decides the broker is dead, to close its socket and start afresh with a new socket. The alternative is for the broker to challenge unknown workers when it gets a heartbeat from the worker and ask them to re-register. That would require protocol support.</p>
<p>Now let's design the Majordomo broker. Its core structure is a set of queues, one per service. We will create these queues as workers appear (we could delete them as workers disappear, but forget that for now because it gets complex). Additionally, we keep a queue of workers per service.</p>
<p>And here is the broker:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">mdbroker:&nbsp;Majordomo&nbsp;broker&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">mdbroker:&nbsp;Majordomo&nbsp;broker&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Majordomo Protocol broker<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>A minimal C implementation of the Majordomo Protocol as defined in<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>http:<span style="white-space: pre-wrap;">//</span>rfc.zeromq.org/spec:7 and http:<span style="white-space: pre-wrap;">//</span>rfc.zeromq.org/spec:8.</span></p>
<p>#include "czmq.h"<br>
#include "mdp.h"</p>
<p><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We'd normally pull these from config data</p>
<p>#define HEARTBEAT_LIVENESS<tt><span style="white-space: pre-wrap;">  </span></tt>3<tt><span style="white-space: pre-wrap;">       </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>3-5 is reasonable</em></span><br>
<span style="color:#BC7A00">#define HEARTBEAT_INTERVAL<tt><span style="white-space: pre-wrap;">  </span></tt>2500<tt><span style="white-space: pre-wrap;">    </span></tt></span><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>msecs</em></span><br>
<span style="color:#BC7A00">#define HEARTBEAT_EXPIRY<tt><span style="white-space: pre-wrap;">    </span></tt>HEARTBEAT_INTERVAL * HEARTBEAT_LIVENESS</span></p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The broker class defines a single broker instance:</em></span></p>
<p><span style="color:#008000"><strong>typedef</strong></span> <span style="color:#008000"><strong>struct</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx;<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Our context</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>socket;<tt><span style="white-space: pre-wrap;">               </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Socket for clients &amp; workers</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> verbose;<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Print activity to stdout</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>endpoint;<tt><span style="white-space: pre-wrap;">             </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Broker binds to this endpoint</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zhash_t <span style="color:#666666">*</span>services;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Hash of known services</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zhash_t <span style="color:#666666">*</span>workers;<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Hash of known workers</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zlist_t <span style="color:#666666">*</span>waiting;<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>List of waiting workers</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">uint64_t</span> heartbeat_at;<tt><span style="white-space: pre-wrap;">      </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>When to send HEARTBEAT</em></span><br>
} broker_t;</p>
<p><span style="color:#008000"><strong>static</strong></span> broker_t <span style="color:#666666">*</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_broker_new (<span style="color:#B00040">int</span> verbose);<br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_broker_destroy (broker_t <span style="color:#666666"><span style="white-space: pre-wrap;">**</span></span>self_p);<br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_broker_bind (broker_t <span style="color:#666666">*</span>self, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>endpoint);<br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_broker_worker_msg (broker_t <span style="color:#666666">*</span>self, zframe_t <span style="color:#666666">*</span>sender, zmsg_t <span style="color:#666666">*</span>msg);<br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_broker_client_msg (broker_t <span style="color:#666666">*</span>self, zframe_t <span style="color:#666666">*</span>sender, zmsg_t <span style="color:#666666">*</span>msg);<br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_broker_purge (broker_t <span style="color:#666666">*</span>self);</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The service class defines a single service instance:</em></span></p>
<p><span style="color:#008000"><strong>typedef</strong></span> <span style="color:#008000"><strong>struct</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>broker_t <span style="color:#666666">*</span>broker;<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Broker instance</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>name;<tt><span style="white-space: pre-wrap;">                 </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Service name</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zlist_t <span style="color:#666666">*</span>requests;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>List of client requests</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zlist_t <span style="color:#666666">*</span>waiting;<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>List of waiting workers</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">size_t</span> workers;<tt><span style="white-space: pre-wrap;">             </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>How many workers we have</em></span><br>
} service_t;</p>
<p><span style="color:#008000"><strong>static</strong></span> service_t <span style="color:#666666">*</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_service_require (broker_t <span style="color:#666666">*</span>self, zframe_t <span style="color:#666666">*</span>service_frame);<br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_service_destroy (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>argument);<br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_service_dispatch (service_t <span style="color:#666666">*</span>service, zmsg_t <span style="color:#666666">*</span>msg);</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The worker class defines a single worker, idle or active:</em></span></p>
<p><span style="color:#008000"><strong>typedef</strong></span> <span style="color:#008000"><strong>struct</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>broker_t <span style="color:#666666">*</span>broker;<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Broker instance</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>id_string;<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Identity of worker as string</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zframe_t <span style="color:#666666">*</span>identity;<tt><span style="white-space: pre-wrap;">         </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Identity frame for routing</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>service_t <span style="color:#666666">*</span>service;<tt><span style="white-space: pre-wrap;">         </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Owning service, if known</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int64_t</span> expiry;<tt><span style="white-space: pre-wrap;">             </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>When worker expires, if no heartbeat</em></span><br>
} worker_t;</p>
<p><span style="color:#008000"><strong>static</strong></span> worker_t <span style="color:#666666">*</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_worker_require (broker_t <span style="color:#666666">*</span>self, zframe_t <span style="color:#666666">*</span>identity);<br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_worker_delete (worker_t <span style="color:#666666">*</span>self, <span style="color:#B00040">int</span> disconnect);<br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_worker_destroy (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>argument);<br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_worker_send (worker_t <span style="color:#666666">*</span>self, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>command, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>option,<br>
<tt><span style="white-space: pre-wrap;">                   </span></tt>zmsg_t <span style="color:#666666">*</span>msg);<br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_worker_waiting (worker_t <span style="color:#666666">*</span>self);</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Here are the constructor and destructor for the broker:</em></span></p>
<p><span style="color:#008000"><strong>static</strong></span> broker_t <span style="color:#666666">*</span><br>
<span style="color:#0000FF">s_broker_new</span> (<span style="color:#B00040">int</span> verbose)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>broker_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> (broker_t <span style="color:#666666">*</span>) zmalloc (<span style="color:#008000"><strong>sizeof</strong></span> (broker_t));</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Initialize broker state</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>socket <span style="color:#666666">=</span> zsocket_new (self<span style="color:#666666">-&gt;</span>ctx, ZMQ_ROUTER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>verbose <span style="color:#666666">=</span> verbose;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>services <span style="color:#666666">=</span> zhash_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>workers <span style="color:#666666">=</span> zhash_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>waiting <span style="color:#666666">=</span> zlist_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>heartbeat_at <span style="color:#666666">=</span> zclock_time () <span style="color:#666666">+</span> HEARTBEAT_INTERVAL;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> self;<br>
}</p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<span style="color:#0000FF">s_broker_destroy</span> (broker_t <span style="color:#666666"><span style="white-space: pre-wrap;">**</span></span>self_p)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self_p);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">*</span>self_p) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>broker_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> <span style="color:#666666">*</span>self_p;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zhash_destroy (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>services);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zhash_destroy (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>workers);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zlist_destroy (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>waiting);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (self);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#666666">*</span>self_p <span style="color:#666666">=</span> <span style="color:#008000">NULL</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This method binds the broker instance to an endpoint. We can call<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>this multiple times. Note that MDP uses a single socket for both clients<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>and workers:</span></span></p>
<p><span style="color:#B00040">void</span><br>
<span style="color:#0000FF">s_broker_bind</span> (broker_t <span style="color:#666666">*</span>self, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>endpoint)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (self<span style="color:#666666">-&gt;</span>socket, endpoint);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zclock_log (<span style="color:#BA2121">"I: MDP broker/0.2.0 is active at %s"</span>, endpoint);<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This method processes one READY, REPLY, HEARTBEAT, or<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>DISCONNECT message sent to the broker by a worker:</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<span style="color:#0000FF">s_broker_worker_msg</span> (broker_t <span style="color:#666666">*</span>self, zframe_t <span style="color:#666666">*</span>sender, zmsg_t <span style="color:#666666">*</span>msg)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (zmsg_size (msg) <span style="color:#666666">&gt;=</span> <span style="color:#666666">1</span>);<tt><span style="white-space: pre-wrap;">     </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>At least, command</em></span></p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zframe_t <span style="color:#666666">*</span>command <span style="color:#666666">=</span> zmsg_pop (msg);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>id_string <span style="color:#666666">=</span> zframe_strhex (sender);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> worker_ready <span style="color:#666666">=</span> (zhash_lookup (self<span style="color:#666666">-&gt;</span>workers, id_string) <span style="color:#666666">!=</span> <span style="color:#008000">NULL</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>free (id_string);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>worker_t <span style="color:#666666">*</span>worker <span style="color:#666666">=</span> s_worker_require (self, sender);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (zframe_streq (command, MDPW_READY)) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (worker_ready)<tt><span style="white-space: pre-wrap;">               </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Not first command in session</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>s_worker_delete (worker, <span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (zframe_size (sender) <span style="color:#666666">&gt;=</span> <span style="color:#666666">4</span><tt><span style="white-space: pre-wrap;">  </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Reserved service name</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#666666">&amp;&amp;</span><tt><span style="white-space: pre-wrap;">  </span></tt>memcmp (zframe_data (sender), <span style="color:#BA2121">"mmi."</span>, <span style="color:#666666">4</span>) <span style="color:#666666">==</span> <span style="color:#666666">0</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>s_worker_delete (worker, <span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Attach worker to service and mark as idle</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_t <span style="color:#666666">*</span>service_frame <span style="color:#666666">=</span> zmsg_pop (msg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>worker<span style="color:#666666">-&gt;</span>service <span style="color:#666666">=</span> s_service_require (self, service_frame);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>worker<span style="color:#666666">-&gt;</span>service<span style="color:#666666">-&gt;</span>workers<span style="color:#666666">++</span>;<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>s_worker_waiting (worker);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_destroy (<span style="color:#666666">&amp;</span>service_frame);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (zframe_streq (command, MDPW_REPLY)) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (worker_ready) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Remove and save client return envelope and insert the</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>protocol header and service name, then rewrap envelope.</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_t <span style="color:#666666">*</span>client <span style="color:#666666">=</span> zmsg_unwrap (msg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_pushstr (msg, worker<span style="color:#666666">-&gt;</span>service<span style="color:#666666">-&gt;</span>name);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_pushstr (msg, MDPC_CLIENT);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_wrap (msg, client);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>msg, self<span style="color:#666666">-&gt;</span>socket);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>s_worker_waiting (worker);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>s_worker_delete (worker, <span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (zframe_streq (command, MDPW_HEARTBEAT)) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (worker_ready)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>worker<span style="color:#666666">-&gt;</span>expiry <span style="color:#666666">=</span> zclock_time () <span style="color:#666666">+</span> HEARTBEAT_EXPIRY;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>s_worker_delete (worker, <span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (zframe_streq (command, MDPW_DISCONNECT))<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>s_worker_delete (worker, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zclock_log (<span style="color:#BA2121">"E: invalid input message"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_dump (msg);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>free (command);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>msg);<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Process a request coming from a client. We implement MMI requests<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>directly here (at present, we implement only the mmi.service request):</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<span style="color:#0000FF">s_broker_client_msg</span> (broker_t <span style="color:#666666">*</span>self, zframe_t <span style="color:#666666">*</span>sender, zmsg_t <span style="color:#666666">*</span>msg)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (zmsg_size (msg) <span style="color:#666666">&gt;=</span> <span style="color:#666666">2</span>);<tt><span style="white-space: pre-wrap;">     </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Service name + body</em></span></p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zframe_t <span style="color:#666666">*</span>service_frame <span style="color:#666666">=</span> zmsg_pop (msg);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>service_t <span style="color:#666666">*</span>service <span style="color:#666666">=</span> s_service_require (self, service_frame);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Set reply return identity to client sender</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_wrap (msg, zframe_dup (sender));</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If we got a MMI service request, process that internally</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (zframe_size (service_frame) <span style="color:#666666">&gt;=</span> <span style="color:#666666">4</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#666666">&amp;&amp;</span><tt><span style="white-space: pre-wrap;">  </span></tt>memcmp (zframe_data (service_frame), <span style="color:#BA2121">"mmi."</span>, <span style="color:#666666">4</span>) <span style="color:#666666">==</span> <span style="color:#666666">0</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>return_code;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (zframe_streq (service_frame, <span style="color:#BA2121">"mmi.service"</span>)) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>name <span style="color:#666666">=</span> zframe_strdup (zmsg_last (msg));<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>service_t <span style="color:#666666">*</span>service <span style="color:#666666">=</span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt>(service_t <span style="color:#666666">*</span>) zhash_lookup (self<span style="color:#666666">-&gt;</span>services, name);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>return_code <span style="color:#666666">=</span> service <span style="color:#666666">&amp;&amp;</span> service<span style="color:#666666">-&gt;</span>workers<span style="color:#666666">?</span> <span style="color:#BA2121">"200"</span><span style="color:#666666">:</span> <span style="color:#BA2121">"404"</span>;<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>free (name);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>return_code <span style="color:#666666">=</span> <span style="color:#BA2121">"501"</span>;</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt>zframe_reset (zmsg_last (msg), return_code, strlen (return_code));</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Remove &amp; save client return envelope and insert the</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>protocol header and service name, then rewrap envelope.</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_t <span style="color:#666666">*</span>client <span style="color:#666666">=</span> zmsg_unwrap (msg);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_prepend (msg, <span style="color:#666666">&amp;</span>service_frame);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_pushstr (msg, MDPC_CLIENT);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_wrap (msg, client);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>msg, self<span style="color:#666666">-&gt;</span>socket);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Else dispatch the message to the requested service</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>s_service_dispatch (service, msg);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zframe_destroy (<span style="color:#666666">&amp;</span>service_frame);<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This method deletes any idle workers that haven't pinged us in a<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>while. We hold workers from oldest to most recent so we can stop<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>scanning whenever we find a live worker. This means we'll mainly stop<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>at the first worker, which is essential when we have large numbers of<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>workers (we call this method in our critical path):</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<span style="color:#0000FF">s_broker_purge</span> (broker_t <span style="color:#666666">*</span>self)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>worker_t <span style="color:#666666">*</span>worker <span style="color:#666666">=</span> (worker_t <span style="color:#666666">*</span>) zlist_first (self<span style="color:#666666">-&gt;</span>waiting);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (worker) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (zclock_time () <span style="color:#666666">&lt;</span> worker<span style="color:#666666">-&gt;</span>expiry)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">                  </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Worker is alive, we're done here</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>verbose)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zclock_log (<span style="color:#BA2121">"I: deleting expired worker: %s"</span>,<br>
<tt><span style="white-space: pre-wrap;">                        </span></tt>worker<span style="color:#666666">-&gt;</span>id_string);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt>s_worker_delete (worker, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>worker <span style="color:#666666">=</span> (worker_t <span style="color:#666666">*</span>) zlist_first (self<span style="color:#666666">-&gt;</span>waiting);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Here is the implementation of the methods that work on a service:</em></span></p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Lazy constructor that locates a service by name or creates a new<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>service if there is no service already with that name.</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> service_t <span style="color:#666666">*</span><br>
<span style="color:#0000FF">s_service_require</span> (broker_t <span style="color:#666666">*</span>self, zframe_t <span style="color:#666666">*</span>service_frame)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (service_frame);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>name <span style="color:#666666">=</span> zframe_strdup (service_frame);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>service_t <span style="color:#666666">*</span>service <span style="color:#666666">=</span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>(service_t <span style="color:#666666">*</span>) zhash_lookup (self<span style="color:#666666">-&gt;</span>services, name);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (service <span style="color:#666666">==</span> <span style="color:#008000">NULL</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>service <span style="color:#666666">=</span> (service_t <span style="color:#666666">*</span>) zmalloc (<span style="color:#008000"><strong>sizeof</strong></span> (service_t));<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>service<span style="color:#666666">-&gt;</span>broker <span style="color:#666666">=</span> self;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>service<span style="color:#666666">-&gt;</span>name <span style="color:#666666">=</span> name;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>service<span style="color:#666666">-&gt;</span>requests <span style="color:#666666">=</span> zlist_new ();<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>service<span style="color:#666666">-&gt;</span>waiting <span style="color:#666666">=</span> zlist_new ();<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zhash_insert (self<span style="color:#666666">-&gt;</span>services, name, service);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zhash_freefn (self<span style="color:#666666">-&gt;</span>services, name, s_service_destroy);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>verbose)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zclock_log (<span style="color:#BA2121">"I: added service: %s"</span>, name);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (name);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> service;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Service destructor is called automatically whenever the service is<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>removed from broker-&gt;services.</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<span style="color:#0000FF">s_service_destroy</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>argument)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>service_t <span style="color:#666666">*</span>service <span style="color:#666666">=</span> (service_t <span style="color:#666666">*</span>) argument;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (zlist_size (service<span style="color:#666666">-&gt;</span>requests)) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zlist_pop (service<span style="color:#666666">-&gt;</span>requests);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>msg);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zlist_destroy (<span style="color:#666666">&amp;</span>service<span style="color:#666666">-&gt;</span>requests);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zlist_destroy (<span style="color:#666666">&amp;</span>service<span style="color:#666666">-&gt;</span>waiting);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>free (service<span style="color:#666666">-&gt;</span>name);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>free (service);<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This method sends requests to waiting workers:</em></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<span style="color:#0000FF">s_service_dispatch</span> (service_t <span style="color:#666666">*</span>self, zmsg_t <span style="color:#666666">*</span>msg)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (msg)<tt><span style="white-space: pre-wrap;">                    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Queue message if any</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zlist_append (self<span style="color:#666666">-&gt;</span>requests, msg);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>s_broker_purge (self<span style="color:#666666">-&gt;</span>broker);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (zlist_size (self<span style="color:#666666">-&gt;</span>waiting) <span style="color:#666666">&amp;&amp;</span> zlist_size (self<span style="color:#666666">-&gt;</span>requests)) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>worker_t <span style="color:#666666">*</span>worker <span style="color:#666666">=</span> zlist_pop (self<span style="color:#666666">-&gt;</span>waiting);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zlist_remove (self<span style="color:#666666">-&gt;</span>broker<span style="color:#666666">-&gt;</span>waiting, worker);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zlist_pop (self<span style="color:#666666">-&gt;</span>requests);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>s_worker_send (worker, MDPW_REQUEST, <span style="color:#008000">NULL</span>, msg);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>msg);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Here is the implementation of the methods that work on a worker:</em></span></p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Lazy constructor that locates a worker by identity, or creates a new<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>worker if there is no worker already with that identity.</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> worker_t <span style="color:#666666">*</span><br>
<span style="color:#0000FF">s_worker_require</span> (broker_t <span style="color:#666666">*</span>self, zframe_t <span style="color:#666666">*</span>identity)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (identity);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>self-&gt;workers is keyed off worker identity</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>id_string <span style="color:#666666">=</span> zframe_strhex (identity);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>worker_t <span style="color:#666666">*</span>worker <span style="color:#666666">=</span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>(worker_t <span style="color:#666666">*</span>) zhash_lookup (self<span style="color:#666666">-&gt;</span>workers, id_string);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (worker <span style="color:#666666">==</span> <span style="color:#008000">NULL</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>worker <span style="color:#666666">=</span> (worker_t <span style="color:#666666">*</span>) zmalloc (<span style="color:#008000"><strong>sizeof</strong></span> (worker_t));<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>worker<span style="color:#666666">-&gt;</span>broker <span style="color:#666666">=</span> self;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>worker<span style="color:#666666">-&gt;</span>id_string <span style="color:#666666">=</span> id_string;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>worker<span style="color:#666666">-&gt;</span>identity <span style="color:#666666">=</span> zframe_dup (identity);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zhash_insert (self<span style="color:#666666">-&gt;</span>workers, id_string, worker);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zhash_freefn (self<span style="color:#666666">-&gt;</span>workers, id_string, s_worker_destroy);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>verbose)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zclock_log (<span style="color:#BA2121">"I: registering new worker: %s"</span>, id_string);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (id_string);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> worker;<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This method deletes the current worker.</em></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<span style="color:#0000FF">s_worker_delete</span> (worker_t <span style="color:#666666">*</span>self, <span style="color:#B00040">int</span> disconnect)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (disconnect)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>s_worker_send (self, MDPW_DISCONNECT, <span style="color:#008000">NULL</span>, <span style="color:#008000">NULL</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>service) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zlist_remove (self<span style="color:#666666">-&gt;</span>service<span style="color:#666666">-&gt;</span>waiting, self);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>self<span style="color:#666666">-&gt;</span>service<span style="color:#666666">-&gt;</span>workers<span style="color:#666666"><span style="white-space: pre-wrap;">--</span></span>;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zlist_remove (self<span style="color:#666666">-&gt;</span>broker<span style="color:#666666">-&gt;</span>waiting, self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This implicitly calls s_worker_destroy</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zhash_delete (self<span style="color:#666666">-&gt;</span>broker<span style="color:#666666">-&gt;</span>workers, self<span style="color:#666666">-&gt;</span>id_string);<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Worker destructor is called automatically whenever the worker is<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>removed from broker-&gt;workers.</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<span style="color:#0000FF">s_worker_destroy</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>argument)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>worker_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> (worker_t <span style="color:#666666">*</span>) argument;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zframe_destroy (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>identity);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>free (self<span style="color:#666666">-&gt;</span>id_string);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>free (self);<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This method formats and sends a command to a worker. The caller may<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>also provide a command option, and a message payload:</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<span style="color:#0000FF">s_worker_send</span> (worker_t <span style="color:#666666">*</span>self, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>command, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>option, zmsg_t <span style="color:#666666">*</span>msg)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>msg <span style="color:#666666">=</span> msg<span style="color:#666666">?</span> zmsg_dup (msg)<span style="color:#666666">:</span> zmsg_new ();</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Stack protocol envelope to start of message</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (option)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_pushstr (msg, option);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_pushstr (msg, command);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_pushstr (msg, MDPW_WORKER);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Stack routing envelope to start of message</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_wrap (msg, zframe_dup (self<span style="color:#666666">-&gt;</span>identity));</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>broker<span style="color:#666666">-&gt;</span>verbose) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zclock_log (<span style="color:#BA2121">"I: sending %s to worker"</span>,<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>mdps_commands <span style="white-space: pre-wrap;">[</span>(<span style="color:#B00040">int</span>) <span style="color:#666666">*</span>command<span style="white-space: pre-wrap;">]</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_dump (msg);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>msg, self<span style="color:#666666">-&gt;</span>broker<span style="color:#666666">-&gt;</span>socket);<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This worker is now waiting for work</em></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<span style="color:#0000FF">s_worker_waiting</span> (worker_t <span style="color:#666666">*</span>self)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Queue to broker and service waiting lists</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self<span style="color:#666666">-&gt;</span>broker);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zlist_append (self<span style="color:#666666">-&gt;</span>broker<span style="color:#666666">-&gt;</span>waiting, self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zlist_append (self<span style="color:#666666">-&gt;</span>service<span style="color:#666666">-&gt;</span>waiting, self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>expiry <span style="color:#666666">=</span> zclock_time () <span style="color:#666666">+</span> HEARTBEAT_EXPIRY;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_service_dispatch (self<span style="color:#666666">-&gt;</span>service, <span style="color:#008000">NULL</span>);<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Finally, here is the main task. We create a new broker instance and<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>then process messages on the broker socket:</span></span></p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">int</span> argc, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>argv <span style="white-space: pre-wrap;">[]</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> verbose <span style="color:#666666">=</span> (argc <span style="color:#666666">&gt;</span> <span style="color:#666666">1</span> <span style="color:#666666">&amp;&amp;</span> streq (argv <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>, <span style="color:#BA2121">"-v"</span>));</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>broker_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> s_broker_new (verbose);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_broker_bind (self, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5555"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Get and process messages forever or until interrupted</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_pollitem_t items <span style="white-space: pre-wrap;">[]</span> <span style="color:#666666">=</span> {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>{ self<span style="color:#666666">-&gt;</span>socket,<tt><span style="white-space: pre-wrap;">  </span></tt><span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> } };<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> rc <span style="color:#666666">=</span> zmq_poll (items, <span style="color:#666666">1</span>, HEARTBEAT_INTERVAL <span style="color:#666666">*</span> ZMQ_POLL_MSEC);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (rc <span style="color:#666666">==</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span></p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Process next input message, if any</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_recv (self<span style="color:#666666">-&gt;</span>socket);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>msg)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>verbose) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zclock_log (<span style="color:#BA2121">"I: received message:"</span>);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_dump (msg);<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_t <span style="color:#666666">*</span>sender <span style="color:#666666">=</span> zmsg_pop (msg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_t <span style="color:#666666">*</span>empty<tt><span style="white-space: pre-wrap;">  </span></tt><span style="color:#666666">=</span> zmsg_pop (msg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_t <span style="color:#666666">*</span>header <span style="color:#666666">=</span> zmsg_pop (msg);</p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (zframe_streq (header, MDPC_CLIENT))<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>s_broker_client_msg (self, sender, msg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (zframe_streq (header, MDPW_WORKER))<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>s_broker_worker_msg (self, sender, msg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>else</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zclock_log (<span style="color:#BA2121">"E: invalid message:"</span>);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_dump (msg);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>msg);<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_destroy (<span style="color:#666666">&amp;</span>sender);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_destroy (<span style="color:#666666">&amp;</span>empty);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_destroy (<span style="color:#666666">&amp;</span>header);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Disconnect and delete any expired workers</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send heartbeats to idle workers if needed</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (zclock_time () <span style="color:#666666">&gt;</span> self<span style="color:#666666">-&gt;</span>heartbeat_at) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>s_broker_purge (self);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>worker_t <span style="color:#666666">*</span>worker <span style="color:#666666">=</span> (worker_t <span style="color:#666666">*</span>) zlist_first (self<span style="color:#666666">-&gt;</span>waiting);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>while</strong></span> (worker) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>s_worker_send (worker, MDPW_HEARTBEAT, <span style="color:#008000">NULL</span>, <span style="color:#008000">NULL</span>);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>worker <span style="color:#666666">=</span> (worker_t <span style="color:#666666">*</span>) zlist_next (self<span style="color:#666666">-&gt;</span>waiting);<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>self<span style="color:#666666">-&gt;</span>heartbeat_at <span style="color:#666666">=</span> zclock_time () <span style="color:#666666">+</span> HEARTBEAT_INTERVAL;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (zctx_interrupted)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"W: interrupt received, shutting down…</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>s_broker_destroy (<span style="color:#666666">&amp;</span>self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:mdbroker" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:mdbroker" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/go:mdbroker" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:mdbroker" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:mdbroker" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:mdbroker" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:mdbroker" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/php:mdbroker" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:mdbroker" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rb:mdbroker" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/tcl:mdbroker" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | Clojure | CL | Delphi | Erlang | F# | Felix | Node.js | Objective-C | ooc | Perl | Q | Racket | Scala</a></span>
<p>This is by far the most complex example we've seen. It's almost 500 lines of code. To write this and make it somewhat robust took two days. However, this is still a short piece of code for a full service-oriented broker.</p>
<p>Here are some things to note about the broker code:</p>
<ul>
<li>The Majordomo Protocol lets us handle both clients and workers on a single socket. This is nicer for those deploying and managing the broker: it just sits on one ZeroMQ endpoint rather than the two that most proxies need.</li>
</ul>
<ul>
<li>The broker implements all of MDP/0.1 properly (as far as I know), including disconnection if the broker sends invalid commands, heartbeating, and the rest.</li>
</ul>
<ul>
<li>It can be extended to run multiple threads, each managing one socket and one set of clients and workers. This could be interesting for segmenting large architectures. The C code is already organized around a broker class to make this trivial.</li>
</ul>
<ul>
<li>A primary/failover or live/live broker reliability model is easy, as the broker essentially has no state except service presence. It's up to clients and workers to choose another broker if their first choice isn't up and running.</li>
</ul>
<ul>
<li>The examples use five-second heartbeats, mainly to reduce the amount of output when you enable tracing. Realistic values would be lower for most LAN applications. However, any retry has to be slow enough to allow for a service to restart, say 10 seconds at least.</li>
</ul>
<p>We later improved and extended the protocol and the Majordomo implementation, which now sits in its own Github project. If you want a properly usable Majordomo stack, use the GitHub project.</p>
<p><a name="Asynchronous-Majordomo-Pattern"></a><a name="header-100"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc99"><span><a href="http://zguide.zeromq.org/page:all#Asynchronous-Majordomo-Pattern">Asynchronous Majordomo Pattern</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-99">prev</a> <a href="http://zguide.zeromq.org/page:all#header-101">next</a></td>
</tr>
</tbody></table>
<p>The Majordomo implementation in the previous section is simple and stupid. The client is just the original Simple Pirate, wrapped up in a sexy API. When I fire up a client, broker, and worker on a test box, it can process 100,000 requests in about 14 seconds. That is partially due to the code, which cheerfully copies message frames around as if CPU cycles were free. But the real problem is that we're doing network round-trips. ZeroMQ disables <a href="http://en.wikipedia.org/wiki/Nagles_algorithm">Nagle's algorithm</a>, but round-tripping is still slow.</p>
<p>Theory is great in theory, but in practice, practice is better. Let's measure the actual cost of round-tripping with a simple test program. This sends a bunch of messages, first waiting for a reply to each message, and second as a batch, reading all the replies back as a batch. Both approaches do the same work, but they give very different results. We mock up a client, broker, and worker:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">tripping:&nbsp;Round-trip&nbsp;demonstrator&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">tripping:&nbsp;Round-trip&nbsp;demonstrator&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Round-trip demonstrator<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>While this example runs in a single process, that is just to make<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>it easier to start and stop the example. The client task signals to<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>main when it's ready.</span></p>
<p>#include "czmq.h"</p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<span style="color:#0000FF">client_task</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>args, zctx_t <span style="color:#666666">*</span>ctx, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>pipe)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>client <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_DEALER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect (client, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5555"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"Setting up test…</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zclock_sleep (<span style="color:#666666">100</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> requests;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int64_t</span> start;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"Synchronous round-trip test…</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>start <span style="color:#666666">=</span> zclock_time ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (requests <span style="color:#666666">=</span> <span style="color:#666666">0</span>; requests <span style="color:#666666">&lt;</span> <span style="color:#666666">10000</span>; requests<span style="color:#666666">++</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zstr_send (client, <span style="color:#BA2121">"hello"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>reply <span style="color:#666666">=</span> zstr_recv (client);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (reply);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">" %d calls/second</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>,<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>(<span style="color:#666666">1000</span> <span style="color:#666666">*</span> <span style="color:#666666">10000</span>) <span style="color:#666666">/</span> (<span style="color:#B00040">int</span>) (zclock_time () <span style="color:#666666">-</span> start));</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"Asynchronous round-trip test…</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>start <span style="color:#666666">=</span> zclock_time ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (requests <span style="color:#666666">=</span> <span style="color:#666666">0</span>; requests <span style="color:#666666">&lt;</span> <span style="color:#666666">100000</span>; requests<span style="color:#666666">++</span>)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zstr_send (client, <span style="color:#BA2121">"hello"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (requests <span style="color:#666666">=</span> <span style="color:#666666">0</span>; requests <span style="color:#666666">&lt;</span> <span style="color:#666666">100000</span>; requests<span style="color:#666666">++</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>reply <span style="color:#666666">=</span> zstr_recv (client);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (reply);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">" %d calls/second</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>,<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>(<span style="color:#666666">1000</span> <span style="color:#666666">*</span> <span style="color:#666666">100000</span>) <span style="color:#666666">/</span> (<span style="color:#B00040">int</span>) (zclock_time () <span style="color:#666666">-</span> start));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zstr_send (pipe, <span style="color:#BA2121">"done"</span>);<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Here is the worker task. All it does is receive a message, and<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>bounce it back the way it came:</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span> <span style="color:#666666">*</span><br>
<span style="color:#0000FF">worker_task</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>args)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>worker <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_DEALER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect (worker, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5556"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_recv (worker);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>msg, worker);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#008000">NULL</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Here is the broker task. It uses the <tt>zmq_proxy</tt> function to switch<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>messages between frontend and backend:</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span> <span style="color:#666666">*</span><br>
<span style="color:#0000FF">broker_task</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>args)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Prepare our context and sockets</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>frontend <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_DEALER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (frontend, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5555"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>backend <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_DEALER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (backend, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5556"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_proxy (frontend, backend, <span style="color:#008000">NULL</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#008000">NULL</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Finally, here's the main task, which starts the client, worker, and<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>broker, and then runs until the client signals it to stop:</span></span></p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Create threads</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>client <span style="color:#666666">=</span> zthread_fork (ctx, client_task, <span style="color:#008000">NULL</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zthread_new (worker_task, <span style="color:#008000">NULL</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zthread_new (broker_task, <span style="color:#008000">NULL</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Wait for signal on client pipe</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>signal <span style="color:#666666">=</span> zstr_recv (client);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>free (signal);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:tripping" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:tripping" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/go:tripping" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hs:tripping" target="_blank">Haskell</a> | <a href="http://zguide.zeromq.org/hx:tripping" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:tripping" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:tripping" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/php:tripping" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:tripping" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/tcl:tripping" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | Clojure | CL | Delphi | Erlang | F# | Felix | Node.js | Objective-C | ooc | Perl | Q | Racket | Ruby | Scala</a></span>
<p>On my development box, this program says:</p>
<div class="code">
<pre><code>Setting up test...
Synchronous round-trip test...
 9057 calls/second
Asynchronous round-trip test...
 173010 calls/second</code>
</pre></div>
<p>Note that the client thread does a small pause before starting. This is to get around one of the "features" of the router socket: if you send a message with the address of a peer that's not yet connected, the message gets discarded. In this example we don't use the load balancing mechanism, so without the sleep, if the worker thread is too slow to connect, it will lose messages, making a mess of our test.</p>
<p>As we see, round-tripping in the simplest case is 20 times slower than the asynchronous, "shove it down the pipe as fast as it'll go" approach. Let's see if we can apply this to Majordomo to make it faster.</p>
<p>First, we modify the client API to send and receive in two separate methods:</p>
<div class="code">
<p>mdcli_t <span style="color:#666666">*</span>mdcli_new<tt><span style="white-space: pre-wrap;">     </span></tt>(<span style="color:#B00040">char</span> <span style="color:#666666">*</span>broker);<br>
<span style="color:#B00040">void</span><tt><span style="white-space: pre-wrap;">     </span></tt>mdcli_destroy (mdcli_t <span style="color:#666666"><span style="white-space: pre-wrap;">**</span></span>self_p);<br>
<span style="color:#B00040">int</span><tt><span style="white-space: pre-wrap;">      </span></tt>mdcli_send<tt><span style="white-space: pre-wrap;">    </span></tt>(mdcli_t <span style="color:#666666">*</span>self, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>service, zmsg_t <span style="color:#666666"><span style="white-space: pre-wrap;">**</span></span>request_p);<br>
zmsg_t<tt><span style="white-space: pre-wrap;">  </span></tt><span style="color:#666666">*</span>mdcli_recv<tt><span style="white-space: pre-wrap;">    </span></tt>(mdcli_t <span style="color:#666666">*</span>self);</p>
</div>
<p>It's literally a few minutes' work to refactor the synchronous client API to become asynchronous:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">mdcliapi2:&nbsp;Majordomo&nbsp;asynchronous&nbsp;client&nbsp;API&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">mdcliapi2:&nbsp;Majordomo&nbsp;asynchronous&nbsp;client&nbsp;API&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>mdcliapi2 class - Majordomo Protocol Client API<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Implements the MDP/Worker spec at http:<span style="white-space: pre-wrap;">//</span>rfc.zeromq.org/spec:7.</span></p>
<p>#include "mdcliapi2.h"</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Structure of our class<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We access these properties only via class methods</span></span></p>
<p><span style="color:#008000"><strong>struct</strong></span> _mdcli_t {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx;<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Our context</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>broker;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>client;<tt><span style="white-space: pre-wrap;">               </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Socket to broker</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> verbose;<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Print activity to stdout</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> timeout;<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Request timeout</em></span><br>
};</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Connect or reconnect to broker. In this asynchronous class we use a<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>DEALER socket instead of a REQ socket; this lets us send any number<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>of requests without waiting for a reply.</span></span></p>
<p><span style="color:#B00040">void</span> <span style="color:#0000FF">s_mdcli_connect_to_broker</span> (mdcli_t <span style="color:#666666">*</span>self)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>client)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zsocket_destroy (self<span style="color:#666666">-&gt;</span>ctx, self<span style="color:#666666">-&gt;</span>client);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>client <span style="color:#666666">=</span> zsocket_new (self<span style="color:#666666">-&gt;</span>ctx, ZMQ_DEALER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_connect (self<span style="color:#666666">-&gt;</span>client, self<span style="color:#666666">-&gt;</span>broker);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>verbose)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zclock_log (<span style="color:#BA2121">"I: connecting to broker at %s…"</span>, self<span style="color:#666666">-&gt;</span>broker);<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The constructor and destructor are the same as in mdcliapi, except<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>we don't do retries, so there's no retries property.<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt><span style="white-space: pre-wrap;">---------------------------------------------------------------------</span><br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Constructor</span></span></p>
<p>mdcli_t <span style="color:#666666">*</span><br>
<span style="color:#0000FF">mdcli_new</span> (<span style="color:#B00040">char</span> <span style="color:#666666">*</span>broker, <span style="color:#B00040">int</span> verbose)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (broker);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>mdcli_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> (mdcli_t <span style="color:#666666">*</span>) zmalloc (<span style="color:#008000"><strong>sizeof</strong></span> (mdcli_t));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>broker <span style="color:#666666">=</span> strdup (broker);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>verbose <span style="color:#666666">=</span> verbose;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>timeout <span style="color:#666666">=</span> <span style="color:#666666">2500</span>;<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>msecs</em></span></p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>s_mdcli_connect_to_broker (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> self;<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Destructor</em></span></p>
<p><span style="color:#B00040">void</span><br>
<span style="color:#0000FF">mdcli_destroy</span> (mdcli_t <span style="color:#666666"><span style="white-space: pre-wrap;">**</span></span>self_p)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self_p);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">*</span>self_p) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>mdcli_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> <span style="color:#666666">*</span>self_p;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (self<span style="color:#666666">-&gt;</span>broker);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (self);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#666666">*</span>self_p <span style="color:#666666">=</span> <span style="color:#008000">NULL</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Set request timeout</em></span></p>
<p><span style="color:#B00040">void</span><br>
<span style="color:#0000FF">mdcli_set_timeout</span> (mdcli_t <span style="color:#666666">*</span>self, <span style="color:#B00040">int</span> timeout)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>timeout <span style="color:#666666">=</span> timeout;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The send method now just sends one message, without waiting for a<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>reply. Since we're using a DEALER socket we have to send an empty<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>frame at the start, to create the same envelope that the REQ socket<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>would normally make for us:</span></span></p>
<p><span style="color:#B00040">int</span><br>
<span style="color:#0000FF">mdcli_send</span> (mdcli_t <span style="color:#666666">*</span>self, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>service, zmsg_t <span style="color:#666666"><span style="white-space: pre-wrap;">**</span></span>request_p)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (request_p);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>request <span style="color:#666666">=</span> <span style="color:#666666">*</span>request_p;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Prefix request with protocol frames</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Frame 0: empty (REQ emulation)</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Frame 1: "MDPCxy" (six bytes, MDP/Client x.y)</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Frame 2: Service name (printable string)</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_pushstr (request, service);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_pushstr (request, MDPC_CLIENT);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_pushstr (request, <span style="color:#BA2121">""</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>verbose) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zclock_log (<span style="color:#BA2121">"I: send request to '%s' service:"</span>, service);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_dump (request);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>request, self<span style="color:#666666">-&gt;</span>client);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The recv method waits for a reply message and returns that to the<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>caller.<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt><span style="white-space: pre-wrap;">---------------------------------------------------------------------</span><br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Returns the reply message or NULL if there was no reply. Does not<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>attempt to recover from a broker failure, this is not possible<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>without storing all unanswered requests and resending them all…</span></span></p>
<p>zmsg_t <span style="color:#666666">*</span><br>
<span style="color:#0000FF">mdcli_recv</span> (mdcli_t <span style="color:#666666">*</span>self)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Poll socket for a reply, with timeout</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_pollitem_t items <span style="white-space: pre-wrap;">[]</span> <span style="color:#666666">=</span> { { self<span style="color:#666666">-&gt;</span>client, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> } };<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> rc <span style="color:#666666">=</span> zmq_poll (items, <span style="color:#666666">1</span>, self<span style="color:#666666">-&gt;</span>timeout <span style="color:#666666">*</span> ZMQ_POLL_MSEC);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (rc <span style="color:#666666">==</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#008000">NULL</span>;<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span></p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If we got a reply, process it</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_recv (self<span style="color:#666666">-&gt;</span>client);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>verbose) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zclock_log (<span style="color:#BA2121">"I: received reply:"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_dump (msg);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Don't try to handle errors, just assert noisily</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>assert (zmsg_size (msg) <span style="color:#666666">&gt;=</span> <span style="color:#666666">4</span>);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt>zframe_t <span style="color:#666666">*</span>empty <span style="color:#666666">=</span> zmsg_pop (msg);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>assert (zframe_streq (empty, <span style="color:#BA2121">""</span>));<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_destroy (<span style="color:#666666">&amp;</span>empty);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt>zframe_t <span style="color:#666666">*</span>header <span style="color:#666666">=</span> zmsg_pop (msg);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>assert (zframe_streq (header, MDPC_CLIENT));<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_destroy (<span style="color:#666666">&amp;</span>header);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt>zframe_t <span style="color:#666666">*</span>service <span style="color:#666666">=</span> zmsg_pop (msg);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_destroy (<span style="color:#666666">&amp;</span>service);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>return</strong></span> msg;<tt><span style="white-space: pre-wrap;">     </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Success</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (zctx_interrupted)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"W: interrupt received, killing client…</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>verbose)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zclock_log (<span style="color:#BA2121">"W: permanent error, abandoning request"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#008000">NULL</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cs:mdcliapi2" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/hx:mdcliapi2" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:mdcliapi2" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:mdcliapi2" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/php:mdcliapi2" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:mdcliapi2" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rb:mdcliapi2" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/tcl:mdcliapi2" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | Clojure | CL | Delphi | Erlang | F# | Felix | Go | Haskell | Node.js | Objective-C | ooc | Perl | Q | Racket | Scala</a></span>
<p>The differences are:</p>
<ul>
<li>We use a DEALER socket instead of REQ, so we emulate REQ with an empty delimiter frame before each request and each response.</li>
<li>We don't retry requests; if the application needs to retry, it can do this itself.</li>
<li>We break the synchronous <tt>send</tt> method into separate <tt>send</tt> and <tt>recv</tt> methods.</li>
<li>The <tt>send</tt> method is asynchronous and returns immediately after sending. The caller can thus send a number of messages before getting a response.</li>
<li>The <tt>recv</tt> method waits for (with a timeout) one response and returns that to the caller.</li>
</ul>
<p>And here's the corresponding client test program, which sends 100,000 messages and then receives 100,000 back:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">mdclient2:&nbsp;Majordomo&nbsp;client&nbsp;application&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">mdclient2:&nbsp;Majordomo&nbsp;client&nbsp;application&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Majordomo Protocol client example - asynchronous<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Uses the mdcli API to hide all MDP aspects</span></p>
<p><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Lets us build this source without creating a library<br>
#include "mdcliapi2.c"</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">int</span> argc, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>argv <span style="white-space: pre-wrap;">[]</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> verbose <span style="color:#666666">=</span> (argc <span style="color:#666666">&gt;</span> <span style="color:#666666">1</span> <span style="color:#666666">&amp;&amp;</span> streq (argv <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>, <span style="color:#BA2121">"-v"</span>));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>mdcli_t <span style="color:#666666">*</span>session <span style="color:#666666">=</span> mdcli_new (<span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5555"</span>, verbose);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> count;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (count <span style="color:#666666">=</span> <span style="color:#666666">0</span>; count <span style="color:#666666">&lt;</span> <span style="color:#666666">100000</span>; count<span style="color:#666666">++</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_t <span style="color:#666666">*</span>request <span style="color:#666666">=</span> zmsg_new ();<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_pushstr (request, <span style="color:#BA2121">"Hello world"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>mdcli_send (session, <span style="color:#BA2121">"echo"</span>, <span style="color:#666666">&amp;</span>request);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (count <span style="color:#666666">=</span> <span style="color:#666666">0</span>; count <span style="color:#666666">&lt;</span> <span style="color:#666666">100000</span>; count<span style="color:#666666">++</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_t <span style="color:#666666">*</span>reply <span style="color:#666666">=</span> mdcli_recv (session);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (reply)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>reply);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted by Ctrl-C</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"%d replies received</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, count);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>mdcli_destroy (<span style="color:#666666">&amp;</span>session);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:mdclient2" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:mdclient2" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/hx:mdclient2" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:mdclient2" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:mdclient2" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/php:mdclient2" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:mdclient2" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rb:mdclient2" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/tcl:mdclient2" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | Clojure | CL | Delphi | Erlang | F# | Felix | Go | Haskell | Node.js | Objective-C | ooc | Perl | Q | Racket | Scala</a></span>
<p>The broker and worker are unchanged because we've not modified the protocol at all. We see an immediate improvement in performance. Here's the synchronous client chugging through 100K request-reply cycles:</p>
<div class="code">
<pre><code>$ time mdclient
100000 requests/replies processed

real    0m14.088s
user    0m1.310s
sys     0m2.670s</code>
</pre></div>
<p>And here's the asynchronous client, with a single worker:</p>
<div class="code">
<pre><code>$ time mdclient2
100000 replies received

real    0m8.730s
user    0m0.920s
sys     0m1.550s</code>
</pre></div>
<p>Twice as fast. Not bad, but let's fire up 10 workers and see how it handles the traffic</p>
<div class="code">
<pre><code>$ time mdclient2
100000 replies received

real    0m3.863s
user    0m0.730s
sys     0m0.470s</code>
</pre></div>
<p>It isn't fully asynchronous because workers get their messages on a strict last-used basis. But it will scale better with more workers. On my PC, after eight or so workers, it doesn't get any faster. Four cores only stretches so far. But we got a 4x improvement in throughput with just a few minutes' work. The broker is still unoptimized. It spends most of its time copying message frames around, instead of doing zero-copy, which it could. But we're getting 25K reliable request/reply calls a second, with pretty low effort.</p>
<p>However, the asynchronous Majordomo pattern isn't all roses. It has a fundamental weakness, namely that it cannot survive a broker crash without more work. If you look at the <tt>mdcliapi2</tt> code you'll see it does not attempt to reconnect after a failure. A proper reconnect would require the following:</p>
<ul>
<li>A number on every request and a matching number on every reply, which would ideally require a change to the protocol to enforce.</li>
<li>Tracking and holding onto all outstanding requests in the client API, i.e., those for which no reply has yet been received.</li>
<li>In case of failover, for the client API to <em>resend</em> all outstanding requests to the broker.</li>
</ul>
<p>It's not a deal breaker, but it does show that performance often means complexity. Is this worth doing for Majordomo? It depends on your use case. For a name lookup service you call once per session, no. For a web frontend serving thousands of clients, probably yes.</p>
<p><a name="Service-Discovery"></a><a name="header-101"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc100"><span><a href="http://zguide.zeromq.org/page:all#Service-Discovery">Service Discovery</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-100">prev</a> <a href="http://zguide.zeromq.org/page:all#header-102">next</a></td>
</tr>
</tbody></table>
<p>So, we have a nice service-oriented broker, but we have no way of knowing whether a particular service is available or not. We know whether a request failed, but we don't know why. It is useful to be able to ask the broker, "is the echo service running?" The most obvious way would be to modify our MDP/Client protocol to add commands to ask this. But MDP/Client has the great charm of being simple. Adding service discovery to it would make it as complex as the MDP/Worker protocol.</p>
<p>Another option is to do what email does, and ask that undeliverable requests be returned. This can work well in an asynchronous world, but it also adds complexity. We need ways to distinguish returned requests from replies and to handle these properly.</p>
<p>Let's try to use what we've already built, building on top of MDP instead of modifying it. Service discovery is, itself, a service. It might indeed be one of several management services, such as "disable service X", "provide statistics", and so on. What we want is a general, extensible solution that doesn't affect the protocol or existing applications.</p>
<p>So here's a small RFC that layers this on top of MDP: <a href="http://rfc.zeromq.org/spec:8">the Majordomo Management Interface (MMI)</a>. We already implemented it in the broker, though unless you read the whole thing you probably missed that. I'll explain how it works in the broker:</p>
<ul>
<li>When a client requests a service that starts with <tt>mmi.</tt>, instead of routing this to a worker, we handle it internally.</li>
</ul>
<ul>
<li>We handle just one service in this broker, which is <tt>mmi.service</tt>, the service discovery service.</li>
</ul>
<ul>
<li>The payload for the request is the name of an external service (a real one, provided by a worker).</li>
</ul>
<ul>
<li>The broker returns "200" (OK) or "404" (Not found), depending on whether there are workers registered for that service or not.</li>
</ul>
<p>Here's how we use the service discovery in an application:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">mmiecho:&nbsp;Service&nbsp;discovery&nbsp;over&nbsp;Majordomo&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">mmiecho:&nbsp;Service&nbsp;discovery&nbsp;over&nbsp;Majordomo&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>MMI echo query example</span></p>
<p><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Lets us build this source without creating a library<br>
#include "mdcliapi.c"</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">int</span> argc, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>argv <span style="white-space: pre-wrap;">[]</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> verbose <span style="color:#666666">=</span> (argc <span style="color:#666666">&gt;</span> <span style="color:#666666">1</span> <span style="color:#666666">&amp;&amp;</span> streq (argv <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>, <span style="color:#BA2121">"-v"</span>));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>mdcli_t <span style="color:#666666">*</span>session <span style="color:#666666">=</span> mdcli_new (<span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5555"</span>, verbose);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This is the service we want to look up</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>request <span style="color:#666666">=</span> zmsg_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_addstr (request, <span style="color:#BA2121">"echo"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This is the service we send our request to</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>reply <span style="color:#666666">=</span> mdcli_send (session, <span style="color:#BA2121">"mmi.service"</span>, <span style="color:#666666">&amp;</span>request);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (reply) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>reply_code <span style="color:#666666">=</span> zframe_strdup (zmsg_first (reply));<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"Lookup echo service: %s</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, reply_code);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (reply_code);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>reply);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"E: no response from broker, make sure it's running</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>mdcli_destroy (<span style="color:#666666">&amp;</span>session);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cs:mmiecho" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/go:mmiecho" target="_blank">Go</a> | <a href="http://zguide.zeromq.org/hx:mmiecho" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:mmiecho" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:mmiecho" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/php:mmiecho" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:mmiecho" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rb:mmiecho" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/tcl:mmiecho" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | Clojure | CL | Delphi | Erlang | F# | Felix | Haskell | Node.js | Objective-C | ooc | Perl | Q | Racket | Scala</a></span>
<p>Try this with and without a worker running, and you should see the little program report "200" or "404" accordingly. The implementation of MMI in our example broker is flimsy. For example, if a worker disappears, services remain "present". In practice, a broker should remove services that have no workers after some configurable timeout.</p>
<p><a name="Idempotent-Services"></a><a name="header-102"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc101"><span><a href="http://zguide.zeromq.org/page:all#Idempotent-Services">Idempotent Services</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-101">prev</a> <a href="http://zguide.zeromq.org/page:all#header-103">next</a></td>
</tr>
</tbody></table>
<p>Idempotency is not something you take a pill for. What it means is that it's safe to repeat an operation. Checking the clock is idempotent. Lending ones credit card to ones children is not. While many client-to-server use cases are idempotent, some are not. Examples of idempotent use cases include:</p>
<ul>
<li>Stateless task distribution, i.e., a pipeline where the servers are stateless workers that compute a reply based purely on the state provided by a request. In such a case, it's safe (though inefficient) to execute the same request many times.</li>
</ul>
<ul>
<li>A name service that translates logical addresses into endpoints to bind or connect to. In such a case, it's safe to make the same lookup request many times.</li>
</ul>
<p>And here are examples of a non-idempotent use cases:</p>
<ul>
<li>A logging service. One does not want the same log information recorded more than once.</li>
</ul>
<ul>
<li>Any service that has impact on downstream nodes, e.g., sends on information to other nodes. If that service gets the same request more than once, downstream nodes will get duplicate information.</li>
</ul>
<ul>
<li>Any service that modifies shared data in some non-idempotent way; e.g., a service that debits a bank account is not idempotent without extra work.</li>
</ul>
<p>When our server applications are not idempotent, we have to think more carefully about when exactly they might crash. If an application dies when it's idle, or while it's processing a request, that's usually fine. We can use database transactions to make sure a debit and a credit are always done together, if at all. If the server dies while sending its reply, that's a problem, because as far as it's concerned, it has done its work.</p>
<p>If the network dies just as the reply is making its way back to the client, the same problem arises. The client will think the server died and will resend the request, and the server will do the same work twice, which is not what we want.</p>
<p>To handle non-idempotent operations, use the fairly standard solution of detecting and rejecting duplicate requests. This means:</p>
<ul>
<li>The client must stamp every request with a unique client identifier and a unique message number.</li>
</ul>
<ul>
<li>The server, before sending back a reply, stores it using the combination of client ID and message number as a key.</li>
</ul>
<ul>
<li>The server, when getting a request from a given client, first checks whether it has a reply for that client ID and message number. If so, it does not process the request, but just resends the reply.</li>
</ul>
<p><a name="Disconnected-Reliability-Titanic-Pattern"></a><a name="header-103"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc102"><span><a href="http://zguide.zeromq.org/page:all#Disconnected-Reliability-Titanic-Pattern">Disconnected Reliability (Titanic Pattern)</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-102">prev</a> <a href="http://zguide.zeromq.org/page:all#header-104">next</a></td>
</tr>
</tbody></table>
<p>Once you realize that Majordomo is a "reliable" message broker, you might be tempted to add some spinning rust (that is, ferrous-based hard disk platters). After all, this works for all the enterprise messaging systems. It's such a tempting idea that it's a little sad to have to be negative toward it. But brutal cynicism is one of my specialties. So, some reasons you don't want rust-based brokers sitting in the center of your architecture are:</p>
<ul>
<li>As you've seen, the Lazy Pirate client performs surprisingly well. It works across a whole range of architectures, from direct client-to-server to distributed queue proxies. It does tend to assume that workers are stateless and idempotent. But we can work around that limitation without resorting to rust.</li>
</ul>
<ul>
<li>Rust brings a whole set of problems, from slow performance to additional pieces that you have to manage, repair, and handle 6 a.m. panics from, as they inevitably break at the start of daily operations. The beauty of the Pirate patterns in general is their simplicity. They won't crash. And if you're still worried about the hardware, you can move to a peer-to-peer pattern that has no broker at all. I'll explain later in this chapter.</li>
</ul>
<p>Having said this, however, there is one sane use case for rust-based reliability, which is an asynchronous disconnected network. It solves a major problem with Pirate, namely that a client has to wait for an answer in real time. If clients and workers are only sporadically connected (think of email as an analogy), we can't use a stateless network between clients and workers. We have to put state in the middle.</p>
<p>So, here's the Titanic pattern, in which we write messages to disk to ensure they never get lost, no matter how sporadically clients and workers are connected. As we did for service discovery, we're going to layer Titanic on top of MDP rather than extend it. It's wonderfully lazy because it means we can implement our fire-and-forget reliability in a specialized worker, rather than in the broker. This is excellent for several reasons:</p>
<ul>
<li>It is <em>much</em> easier because we divide and conquer: the broker handles message routing and the worker handles reliability.</li>
<li>It lets us mix brokers written in one language with workers written in another.</li>
<li>It lets us evolve the fire-and-forget technology independently.</li>
</ul>
<p>The only downside is that there's an extra network hop between broker and hard disk. The benefits are easily worth it.</p>
<p>There are many ways to make a persistent request-reply architecture. We'll aim for one that is simple and painless. The simplest design I could come up with, after playing with this for a few hours, is a "proxy service". That is, Titanic doesn't affect workers at all. If a client wants a reply immediately, it talks directly to a service and hopes the service is available. If a client is happy to wait a while, it talks to Titanic instead and asks, "hey, buddy, would you take care of this for me while I go buy my groceries?"</p>
<p><strong>Figure 51 - The Titanic Pattern</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig51.png" alt="fig51.png" class="image"></div>
<p>Titanic is thus both a worker and a client. The dialog between client and Titanic goes along these lines:</p>
<ul>
<li>Client: Please accept this request for me. Titanic: OK, done.</li>
<li>Client: Do you have a reply for me? Titanic: Yes, here it is. Or, no, not yet.</li>
<li>Client: OK, you can wipe that request now, I'm happy. Titanic: OK, done.</li>
</ul>
<p>Whereas the dialog between Titanic and broker and worker goes like this:</p>
<ul>
<li>Titanic: Hey, Broker, is there an coffee service? Broker: Uhm, Yeah, seems like.</li>
<li>Titanic: Hey, coffee service, please handle this for me.</li>
<li>Coffee: Sure, here you are.</li>
<li>Titanic: Sweeeeet!</li>
</ul>
<p>You can work through this and the possible failure scenarios. If a worker crashes while processing a request, Titanic retries indefinitely. If a reply gets lost somewhere, Titanic will retry. If the request gets processed but the client doesn't get the reply, it will ask again. If Titanic crashes while processing a request or a reply, the client will try again. As long as requests are fully committed to safe storage, work can't get lost.</p>
<p>The handshaking is pedantic, but can be pipelined, i.e., clients can use the asynchronous Majordomo pattern to do a lot of work and then get the responses later.</p>
<p>We need some way for a client to request <em>its</em> replies. We'll have many clients asking for the same services, and clients disappear and reappear with different identities. Here is a simple, reasonably secure solution:</p>
<ul>
<li>Every request generates a universally unique ID (UUID), which Titanic returns to the client after it has queued the request.</li>
<li>When a client asks for a reply, it must specify the UUID for the original request.</li>
</ul>
<p>In a realistic case, the client would want to store its request UUIDs safely, e.g., in a local database.</p>
<p>Before we jump off and write yet another formal specification (fun, fun!), let's consider how the client talks to Titanic. One way is to use a single service and send it three different request types. Another way, which seems simpler, is to use three services:</p>
<ul>
<li><tt>titanic.request</tt>: store a request message, and return a UUID for the request.</li>
<li><tt>titanic.reply</tt>: fetch a reply, if available, for a given request UUID.</li>
<li><tt>titanic.close</tt>: confirm that a reply has been stored and processed.</li>
</ul>
<p>We'll just make a multithreaded worker, which as we've seen from our multithreading experience with ZeroMQ, is trivial. However, let's first sketch what Titanic would look like in terms of ZeroMQ messages and frames. This gives us the <a href="http://rfc.zeromq.org/spec:9">Titanic Service Protocol (TSP)</a>.</p>
<p>Using TSP is clearly more work for client applications than accessing a service directly via MDP. Here's the shortest robust "echo" client example:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">ticlient:&nbsp;Titanic&nbsp;client&nbsp;example&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">ticlient:&nbsp;Titanic&nbsp;client&nbsp;example&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Titanic client example<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Implements client side of http:<span style="white-space: pre-wrap;">//</span>rfc.zeromq.org/spec:9</span></p>
<p><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Lets build this source without creating a library<br>
#include "mdcliapi.c"</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Calls a TSP service<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Returns response if successful (status code 200 OK), else NULL<br>
<span style="white-space: pre-wrap;">//</span></span></span><br>
<span style="color:#008000"><strong>static</strong></span> zmsg_t <span style="color:#666666">*</span><br>
<span style="color:#0000FF">s_service_call</span> (mdcli_t <span style="color:#666666">*</span>session, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>service, zmsg_t <span style="color:#666666"><span style="white-space: pre-wrap;">**</span></span>request_p)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>reply <span style="color:#666666">=</span> mdcli_send (session, service, request_p);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (reply) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_t <span style="color:#666666">*</span>status <span style="color:#666666">=</span> zmsg_pop (reply);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (zframe_streq (status, <span style="color:#BA2121">"200"</span>)) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_destroy (<span style="color:#666666">&amp;</span>status);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>return</strong></span> reply;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (zframe_streq (status, <span style="color:#BA2121">"400"</span>)) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"E: client fatal error, aborting</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>exit (EXIT_FAILURE);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (zframe_streq (status, <span style="color:#BA2121">"500"</span>)) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"E: server fatal error, aborting</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>exit (EXIT_FAILURE);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>exit (EXIT_SUCCESS);<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted or failed</em></span></p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>reply);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#008000">NULL</span>;<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Didn't succeed; don't care why not</em></span><br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The main task tests our service call by sending an echo request:</em></span></p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">int</span> argc, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>argv <span style="white-space: pre-wrap;">[]</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> verbose <span style="color:#666666">=</span> (argc <span style="color:#666666">&gt;</span> <span style="color:#666666">1</span> <span style="color:#666666">&amp;&amp;</span> streq (argv <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>, <span style="color:#BA2121">"-v"</span>));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>mdcli_t <span style="color:#666666">*</span>session <span style="color:#666666">=</span> mdcli_new (<span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5555"</span>, verbose);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>1. Send 'echo' request to Titanic</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>request <span style="color:#666666">=</span> zmsg_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_addstr (request, <span style="color:#BA2121">"echo"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_addstr (request, <span style="color:#BA2121">"Hello world"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>reply <span style="color:#666666">=</span> s_service_call (<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>session, <span style="color:#BA2121">"titanic.request"</span>, <span style="color:#666666">&amp;</span>request);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zframe_t <span style="color:#666666">*</span>uuid <span style="color:#666666">=</span> <span style="color:#008000">NULL</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (reply) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>uuid <span style="color:#666666">=</span> zmsg_pop (reply);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>reply);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_print (uuid, <span style="color:#BA2121">"I: request UUID "</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>2. Wait until we get a reply</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">!</span>zctx_interrupted) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zclock_sleep (<span style="color:#666666">100</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>request <span style="color:#666666">=</span> zmsg_new ();<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_add (request, zframe_dup (uuid));<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_t <span style="color:#666666">*</span>reply <span style="color:#666666">=</span> s_service_call (<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>session, <span style="color:#BA2121">"titanic.reply"</span>, <span style="color:#666666">&amp;</span>request);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (reply) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>reply_string <span style="color:#666666">=</span> zframe_strdup (zmsg_last (reply));<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"Reply: %s</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, reply_string);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>free (reply_string);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>reply);</p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>3. Close request</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>request <span style="color:#666666">=</span> zmsg_new ();<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_add (request, zframe_dup (uuid));<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>reply <span style="color:#666666">=</span> s_service_call (session, <span style="color:#BA2121">"titanic.close"</span>, <span style="color:#666666">&amp;</span>request);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>reply);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"I: no reply yet, trying again…</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zclock_sleep (<span style="color:#666666">5000</span>);<tt><span style="white-space: pre-wrap;">     </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Try again in 5 seconds</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zframe_destroy (<span style="color:#666666">&amp;</span>uuid);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>mdcli_destroy (<span style="color:#666666">&amp;</span>session);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cs:ticlient" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/hx:ticlient" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:ticlient" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/php:ticlient" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:ticlient" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rb:ticlient" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/tcl:ticlient" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | Clojure | CL | Delphi | Erlang | F# | Felix | Go | Haskell | Lua | Node.js | Objective-C | ooc | Perl | Q | Racket | Scala</a></span>
<p>Of course this can be, and should be, wrapped up in some kind of framework or API. It's not healthy to ask average application developers to learn the full details of messaging: it hurts their brains, costs time, and offers too many ways to make buggy complexity. Additionally, it makes it hard to add intelligence.</p>
<p>For example, this client blocks on each request whereas in a real application, we'd want to be doing useful work while tasks are executed. This requires some nontrivial plumbing to build a background thread and talk to that cleanly. It's the kind of thing you want to wrap in a nice simple API that the average developer cannot misuse. It's the same approach that we used for Majordomo.</p>
<p>Here's the Titanic implementation. This server handles the three services using three threads, as proposed. It does full persistence to disk using the most brutal approach possible: one file per message. It's so simple, it's scary. The only complex part is that it keeps a separate queue of all requests, to avoid reading the directory over and over:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">titanic:&nbsp;Titanic&nbsp;broker&nbsp;example&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">titanic:&nbsp;Titanic&nbsp;broker&nbsp;example&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Titanic service<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Implements server side of http:<span style="white-space: pre-wrap;">//</span>rfc.zeromq.org/spec:9</span></p>
<p><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Lets us build this source without creating a library<br>
#include "mdwrkapi.c"<br>
#include "mdcliapi.c"</p>
<p>#include "zfile.h"<br>
#include &lt;uuid/uuid.h&gt;</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Return a new UUID as a printable character string<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Caller must free returned string when finished with it</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">char</span> <span style="color:#666666">*</span><br>
<span style="color:#0000FF">s_generate_uuid</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> hex_char <span style="white-space: pre-wrap;">[]</span> <span style="color:#666666">=</span> <span style="color:#BA2121">"0123456789ABCDEF"</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>uuidstr <span style="color:#666666">=</span> zmalloc (<span style="color:#008000"><strong>sizeof</strong></span> (uuid_t) <span style="color:#666666">*</span> <span style="color:#666666">2</span> <span style="color:#666666">+</span> <span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>uuid_t uuid;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>uuid_generate (uuid);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> byte_nbr;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (byte_nbr <span style="color:#666666">=</span> <span style="color:#666666">0</span>; byte_nbr <span style="color:#666666">&lt;</span> <span style="color:#008000"><strong>sizeof</strong></span> (uuid_t); byte_nbr<span style="color:#666666">++</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>uuidstr <span style="white-space: pre-wrap;">[</span>byte_nbr <span style="color:#666666">*</span> <span style="color:#666666">2</span> <span style="color:#666666">+</span> <span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span> <span style="color:#666666">=</span> hex_char <span style="white-space: pre-wrap;">[</span>uuid <span style="white-space: pre-wrap;">[</span>byte_nbr<span style="white-space: pre-wrap;">]</span> <span style="color:#666666"><span style="white-space: pre-wrap;">&gt;&gt;</span></span> <span style="color:#666666">4</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>uuidstr <span style="white-space: pre-wrap;">[</span>byte_nbr <span style="color:#666666">*</span> <span style="color:#666666">2</span> <span style="color:#666666">+</span> <span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span> <span style="color:#666666">=</span> hex_char <span style="white-space: pre-wrap;">[</span>uuid <span style="white-space: pre-wrap;">[</span>byte_nbr<span style="white-space: pre-wrap;">]</span> <span style="color:#666666">&amp;</span> <span style="color:#666666">15</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> uuidstr;<br>
}<br>
<span style="color:#BC7A00"><br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Returns freshly allocated request filename for given UUID</span></p>
<p>#define TITANIC_DIR ".titanic"</p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">char</span> <span style="color:#666666">*</span><br>
<span style="color:#0000FF">s_request_filename</span> (<span style="color:#B00040">char</span> <span style="color:#666666">*</span>uuid) {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>filename <span style="color:#666666">=</span> malloc (<span style="color:#666666">256</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>snprintf (filename, <span style="color:#666666">256</span>, TITANIC_DIR <span style="color:#BA2121">"/%s.req"</span>, uuid);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> filename;<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Returns freshly allocated reply filename for given UUID</em></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">char</span> <span style="color:#666666">*</span><br>
<span style="color:#0000FF">s_reply_filename</span> (<span style="color:#B00040">char</span> <span style="color:#666666">*</span>uuid) {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>filename <span style="color:#666666">=</span> malloc (<span style="color:#666666">256</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>snprintf (filename, <span style="color:#666666">256</span>, TITANIC_DIR <span style="color:#BA2121">"/%s.rep"</span>, uuid);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> filename;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The <tt>titanic.request</tt> task waits for requests to this service. It writes<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>each request to disk and returns a UUID to the client. The client picks<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>up the reply asynchronously using the <tt>titanic.reply</tt> service:</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<span style="color:#0000FF">titanic_request</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>args, zctx_t <span style="color:#666666">*</span>ctx, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>pipe)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>mdwrk_t <span style="color:#666666">*</span>worker <span style="color:#666666">=</span> mdwrk_new (<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5555"</span>, <span style="color:#BA2121">"titanic.request"</span>, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>reply <span style="color:#666666">=</span> <span style="color:#008000">NULL</span>;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send reply if it's not null</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>And then get next request from broker</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_t <span style="color:#666666">*</span>request <span style="color:#666666">=</span> mdwrk_recv (worker, <span style="color:#666666">&amp;</span>reply);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>request)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">      </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted, exit</em></span></p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Ensure message directory exists</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zfile_mkdir (TITANIC_DIR);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Generate UUID and save message to disk</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>uuid <span style="color:#666666">=</span> s_generate_uuid ();<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>filename <span style="color:#666666">=</span> s_request_filename (uuid);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">FILE</span> <span style="color:#666666">*</span>file <span style="color:#666666">=</span> fopen (filename, <span style="color:#BA2121">"w"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>assert (file);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_save (request, file);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>fclose (file);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (filename);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>request);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send UUID through to message queue</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>reply <span style="color:#666666">=</span> zmsg_new ();<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_addstr (reply, uuid);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>reply, pipe);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Now send UUID back to client</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Done by the mdwrk_recv() at the top of the loop</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>reply <span style="color:#666666">=</span> zmsg_new ();<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_addstr (reply, <span style="color:#BA2121">"200"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_addstr (reply, uuid);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (uuid);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>mdwrk_destroy (<span style="color:#666666">&amp;</span>worker);<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The <tt>titanic.reply</tt> task checks if there's a reply for the specified<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>request (by UUID), and returns a 200 (OK), 300 (Pending), or 400<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>(Unknown) accordingly:</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span> <span style="color:#666666">*</span><br>
<span style="color:#0000FF">titanic_reply</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>context)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>mdwrk_t <span style="color:#666666">*</span>worker <span style="color:#666666">=</span> mdwrk_new (<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5555"</span>, <span style="color:#BA2121">"titanic.reply"</span>, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>reply <span style="color:#666666">=</span> <span style="color:#008000">NULL</span>;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_t <span style="color:#666666">*</span>request <span style="color:#666666">=</span> mdwrk_recv (worker, <span style="color:#666666">&amp;</span>reply);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>request)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">      </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted, exit</em></span></p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>uuid <span style="color:#666666">=</span> zmsg_popstr (request);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>req_filename <span style="color:#666666">=</span> s_request_filename (uuid);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>rep_filename <span style="color:#666666">=</span> s_reply_filename (uuid);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (zfile_exists (rep_filename)) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">FILE</span> <span style="color:#666666">*</span>file <span style="color:#666666">=</span> fopen (rep_filename, <span style="color:#BA2121">"r"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>assert (file);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>reply <span style="color:#666666">=</span> zmsg_load (<span style="color:#008000">NULL</span>, file);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_pushstr (reply, <span style="color:#BA2121">"200"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>fclose (file);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>reply <span style="color:#666666">=</span> zmsg_new ();<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (zfile_exists (req_filename))<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_pushstr (reply, <span style="color:#BA2121">"300"</span>); <span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span>Pending</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_pushstr (reply, <span style="color:#BA2121">"400"</span>); <span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span>Unknown</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>request);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (uuid);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (req_filename);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (rep_filename);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>mdwrk_destroy (<span style="color:#666666">&amp;</span>worker);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The <tt>titanic.close</tt> task removes any waiting replies for the request<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>(specified by UUID). It's idempotent, so it is safe to call more than<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>once in a row:</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span> <span style="color:#666666">*</span><br>
<span style="color:#0000FF">titanic_close</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>context)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>mdwrk_t <span style="color:#666666">*</span>worker <span style="color:#666666">=</span> mdwrk_new (<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5555"</span>, <span style="color:#BA2121">"titanic.close"</span>, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>reply <span style="color:#666666">=</span> <span style="color:#008000">NULL</span>;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_t <span style="color:#666666">*</span>request <span style="color:#666666">=</span> mdwrk_recv (worker, <span style="color:#666666">&amp;</span>reply);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>request)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">      </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted, exit</em></span></p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>uuid <span style="color:#666666">=</span> zmsg_popstr (request);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>req_filename <span style="color:#666666">=</span> s_request_filename (uuid);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>rep_filename <span style="color:#666666">=</span> s_reply_filename (uuid);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zfile_delete (req_filename);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zfile_delete (rep_filename);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (uuid);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (req_filename);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (rep_filename);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>request);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>reply <span style="color:#666666">=</span> zmsg_new ();<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_addstr (reply, <span style="color:#BA2121">"200"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>mdwrk_destroy (<span style="color:#666666">&amp;</span>worker);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This is the main thread for the Titanic worker. It starts three child<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>threads; for the request, reply, and close services. It then dispatches<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>requests to workers using a simple brute force disk queue. It receives<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>request UUIDs from the <tt>titanic.request</tt> service, saves these to a disk<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>file, and then throws each request at MDP workers until it gets a<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>response.</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">int</span> s_service_success (<span style="color:#B00040">char</span> <span style="color:#666666">*</span>uuid);</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">int</span> argc, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>argv <span style="white-space: pre-wrap;">[]</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> verbose <span style="color:#666666">=</span> (argc <span style="color:#666666">&gt;</span> <span style="color:#666666">1</span> <span style="color:#666666">&amp;&amp;</span> streq (argv <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>, <span style="color:#BA2121">"-v"</span>));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>request_pipe <span style="color:#666666">=</span> zthread_fork (ctx, titanic_request, <span style="color:#008000">NULL</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zthread_new (titanic_reply, <span style="color:#008000">NULL</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zthread_new (titanic_close, <span style="color:#008000">NULL</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Main dispatcher loop</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We'll dispatch once per second, if there's no activity</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_pollitem_t items <span style="white-space: pre-wrap;">[]</span> <span style="color:#666666">=</span> { { request_pipe, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> } };<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> rc <span style="color:#666666">=</span> zmq_poll (items, <span style="color:#666666">1</span>, <span style="color:#666666">1000</span> <span style="color:#666666">*</span> ZMQ_POLL_MSEC);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (rc <span style="color:#666666">==</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Ensure message directory exists</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zfile_mkdir (TITANIC_DIR);</p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Append UUID to queue, prefixed with '-' for pending</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_recv (request_pipe);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>msg)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">FILE</span> <span style="color:#666666">*</span>file <span style="color:#666666">=</span> fopen (TITANIC_DIR <span style="color:#BA2121">"/queue"</span>, <span style="color:#BA2121">"a"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>uuid <span style="color:#666666">=</span> zmsg_popstr (msg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>fprintf (file, <span style="color:#BA2121">"-%s</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, uuid);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>fclose (file);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>free (uuid);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>msg);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Brute force dispatcher</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> entry <span style="white-space: pre-wrap;">[]</span> <span style="color:#666666">=</span> <span style="color:#BA2121">"?…….:…….:…….:…….:"</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">FILE</span> <span style="color:#666666">*</span>file <span style="color:#666666">=</span> fopen (TITANIC_DIR <span style="color:#BA2121">"/queue"</span>, <span style="color:#BA2121">"r+"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>while</strong></span> (file <span style="color:#666666">&amp;&amp;</span> fread (entry, <span style="color:#666666">33</span>, <span style="color:#666666">1</span>, file) <span style="color:#666666">==</span> <span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>UUID is prefixed with '-' if still waiting</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (entry <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span> <span style="color:#666666">==</span> <span style="color:#BA2121">'-'</span>) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>if</strong></span> (verbose)<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>printf (<span style="color:#BA2121">"I: processing request %s</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, entry <span style="color:#666666">+</span> <span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>if</strong></span> (s_service_success (entry <span style="color:#666666">+</span> <span style="color:#666666">1</span>)) {<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Mark queue entry as processed</em></span><br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>fseek (file, <span style="color:#666666">-</span><span style="color:#666666">33</span>, SEEK_CUR);<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>fwrite (<span style="color:#BA2121">"+"</span>, <span style="color:#666666">1</span>, <span style="color:#666666">1</span>, file);<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>fseek (file, <span style="color:#666666">32</span>, SEEK_CUR);<br>
<tt><span style="white-space: pre-wrap;">                </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Skip end of line, LF or CRLF</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (fgetc (file) <span style="color:#666666">==</span> <span style="color:#BA2121">'\r'</span>)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>fgetc (file);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (zctx_interrupted)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (file)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>fclose (file);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Here, we first check if the requested MDP service is defined or not,<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>using a MMI lookup to the Majordomo broker. If the service exists,<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>we send a request and wait for a reply using the conventional MDP<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>client API. This is not meant to be fast, just very simple:</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">int</span><br>
<span style="color:#0000FF">s_service_success</span> (<span style="color:#B00040">char</span> <span style="color:#666666">*</span>uuid)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Load request message, service will be first frame</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>filename <span style="color:#666666">=</span> s_request_filename (uuid);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">FILE</span> <span style="color:#666666">*</span>file <span style="color:#666666">=</span> fopen (filename, <span style="color:#BA2121">"r"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>free (filename);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If the client already closed request, treat as successful</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>file)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">1</span>;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>request <span style="color:#666666">=</span> zmsg_load (<span style="color:#008000">NULL</span>, file);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>fclose (file);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zframe_t <span style="color:#666666">*</span>service <span style="color:#666666">=</span> zmsg_pop (request);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>service_name <span style="color:#666666">=</span> zframe_strdup (service);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Create MDP client session with short timeout</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>mdcli_t <span style="color:#666666">*</span>client <span style="color:#666666">=</span> mdcli_new (<span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5555"</span>, <span style="color:#008000">false</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>mdcli_set_timeout (client, <span style="color:#666666">1000</span>);<tt><span style="white-space: pre-wrap;">  </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>1 sec</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>mdcli_set_retries (client, <span style="color:#666666">1</span>);<tt><span style="white-space: pre-wrap;">     </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>only 1 retry</em></span></p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Use MMI protocol to check if service is available</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>mmi_request <span style="color:#666666">=</span> zmsg_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_add (mmi_request, service);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>mmi_reply <span style="color:#666666">=</span> mdcli_send (client, <span style="color:#BA2121">"mmi.service"</span>, <span style="color:#666666">&amp;</span>mmi_request);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> service_ok <span style="color:#666666">=</span> (mmi_reply<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#666666">&amp;&amp;</span> zframe_streq (zmsg_first (mmi_reply), <span style="color:#BA2121">"200"</span>));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>mmi_reply);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> result <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (service_ok) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_t <span style="color:#666666">*</span>reply <span style="color:#666666">=</span> mdcli_send (client, service_name, <span style="color:#666666">&amp;</span>request);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (reply) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>filename <span style="color:#666666">=</span> s_reply_filename (uuid);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">FILE</span> <span style="color:#666666">*</span>file <span style="color:#666666">=</span> fopen (filename, <span style="color:#BA2121">"w"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>assert (file);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_save (reply, file);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>fclose (file);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>free (filename);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>result <span style="color:#666666">=</span> <span style="color:#666666">1</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>reply);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>request);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>mdcli_destroy (<span style="color:#666666">&amp;</span>client);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>free (service_name);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> result;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cs:titanic" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/hx:titanic" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:titanic" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/php:titanic" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:titanic" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rb:titanic" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/tcl:titanic" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | Clojure | CL | Delphi | Erlang | F# | Felix | Go | Haskell | Lua | Node.js | Objective-C | ooc | Perl | Q | Racket | Scala</a></span>
<p>To test this, start <tt>mdbroker</tt> and <tt>titanic</tt>, and then run <tt>ticlient</tt>. Now start <tt>mdworker</tt> arbitrarily, and you should see the client getting a response and exiting happily.</p>
<p>Some notes about this code:</p>
<ul>
<li>Note that some loops start by sending, others by receiving messages. This is because Titanic acts both as a client and a worker in different roles.</li>
<li>The Titanic broker uses the MMI service discovery protocol to send requests only to services that appear to be running. Since the MMI implementation in our little Majordomo broker is quite poor, this won't work all the time.</li>
<li>We use an inproc connection to send new request data from the <tt>titanic.request</tt> service through to the main dispatcher. This saves the dispatcher from having to scan the disk directory, load all request files, and sort them by date/time.</li>
</ul>
<p>The important thing about this example is not performance (which, although I haven't tested it, is surely terrible), but how well it implements the reliability contract. To try it, start the mdbroker and titanic programs. Then start the ticlient, and then start the mdworker echo service. You can run all four of these using the <tt>-v</tt> option to do verbose activity tracing. You can stop and restart any piece <em>except the client</em> and nothing will get lost.</p>
<p>If you want to use Titanic in real cases, you'll rapidly be asking "how do we make this faster?"</p>
<p>Here's what I'd do, starting with the example implementation:</p>
<ul>
<li>Use a single disk file for all data, rather than multiple files. Operating systems are usually better at handling a few large files than many smaller ones.</li>
<li>Organize that disk file as a circular buffer so that new requests can be written contiguously (with very occasional wraparound). One thread, writing full speed to a disk file, can work rapidly.</li>
<li>Keep the index in memory and rebuild the index at startup time, from the disk buffer. This saves the extra disk head flutter needed to keep the index fully safe on disk. You would want an fsync after every message, or every N milliseconds if you were prepared to lose the last M messages in case of a system failure.</li>
<li>Use a solid-state drive rather than spinning iron oxide platters.</li>
<li>Pre-allocate the entire file, or allocate it in large chunks, which allows the circular buffer to grow and shrink as needed. This avoids fragmentation and ensures that most reads and writes are contiguous.</li>
</ul>
<p>And so on. What I'd not recommend is storing messages in a database, not even a "fast" key/value store, unless you really like a specific database and don't have performance worries. You will pay a steep price for the abstraction, ten to a thousand times over a raw disk file.</p>
<p>If you want to make Titanic <em>even more reliable</em>, duplicate the requests to a second server, which you'd place in a second location just far away enough to survive a nuclear attack on your primary location, yet not so far that you get too much latency.</p>
<p>If you want to make Titanic <em>much faster and less reliable</em>, store requests and replies purely in memory. This will give you the functionality of a disconnected network, but requests won't survive a crash of the Titanic server itself.</p>
<p><a name="High-Availability-Pair-Binary-Star-Pattern"></a><a name="header-104"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc103"><span><a href="http://zguide.zeromq.org/page:all#High-Availability-Pair-Binary-Star-Pattern">High-Availability Pair (Binary Star Pattern)</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-103">prev</a> <a href="http://zguide.zeromq.org/page:all#header-105">next</a></td>
</tr>
</tbody></table>
<p><strong>Figure 52 - High-Availability Pair, Normal Operation</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig52.png" alt="fig52.png" class="image"></div>
<p>The Binary Star pattern puts two servers in a primary-backup high-availability pair. At any given time, one of these (the active) accepts connections from client applications. The other (the passive) does nothing, but the two servers monitor each other. If the active disappears from the network, after a certain time the passive takes over as active.</p>
<p>We developed the Binary Star pattern at iMatix for our <a href="http://www.openamq.org/">OpenAMQ server</a>. We designed it:</p>
<ul>
<li>To provide a straightforward high-availability solution.</li>
<li>To be simple enough to actually understand and use.</li>
<li>To fail over reliably when needed, and only when needed.</li>
</ul>
<p>Assuming we have a Binary Star pair running, here are the different scenarios that will result in a failover:</p>
<ul>
<li>The hardware running the primary server has a fatal problem (power supply explodes, machine catches fire, or someone simply unplugs it by mistake), and disappears. Applications see this, and reconnect to the backup server.</li>
<li>The network segment on which the primary server sits crashes—perhaps a router gets hit by a power spike—and applications start to reconnect to the backup server.</li>
<li>The primary server crashes or is killed by the operator and does not restart automatically.</li>
</ul>
<p><strong>Figure 53 - High-availability Pair During Failover</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig53.png" alt="fig53.png" class="image"></div>
<p>Recovery from failover works as follows:</p>
<ul>
<li>The operators restart the primary server and fix whatever problems were causing it to disappear from the network.</li>
<li>The operators stop the backup server at a moment when it will cause minimal disruption to applications.</li>
<li>When applications have reconnected to the primary server, the operators restart the backup server.</li>
</ul>
<p>Recovery (to using the primary server as active) is a manual operation. Painful experience teaches us that automatic recovery is undesirable. There are several reasons:</p>
<ul>
<li>Failover creates an interruption of service to applications, possibly lasting 10-30 seconds. If there is a real emergency, this is much better than total outage. But if recovery creates a further 10-30 second outage, it is better that this happens off-peak, when users have gone off the network.</li>
</ul>
<ul>
<li>When there is an emergency, the absolute first priority is certainty for those trying to fix things. Automatic recovery creates uncertainty for system administrators, who can no longer be sure which server is in charge without double-checking.</li>
</ul>
<ul>
<li>Automatic recovery can create situations where networks fail over and then recover, placing operators in the difficult position of analyzing what happened. There was an interruption of service, but the cause isn't clear.</li>
</ul>
<p>Having said this, the Binary Star pattern will fail back to the primary server if this is running (again) and the backup server fails. In fact, this is how we provoke recovery.</p>
<p>The shutdown process for a Binary Star pair is to either:</p>
<ol>
<li>Stop the passive server and then stop the active server at any later time, or</li>
<li>Stop both servers in any order but within a few seconds of each other.</li>
</ol>
<p>Stopping the active and then the passive server with any delay longer than the failover timeout will cause applications to disconnect, then reconnect, and then disconnect again, which may disturb users.</p>
<p><a name="Detailed-Requirements"></a><a name="header-105"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc104"><span><a href="http://zguide.zeromq.org/page:all#Detailed-Requirements">Detailed Requirements</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-104">prev</a> <a href="http://zguide.zeromq.org/page:all#header-106">next</a></td>
</tr>
</tbody></table>
<p>Binary Star is as simple as it can be, while still working accurately. In fact, the current design is the third complete redesign. Each of the previous designs we found to be too complex, trying to do too much, and we stripped out functionality until we came to a design that was understandable, easy to use, and reliable enough to be worth using.</p>
<p>These are our requirements for a high-availability architecture:</p>
<ul>
<li>The failover is meant to provide insurance against catastrophic system failures, such as hardware breakdown, fire, accident, and so on. There are simpler ways to recover from ordinary server crashes and we already covered these.</li>
</ul>
<ul>
<li>Failover time should be under 60 seconds and preferably under 10 seconds.</li>
</ul>
<ul>
<li>Failover has to happen automatically, whereas recovery must happen manually. We want applications to switch over to the backup server automatically, but we do not want them to switch back to the primary server except when the operators have fixed whatever problem there was and decided that it is a good time to interrupt applications again.</li>
</ul>
<ul>
<li>The semantics for client applications should be simple and easy for developers to understand. Ideally, they should be hidden in the client API.</li>
</ul>
<ul>
<li>There should be clear instructions for network architects on how to avoid designs that could lead to <em>split brain syndrome</em>, in which both servers in a Binary Star pair think they are the active server.</li>
</ul>
<ul>
<li>There should be no dependencies on the order in which the two servers are started.</li>
</ul>
<ul>
<li>It must be possible to make planned stops and restarts of either server without stopping client applications (though they may be forced to reconnect).</li>
</ul>
<ul>
<li>Operators must be able to monitor both servers at all times.</li>
</ul>
<ul>
<li>It must be possible to connect the two servers using a high-speed dedicated network connection. That is, failover synchronization must be able to use a specific IP route.</li>
</ul>
<p>We make the following assumptions:</p>
<ul>
<li>A single backup server provides enough insurance; we don't need multiple levels of backup.</li>
</ul>
<ul>
<li>The primary and backup servers are equally capable of carrying the application load. We do not attempt to balance load across the servers.</li>
</ul>
<ul>
<li>There is sufficient budget to cover a fully redundant backup server that does nothing almost all the time.</li>
</ul>
<p>We don't attempt to cover the following:</p>
<ul>
<li>The use of an active backup server or load balancing. In a Binary Star pair, the backup server is inactive and does no useful work until the primary server goes offline.</li>
</ul>
<ul>
<li>The handling of persistent messages or transactions in any way. We assume the existence of a network of unreliable (and probably untrusted) servers or Binary Star pairs.</li>
</ul>
<ul>
<li>Any automatic exploration of the network. The Binary Star pair is manually and explicitly defined in the network and is known to applications (at least in their configuration data).</li>
</ul>
<ul>
<li>Replication of state or messages between servers. All server-side state must be recreated by applications when they fail over.</li>
</ul>
<p>Here is the key terminology that we use in Binary Star:</p>
<ul>
<li><em>Primary</em>: the server that is normally or initially active.</li>
</ul>
<ul>
<li><em>Backup</em>: the server that is normally passive. It will become active if and when the primary server disappears from the network, and when client applications ask the backup server to connect.</li>
</ul>
<ul>
<li><em>Active</em>: the server that accepts client connections. There is at most one active server.</li>
</ul>
<ul>
<li><em>Passive</em>: the server that takes over if the active disappears. Note that when a Binary Star pair is running normally, the primary server is active, and the backup is passive. When a failover has happened, the roles are switched.</li>
</ul>
<p>To configure a Binary Star pair, you need to:</p>
<ol>
<li>Tell the primary server where the backup server is located.</li>
<li>Tell the backup server where the primary server is located.</li>
<li>Optionally, tune the failover response times, which must be the same for both servers.</li>
</ol>
<p>The main tuning concern is how frequently you want the servers to check their peering status, and how quickly you want to activate failover. In our example, the failover timeout value defaults to 2,000 msec. If you reduce this, the backup server will take over as active more rapidly but may take over in cases where the primary server could recover. For example, you may have wrapped the primary server in a shell script that restarts it if it crashes. In that case, the timeout should be higher than the time needed to restart the primary server.</p>
<p>For client applications to work properly with a Binary Star pair, they must:</p>
<ol>
<li>Know both server addresses.</li>
<li>Try to connect to the primary server, and if that fails, to the backup server.</li>
<li>Detect a failed connection, typically using heartbeating.</li>
<li>Try to reconnect to the primary, and then backup (in that order), with a delay between retries that is at least as high as the server failover timeout.</li>
<li>Recreate all of the state they require on a server.</li>
<li>Retransmit messages lost during a failover, if messages need to be reliable.</li>
</ol>
<p>It's not trivial work, and we'd usually wrap this in an API that hides it from real end-user applications.</p>
<p>These are the main limitations of the Binary Star pattern:</p>
<ul>
<li>A server process cannot be part of more than one Binary Star pair.</li>
<li>A primary server can have a single backup server, and no more.</li>
<li>The passive server does no useful work, and is thus wasted.</li>
<li>The backup server must be capable of handling full application loads.</li>
<li>Failover configuration cannot be modified at runtime.</li>
<li>Client applications must do some work to benefit from failover.</li>
</ul>
<p><a name="Preventing-Split-Brain-Syndrome"></a><a name="header-106"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc105"><span><a href="http://zguide.zeromq.org/page:all#Preventing-Split-Brain-Syndrome">Preventing Split-Brain Syndrome</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-105">prev</a> <a href="http://zguide.zeromq.org/page:all#header-107">next</a></td>
</tr>
</tbody></table>
<p><em>Split-brain syndrome</em> occurs when different parts of a cluster think they are active at the same time. It causes applications to stop seeing each other. Binary Star has an algorithm for detecting and eliminating split brain, which is based on a three-way decision mechanism (a server will not decide to become active until it gets application connection requests and it cannot see its peer server).</p>
<p>However, it is still possible to (mis)design a network to fool this algorithm. A typical scenario would be a Binary Star pair, that is distributed between two buildings, where each building also had a set of applications and where there was a single network link between both buildings. Breaking this link would create two sets of client applications, each with half of the Binary Star pair, and each failover server would become active.</p>
<p>To prevent split-brain situations, we must connect a Binary Star pair using a dedicated network link, which can be as simple as plugging them both into the same switch or, better, using a crossover cable directly between two machines.</p>
<p>We must not split a Binary Star architecture into two islands, each with a set of applications. While this may be a common type of network architecture, you should use federation, not high-availability failover, in such cases.</p>
<p>A suitably paranoid network configuration would use two private cluster interconnects, rather than a single one. Further, the network cards used for the cluster would be different from those used for message traffic, and possibly even on different paths on the server hardware. The goal is to separate possible failures in the network from possible failures in the cluster. Network ports can have a relatively high failure rate.</p>
<p><a name="Binary-Star-Implementation"></a><a name="header-107"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc106"><span><a href="http://zguide.zeromq.org/page:all#Binary-Star-Implementation">Binary Star Implementation</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-106">prev</a> <a href="http://zguide.zeromq.org/page:all#header-108">next</a></td>
</tr>
</tbody></table>
<p>Without further ado, here is a proof-of-concept implementation of the Binary Star server. The primary and backup servers run the same code, you choose their roles when you run the code:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">bstarsrv:&nbsp;Binary&nbsp;Star&nbsp;server&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">bstarsrv:&nbsp;Binary&nbsp;Star&nbsp;server&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Binary Star server proof-of-concept implementation. This server does no<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>real work; it just demonstrates the Binary Star failover model.</span></p>
<p>#include "czmq.h"</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>States we can be in at any point in time</em></span><br>
<span style="color:#008000"><strong>typedef</strong></span> <span style="color:#008000"><strong>enum</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>STATE_PRIMARY <span style="color:#666666">=</span> <span style="color:#666666">1</span>,<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Primary, waiting for peer to connect</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>STATE_BACKUP <span style="color:#666666">=</span> <span style="color:#666666">2</span>,<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Backup, waiting for peer to connect</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>STATE_ACTIVE <span style="color:#666666">=</span> <span style="color:#666666">3</span>,<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Active - accepting connections</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>STATE_PASSIVE <span style="color:#666666">=</span> <span style="color:#666666">4</span><tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Passive - not accepting connections</em></span><br>
} state_t;</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Events, which start with the states our peer can be in</em></span><br>
<span style="color:#008000"><strong>typedef</strong></span> <span style="color:#008000"><strong>enum</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>PEER_PRIMARY <span style="color:#666666">=</span> <span style="color:#666666">1</span>,<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>HA peer is pending primary</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>PEER_BACKUP <span style="color:#666666">=</span> <span style="color:#666666">2</span>,<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>HA peer is pending backup</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>PEER_ACTIVE <span style="color:#666666">=</span> <span style="color:#666666">3</span>,<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>HA peer is active</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>PEER_PASSIVE <span style="color:#666666">=</span> <span style="color:#666666">4</span>,<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>HA peer is passive</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>CLIENT_REQUEST <span style="color:#666666">=</span> <span style="color:#666666">5</span><tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Client makes request</em></span><br>
} event_t;</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Our finite state machine</em></span><br>
<span style="color:#008000"><strong>typedef</strong></span> <span style="color:#008000"><strong>struct</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>state_t state;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Current state</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>event_t event;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Current event</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int64_t</span> peer_expiry;<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>When peer is considered 'dead'</em></span><br>
} bstar_t;<br>
<span style="color:#BC7A00"><br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We send state information this often<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If peer doesn't respond in two heartbeats, it is 'dead'<br>
#define HEARTBEAT 1000<tt><span style="white-space: pre-wrap;">          </span></tt></span><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>In msecs</em></span></p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The heart of the Binary Star design is its finite-state machine (FSM).<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The FSM runs one event at a time. We apply an event to the current state,<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>which checks if the event is accepted, and if so, sets a new state:</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> bool<br>
<span style="color:#0000FF">s_state_machine</span> (bstar_t <span style="color:#666666">*</span>fsm)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>bool exception <span style="color:#666666">=</span> <span style="color:#008000">false</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>These are the PRIMARY and BACKUP states; we're waiting to become</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>ACTIVE or PASSIVE depending on events we get from our peer:</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (fsm<span style="color:#666666">-&gt;</span>state <span style="color:#666666">==</span> STATE_PRIMARY) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (fsm<span style="color:#666666">-&gt;</span>event <span style="color:#666666">==</span> PEER_BACKUP) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"I: connected to backup (passive), ready active</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>fsm<span style="color:#666666">-&gt;</span>state <span style="color:#666666">=</span> STATE_ACTIVE;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (fsm<span style="color:#666666">-&gt;</span>event <span style="color:#666666">==</span> PEER_ACTIVE) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"I: connected to backup (active), ready passive</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>fsm<span style="color:#666666">-&gt;</span>state <span style="color:#666666">=</span> STATE_PASSIVE;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Accept client connections</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (fsm<span style="color:#666666">-&gt;</span>state <span style="color:#666666">==</span> STATE_BACKUP) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (fsm<span style="color:#666666">-&gt;</span>event <span style="color:#666666">==</span> PEER_ACTIVE) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"I: connected to primary (active), ready passive</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>fsm<span style="color:#666666">-&gt;</span>state <span style="color:#666666">=</span> STATE_PASSIVE;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Reject client connections when acting as backup</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (fsm<span style="color:#666666">-&gt;</span>event <span style="color:#666666">==</span> CLIENT_REQUEST)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>exception <span style="color:#666666">=</span> <span style="color:#008000">true</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>These are the ACTIVE and PASSIVE states:</em></span></p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (fsm<span style="color:#666666">-&gt;</span>state <span style="color:#666666">==</span> STATE_ACTIVE) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (fsm<span style="color:#666666">-&gt;</span>event <span style="color:#666666">==</span> PEER_ACTIVE) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Two actives would mean split-brain</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"E: fatal error - dual actives, aborting</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>exception <span style="color:#666666">=</span> <span style="color:#008000">true</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Server is passive</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>CLIENT_REQUEST events can trigger failover if peer looks dead</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (fsm<span style="color:#666666">-&gt;</span>state <span style="color:#666666">==</span> STATE_PASSIVE) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (fsm<span style="color:#666666">-&gt;</span>event <span style="color:#666666">==</span> PEER_PRIMARY) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Peer is restarting - become active, peer will go passive</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"I: primary (passive) is restarting, ready active</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>fsm<span style="color:#666666">-&gt;</span>state <span style="color:#666666">=</span> STATE_ACTIVE;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (fsm<span style="color:#666666">-&gt;</span>event <span style="color:#666666">==</span> PEER_BACKUP) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Peer is restarting - become active, peer will go passive</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"I: backup (passive) is restarting, ready active</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>fsm<span style="color:#666666">-&gt;</span>state <span style="color:#666666">=</span> STATE_ACTIVE;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (fsm<span style="color:#666666">-&gt;</span>event <span style="color:#666666">==</span> PEER_PASSIVE) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Two passives would mean cluster would be non-responsive</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"E: fatal error - dual passives, aborting</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>exception <span style="color:#666666">=</span> <span style="color:#008000">true</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (fsm<span style="color:#666666">-&gt;</span>event <span style="color:#666666">==</span> CLIENT_REQUEST) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Peer becomes active if timeout has passed</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>It's the client request that triggers the failover</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>assert (fsm<span style="color:#666666">-&gt;</span>peer_expiry <span style="color:#666666">&gt;</span> <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (zclock_time () <span style="color:#666666">&gt;=</span> fsm<span style="color:#666666">-&gt;</span>peer_expiry) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If peer is dead, switch to the active state</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt>printf (<span style="color:#BA2121">"I: failover successful, ready active</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>fsm<span style="color:#666666">-&gt;</span>state <span style="color:#666666">=</span> STATE_ACTIVE;<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If peer is alive, reject connections</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt>exception <span style="color:#666666">=</span> <span style="color:#008000">true</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> exception;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This is our main task. First we bind/connect our sockets with our<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>peer and make sure we will get state messages correctly. We use<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>three sockets; one to publish state, one to subscribe to state, and<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>one for client requests/replies:</span></span></p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">int</span> argc, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>argv <span style="white-space: pre-wrap;">[]</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Arguments can be either of:</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">      </span></tt>-p<tt><span style="white-space: pre-wrap;">  </span></tt>primary server, at tcp:<span style="white-space: pre-wrap;">//</span>localhost:5001</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">      </span></tt>-b<tt><span style="white-space: pre-wrap;">  </span></tt>backup server, at tcp:<span style="white-space: pre-wrap;">//</span>localhost:5002</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>statepub <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_PUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>statesub <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_SUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_set_subscribe (statesub, <span style="color:#BA2121">""</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>frontend <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_ROUTER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>bstar_t fsm <span style="color:#666666">=</span> { <span style="color:#666666">0</span> };</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (argc <span style="color:#666666">==</span> <span style="color:#666666">2</span> <span style="color:#666666">&amp;&amp;</span> streq (argv <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>, <span style="color:#BA2121">"-p"</span>)) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"I: Primary active, waiting for backup (passive)</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zsocket_bind (frontend, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5001"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zsocket_bind (statepub, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5003"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zsocket_connect (statesub, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5004"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>fsm.state <span style="color:#666666">=</span> STATE_PRIMARY;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (argc <span style="color:#666666">==</span> <span style="color:#666666">2</span> <span style="color:#666666">&amp;&amp;</span> streq (argv <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>, <span style="color:#BA2121">"-b"</span>)) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"I: Backup passive, waiting for primary (active)</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zsocket_bind (frontend, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5002"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zsocket_bind (statepub, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5004"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zsocket_connect (statesub, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5003"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>fsm.state <span style="color:#666666">=</span> STATE_BACKUP;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"Usage: bstarsrv { -p | -b }</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>exit (<span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We now process events on our two input sockets, and process these</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>events one at a time via our finite-state machine. Our "work" for</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>a client request is simply to echo it back:</em></span></p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Set timer for next outgoing state message</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int64_t</span> send_state_at <span style="color:#666666">=</span> zclock_time () <span style="color:#666666">+</span> HEARTBEAT;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">!</span>zctx_interrupted) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_pollitem_t items <span style="white-space: pre-wrap;">[]</span> <span style="color:#666666">=</span> {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>{ frontend, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> },<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>{ statesub, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> }<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> time_left <span style="color:#666666">=</span> (<span style="color:#B00040">int</span>) ((send_state_at <span style="color:#666666">-</span> zclock_time ()));<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (time_left <span style="color:#666666">&lt;</span> <span style="color:#666666">0</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>time_left <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> rc <span style="color:#666666">=</span> zmq_poll (items, <span style="color:#666666">2</span>, time_left <span style="color:#666666">*</span> ZMQ_POLL_MSEC);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (rc <span style="color:#666666">==</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Context has been shut down</em></span></p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Have a client request</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_recv (frontend);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>fsm.event <span style="color:#666666">=</span> CLIENT_REQUEST;<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (s_state_machine (<span style="color:#666666">&amp;</span>fsm) <span style="color:#666666">==</span> <span style="color:#008000">false</span>)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Answer client by echoing request back</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>msg, frontend);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>msg);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Have state from our peer, execute as event</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>message <span style="color:#666666">=</span> zstr_recv (statesub);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>fsm.event <span style="color:#666666">=</span> atoi (message);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>free (message);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (s_state_machine (<span style="color:#666666">&amp;</span>fsm))<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Error, so exit</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>fsm.peer_expiry <span style="color:#666666">=</span> zclock_time () <span style="color:#666666">+</span> <span style="color:#666666">2</span> <span style="color:#666666">*</span> HEARTBEAT;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If we timed out, send state to peer</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (zclock_time () <span style="color:#666666">&gt;=</span> send_state_at) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">char</span> message <span style="white-space: pre-wrap;">[</span><span style="color:#666666">2</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>sprintf (message, <span style="color:#BA2121">"%d"</span>, fsm.state);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zstr_send (statepub, message);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>send_state_at <span style="color:#666666">=</span> zclock_time () <span style="color:#666666">+</span> HEARTBEAT;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (zctx_interrupted)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"W: interrupted</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Shutdown sockets and context</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/hx:bstarsrv" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:bstarsrv" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/py:bstarsrv" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rb:bstarsrv" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/tcl:bstarsrv" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | C# | Clojure | CL | Delphi | Erlang | F# | Felix | Go | Haskell | Lua | Node.js | Objective-C | ooc | Perl | PHP | Q | Racket | Scala</a></span>
<p>And here is the client:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">bstarcli:&nbsp;Binary&nbsp;Star&nbsp;client&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">bstarcli:&nbsp;Binary&nbsp;Star&nbsp;client&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Binary Star client proof-of-concept implementation. This client does no<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>real work; it just demonstrates the Binary Star failover model.</span></p>
<p>#include "czmq.h"<br>
#define REQUEST_TIMEOUT<tt><span style="white-space: pre-wrap;">     </span></tt>1000<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>msecs</em></span><br>
<span style="color:#BC7A00">#define SETTLE_DELAY<tt><span style="white-space: pre-wrap;">        </span></tt>2000<tt><span style="white-space: pre-wrap;">    </span></tt></span><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Before failing over</em></span></p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>server <span style="white-space: pre-wrap;">[]</span> <span style="color:#666666">=</span> { <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5001"</span>, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5002"</span> };<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>uint server_nbr <span style="color:#666666">=</span> <span style="color:#666666">0</span>;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"I: connecting to server at %s…</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, server <span style="white-space: pre-wrap;">[</span>server_nbr<span style="white-space: pre-wrap;">]</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>client <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_REQ);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect (client, server <span style="white-space: pre-wrap;">[</span>server_nbr<span style="white-space: pre-wrap;">]</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> sequence <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">!</span>zctx_interrupted) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We send a request, then we work to get a reply</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> request <span style="white-space: pre-wrap;">[</span><span style="color:#666666">10</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>sprintf (request, <span style="color:#BA2121">"%d"</span>, <span style="color:#666666">++</span>sequence);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zstr_send (client, request);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> expect_reply <span style="color:#666666">=</span> <span style="color:#666666">1</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>while</strong></span> (expect_reply) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Poll socket for a reply, with timeout</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmq_pollitem_t items <span style="white-space: pre-wrap;">[]</span> <span style="color:#666666">=</span> { { client, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> } };<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">int</span> rc <span style="color:#666666">=</span> zmq_poll (items, <span style="color:#666666">1</span>, REQUEST_TIMEOUT <span style="color:#666666">*</span> ZMQ_POLL_MSEC);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (rc <span style="color:#666666">==</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span></p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We use a Lazy Pirate strategy in the client. If there's no</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>reply within our timeout, we close the socket and try again.</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>In Binary Star, it's the client vote that decides which</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>server is primary; the client must therefore try to connect</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>to each server in turn:</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We got a reply from the server, must match sequence</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>reply <span style="color:#666666">=</span> zstr_recv (client);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>if</strong></span> (atoi (reply) <span style="color:#666666">==</span> sequence) {<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>printf (<span style="color:#BA2121">"I: server replied OK (%s)</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, reply);<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>expect_reply <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>sleep (<span style="color:#666666">1</span>);<tt><span style="white-space: pre-wrap;">  </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>One request per second</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>printf (<span style="color:#BA2121">"E: bad reply from server: %s</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, reply);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>free (reply);<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>else</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>printf (<span style="color:#BA2121">"W: no response from server, failing over</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Old socket is confused; close it and open a new one</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zsocket_destroy (ctx, client);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>server_nbr <span style="color:#666666">=</span> (server_nbr <span style="color:#666666">+</span> <span style="color:#666666">1</span>) <span style="color:#666666">%</span> <span style="color:#666666">2</span>;<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zclock_sleep (SETTLE_DELAY);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>printf (<span style="color:#BA2121">"I: connecting to server at %s…</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>,<br>
<tt><span style="white-space: pre-wrap;">                        </span></tt>server <span style="white-space: pre-wrap;">[</span>server_nbr<span style="white-space: pre-wrap;">]</span>);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>client <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_REQ);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zsocket_connect (client, server <span style="white-space: pre-wrap;">[</span>server_nbr<span style="white-space: pre-wrap;">]</span>);</p>
<p><tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send request again, on new socket</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zstr_send (client, request);<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/hx:bstarcli" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:bstarcli" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/py:bstarcli" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rb:bstarcli" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/tcl:bstarcli" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | C# | Clojure | CL | Delphi | Erlang | F# | Felix | Go | Haskell | Lua | Node.js | Objective-C | ooc | Perl | PHP | Q | Racket | Scala</a></span>
<p>To test Binary Star, start the servers and client in any order:</p>
<div class="code">
<pre><code>bstarsrv -p     # Start primary
bstarsrv -b     # Start backup
bstarcli</code>
</pre></div>
<p>You can then provoke failover by killing the primary server, and recovery by restarting the primary and killing the backup. Note how it's the client vote that triggers failover, and recovery.</p>
<p>Binary star is driven by a finite state machine. Events are the peer state, so "Peer Active" means the other server has told us it's active. "Client Request" means we've received a client request. "Client Vote" means we've received a client request AND our peer is inactive for two heartbeats.</p>
<p>Note that the servers use PUB-SUB sockets for state exchange. No other socket combination will work here. PUSH and DEALER block if there is no peer ready to receive a message. PAIR does not reconnect if the peer disappears and comes back. ROUTER needs the address of the peer before it can send it a message.</p>
<p><strong>Figure 54 - Binary Star Finite State Machine</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig54.png" alt="fig54.png" class="image"></div>
<p><a name="Binary-Star-Reactor"></a><a name="header-108"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc107"><span><a href="http://zguide.zeromq.org/page:all#Binary-Star-Reactor">Binary Star Reactor</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-107">prev</a> <a href="http://zguide.zeromq.org/page:all#header-109">next</a></td>
</tr>
</tbody></table>
<p>Binary Star is useful and generic enough to package up as a reusable reactor class. The reactor then runs and calls our code whenever it has a message to process. This is much nicer than copying/pasting the Binary Star code into each server where we want that capability.</p>
<p>In C, we wrap the CZMQ <tt>zloop</tt> class that we saw before. <tt>zloop</tt> lets you register handlers to react on socket and timer events. In the Binary Star reactor, we provide handlers for voters and for state changes (active to passive, and vice versa). Here is the <tt>bstar</tt> API:</p>
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>bstar class - Binary Star reactor</span></p>
<p>#include "bstar.h"</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>States we can be in at any point in time</em></span><br>
<span style="color:#008000"><strong>typedef</strong></span> <span style="color:#008000"><strong>enum</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>STATE_PRIMARY <span style="color:#666666">=</span> <span style="color:#666666">1</span>,<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Primary, waiting for peer to connect</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>STATE_BACKUP <span style="color:#666666">=</span> <span style="color:#666666">2</span>,<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Backup, waiting for peer to connect</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>STATE_ACTIVE <span style="color:#666666">=</span> <span style="color:#666666">3</span>,<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Active - accepting connections</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>STATE_PASSIVE <span style="color:#666666">=</span> <span style="color:#666666">4</span><tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Passive - not accepting connections</em></span><br>
} state_t;</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Events, which start with the states our peer can be in</em></span><br>
<span style="color:#008000"><strong>typedef</strong></span> <span style="color:#008000"><strong>enum</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>PEER_PRIMARY <span style="color:#666666">=</span> <span style="color:#666666">1</span>,<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>HA peer is pending primary</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>PEER_BACKUP <span style="color:#666666">=</span> <span style="color:#666666">2</span>,<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>HA peer is pending backup</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>PEER_ACTIVE <span style="color:#666666">=</span> <span style="color:#666666">3</span>,<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>HA peer is active</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>PEER_PASSIVE <span style="color:#666666">=</span> <span style="color:#666666">4</span>,<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>HA peer is passive</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>CLIENT_REQUEST <span style="color:#666666">=</span> <span style="color:#666666">5</span><tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Client makes request</em></span><br>
} event_t;</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Structure of our class</em></span></p>
<p><span style="color:#008000"><strong>struct</strong></span> _bstar_t {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx;<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Our private context</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zloop_t <span style="color:#666666">*</span>loop;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Reactor loop</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>statepub;<tt><span style="white-space: pre-wrap;">             </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>State publisher</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>statesub;<tt><span style="white-space: pre-wrap;">             </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>State subscriber</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>state_t state;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Current state</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>event_t event;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Current event</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int64_t</span> peer_expiry;<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>When peer is considered 'dead'</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zloop_fn <span style="color:#666666">*</span>voter_fn;<tt><span style="white-space: pre-wrap;">         </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Voting socket handler</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>voter_arg;<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Arguments for voting handler</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zloop_fn <span style="color:#666666">*</span>active_fn;<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Call when become active</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>active_arg;<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Arguments for handler</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zloop_fn <span style="color:#666666">*</span>passive_fn;<tt><span style="white-space: pre-wrap;">         </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Call when become passive</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>passive_arg;<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Arguments for handler</em></span><br>
};<br>
<span style="color:#BC7A00"><br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The finite-state machine is the same as in the proof-of-concept server.<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>To understand this reactor in detail, first read the CZMQ zloop class.</span></p>
<p><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We send state information every this often<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If peer doesn't respond in two heartbeats, it is 'dead'<br>
#define BSTAR_HEARTBEAT<tt><span style="white-space: pre-wrap;">     </span></tt>1000<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>In msecs</em></span></p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Binary Star finite state machine (applies event to state)<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Returns -1 if there was an exception, 0 if event was valid.</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">int</span><br>
<span style="color:#0000FF">s_execute_fsm</span> (bstar_t <span style="color:#666666">*</span>self)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> rc <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Primary server is waiting for peer to connect</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Accepts CLIENT_REQUEST events in this state</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>state <span style="color:#666666">==</span> STATE_PRIMARY) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>event <span style="color:#666666">==</span> PEER_BACKUP) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zclock_log (<span style="color:#BA2121">"I: connected to backup (passive), ready as active"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>self<span style="color:#666666">-&gt;</span>state <span style="color:#666666">=</span> STATE_ACTIVE;<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>active_fn)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>(self<span style="color:#666666">-&gt;</span>active_fn) (self<span style="color:#666666">-&gt;</span>loop, <span style="color:#008000">NULL</span>, self<span style="color:#666666">-&gt;</span>active_arg);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>event <span style="color:#666666">==</span> PEER_ACTIVE) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zclock_log (<span style="color:#BA2121">"I: connected to backup (active), ready as passive"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>self<span style="color:#666666">-&gt;</span>state <span style="color:#666666">=</span> STATE_PASSIVE;<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>passive_fn)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>(self<span style="color:#666666">-&gt;</span>passive_fn) (self<span style="color:#666666">-&gt;</span>loop, <span style="color:#008000">NULL</span>, self<span style="color:#666666">-&gt;</span>passive_arg);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>event <span style="color:#666666">==</span> CLIENT_REQUEST) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span> Allow client requests to turn us into the active if we've</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span> waited sufficiently long to believe the backup is not</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span> currently acting as active (i.e., after a failover)</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>assert (self<span style="color:#666666">-&gt;</span>peer_expiry <span style="color:#666666">&gt;</span> <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (zclock_time () <span style="color:#666666">&gt;=</span> self<span style="color:#666666">-&gt;</span>peer_expiry) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zclock_log (<span style="color:#BA2121">"I: request from client, ready as active"</span>);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>self<span style="color:#666666">-&gt;</span>state <span style="color:#666666">=</span> STATE_ACTIVE;<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>active_fn)<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>(self<span style="color:#666666">-&gt;</span>active_fn) (self<span style="color:#666666">-&gt;</span>loop, <span style="color:#008000">NULL</span>, self<span style="color:#666666">-&gt;</span>active_arg);<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt> <span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span> Don't respond to clients yet - it's possible we're</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span> performing a failback and the backup is currently active</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt>rc <span style="color:#666666">=</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Backup server is waiting for peer to connect</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Rejects CLIENT_REQUEST events in this state</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>state <span style="color:#666666">==</span> STATE_BACKUP) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>event <span style="color:#666666">==</span> PEER_ACTIVE) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zclock_log (<span style="color:#BA2121">"I: connected to primary (active), ready as passive"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>self<span style="color:#666666">-&gt;</span>state <span style="color:#666666">=</span> STATE_PASSIVE;<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>passive_fn)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>(self<span style="color:#666666">-&gt;</span>passive_fn) (self<span style="color:#666666">-&gt;</span>loop, <span style="color:#008000">NULL</span>, self<span style="color:#666666">-&gt;</span>passive_arg);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>event <span style="color:#666666">==</span> CLIENT_REQUEST)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>rc <span style="color:#666666">=</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Server is active</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Accepts CLIENT_REQUEST events in this state</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The only way out of ACTIVE is death</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>state <span style="color:#666666">==</span> STATE_ACTIVE) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>event <span style="color:#666666">==</span> PEER_ACTIVE) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Two actives would mean split-brain</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zclock_log (<span style="color:#BA2121">"E: fatal error - dual actives, aborting"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>rc <span style="color:#666666">=</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Server is passive</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>CLIENT_REQUEST events can trigger failover if peer looks dead</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>state <span style="color:#666666">==</span> STATE_PASSIVE) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>event <span style="color:#666666">==</span> PEER_PRIMARY) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Peer is restarting - become active, peer will go passive</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zclock_log (<span style="color:#BA2121">"I: primary (passive) is restarting, ready as active"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>self<span style="color:#666666">-&gt;</span>state <span style="color:#666666">=</span> STATE_ACTIVE;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>event <span style="color:#666666">==</span> PEER_BACKUP) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Peer is restarting - become active, peer will go passive</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zclock_log (<span style="color:#BA2121">"I: backup (passive) is restarting, ready as active"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>self<span style="color:#666666">-&gt;</span>state <span style="color:#666666">=</span> STATE_ACTIVE;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>event <span style="color:#666666">==</span> PEER_PASSIVE) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Two passives would mean cluster would be non-responsive</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zclock_log (<span style="color:#BA2121">"E: fatal error - dual passives, aborting"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>rc <span style="color:#666666">=</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>event <span style="color:#666666">==</span> CLIENT_REQUEST) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Peer becomes active if timeout has passed</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>It's the client request that triggers the failover</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>assert (self<span style="color:#666666">-&gt;</span>peer_expiry <span style="color:#666666">&gt;</span> <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (zclock_time () <span style="color:#666666">&gt;=</span> self<span style="color:#666666">-&gt;</span>peer_expiry) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If peer is dead, switch to the active state</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zclock_log (<span style="color:#BA2121">"I: failover successful, ready as active"</span>);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>self<span style="color:#666666">-&gt;</span>state <span style="color:#666666">=</span> STATE_ACTIVE;<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If peer is alive, reject connections</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt>rc <span style="color:#666666">=</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Call state change handler if necessary</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>state <span style="color:#666666">==</span> STATE_ACTIVE <span style="color:#666666">&amp;&amp;</span> self<span style="color:#666666">-&gt;</span>active_fn)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>(self<span style="color:#666666">-&gt;</span>active_fn) (self<span style="color:#666666">-&gt;</span>loop, <span style="color:#008000">NULL</span>, self<span style="color:#666666">-&gt;</span>active_arg);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> rc;<br>
}</p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<span style="color:#0000FF">s_update_peer_expiry</span> (bstar_t <span style="color:#666666">*</span>self)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>peer_expiry <span style="color:#666666">=</span> zclock_time () <span style="color:#666666">+</span> <span style="color:#666666">2</span> <span style="color:#666666">*</span> BSTAR_HEARTBEAT;<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Reactor event handlers…</em></span></p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Publish our state to peer</em></span><br>
<span style="color:#B00040">int</span> <span style="color:#0000FF">s_send_state</span> (zloop_t <span style="color:#666666">*</span>loop, <span style="color:#B00040">int</span> timer_id, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>arg)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>bstar_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> (bstar_t <span style="color:#666666">*</span>) arg;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zstr_sendf (self<span style="color:#666666">-&gt;</span>statepub, <span style="color:#BA2121">"%d"</span>, self<span style="color:#666666">-&gt;</span>state);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Receive state from peer, execute finite state machine</em></span><br>
<span style="color:#B00040">int</span> <span style="color:#0000FF">s_recv_state</span> (zloop_t <span style="color:#666666">*</span>loop, zmq_pollitem_t <span style="color:#666666">*</span>poller, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>arg)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>bstar_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> (bstar_t <span style="color:#666666">*</span>) arg;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>state <span style="color:#666666">=</span> zstr_recv (poller<span style="color:#666666">-&gt;</span>socket);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (state) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>self<span style="color:#666666">-&gt;</span>event <span style="color:#666666">=</span> atoi (state);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>s_update_peer_expiry (self);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (state);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> s_execute_fsm (self);<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Application wants to speak to us, see if it's possible</em></span><br>
<span style="color:#B00040">int</span> <span style="color:#0000FF">s_voter_ready</span> (zloop_t <span style="color:#666666">*</span>loop, zmq_pollitem_t <span style="color:#666666">*</span>poller, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>arg)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>bstar_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> (bstar_t <span style="color:#666666">*</span>) arg;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If server can accept input now, call appl handler</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>event <span style="color:#666666">=</span> CLIENT_REQUEST;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (s_execute_fsm (self) <span style="color:#666666">==</span> <span style="color:#666666">0</span>)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>(self<span style="color:#666666">-&gt;</span>voter_fn) (self<span style="color:#666666">-&gt;</span>loop, poller, self<span style="color:#666666">-&gt;</span>voter_arg);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Destroy waiting message, no-one to read it</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_recv (poller<span style="color:#666666">-&gt;</span>socket);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>msg);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This is the constructor for our <tt>bstar</tt> class. We have to tell it<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>whether we're primary or backup server, as well as our local and<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>remote endpoints to bind and connect to:</span></span></p>
<p>bstar_t <span style="color:#666666">*</span><br>
<span style="color:#0000FF">bstar_new</span> (<span style="color:#B00040">int</span> primary, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>local, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>remote)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>bstar_t<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#666666">*</span>self;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>self <span style="color:#666666">=</span> (bstar_t <span style="color:#666666">*</span>) zmalloc (<span style="color:#008000"><strong>sizeof</strong></span> (bstar_t));</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Initialize the Binary Star</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>loop <span style="color:#666666">=</span> zloop_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>state <span style="color:#666666">=</span> primary<span style="color:#666666">?</span> STATE_PRIMARY<span style="color:#666666">:</span> STATE_BACKUP;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Create publisher for state going to peer</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>statepub <span style="color:#666666">=</span> zsocket_new (self<span style="color:#666666">-&gt;</span>ctx, ZMQ_PUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (self<span style="color:#666666">-&gt;</span>statepub, local);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Create subscriber for state coming from peer</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>statesub <span style="color:#666666">=</span> zsocket_new (self<span style="color:#666666">-&gt;</span>ctx, ZMQ_SUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_set_subscribe (self<span style="color:#666666">-&gt;</span>statesub, <span style="color:#BA2121">""</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect (self<span style="color:#666666">-&gt;</span>statesub, remote);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Set-up basic reactor events</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zloop_timer (self<span style="color:#666666">-&gt;</span>loop, BSTAR_HEARTBEAT, <span style="color:#666666">0</span>, s_send_state, self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_pollitem_t poller <span style="color:#666666">=</span> { self<span style="color:#666666">-&gt;</span>statesub, <span style="color:#666666">0</span>, ZMQ_POLLIN };<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zloop_poller (self<span style="color:#666666">-&gt;</span>loop, <span style="color:#666666">&amp;</span>poller, s_recv_state, self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> self;<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The destructor shuts down the bstar reactor:</em></span></p>
<p><span style="color:#B00040">void</span><br>
<span style="color:#0000FF">bstar_destroy</span> (bstar_t <span style="color:#666666"><span style="white-space: pre-wrap;">**</span></span>self_p)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self_p);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">*</span>self_p) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>bstar_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> <span style="color:#666666">*</span>self_p;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zloop_destroy (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>loop);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (self);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#666666">*</span>self_p <span style="color:#666666">=</span> <span style="color:#008000">NULL</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This method returns the underlying zloop reactor, so we can add<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>additional timers and readers:</span></span></p>
<p>zloop_t <span style="color:#666666">*</span><br>
<span style="color:#0000FF">bstar_zloop</span> (bstar_t <span style="color:#666666">*</span>self)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> self<span style="color:#666666">-&gt;</span>loop;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This method registers a client voter socket. Messages received<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>on this socket provide the CLIENT_REQUEST events for the Binary Star<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>FSM and are passed to the provided application handler. We require<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>exactly one voter per <tt>bstar</tt> instance:</span></span></p>
<p><span style="color:#B00040">int</span><br>
<span style="color:#0000FF">bstar_voter</span> (bstar_t <span style="color:#666666">*</span>self, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>endpoint, <span style="color:#B00040">int</span> type, zloop_fn handler,<br>
<tt><span style="white-space: pre-wrap;">             </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>arg)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Hold actual handler+arg so we can call this later</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>socket <span style="color:#666666">=</span> zsocket_new (self<span style="color:#666666">-&gt;</span>ctx, type);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (socket, endpoint);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (<span style="color:#666666">!</span>self<span style="color:#666666">-&gt;</span>voter_fn);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>voter_fn <span style="color:#666666">=</span> handler;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>voter_arg <span style="color:#666666">=</span> arg;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_pollitem_t poller <span style="color:#666666">=</span> { socket, <span style="color:#666666">0</span>, ZMQ_POLLIN };<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> zloop_poller (self<span style="color:#666666">-&gt;</span>loop, <span style="color:#666666">&amp;</span>poller, s_voter_ready, self);<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Register handlers to be called each time there's a state change:</em></span></p>
<p><span style="color:#B00040">void</span><br>
<span style="color:#0000FF">bstar_new_active</span> (bstar_t <span style="color:#666666">*</span>self, zloop_fn handler, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>arg)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (<span style="color:#666666">!</span>self<span style="color:#666666">-&gt;</span>active_fn);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>active_fn <span style="color:#666666">=</span> handler;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>active_arg <span style="color:#666666">=</span> arg;<br>
}</p>
<p><span style="color:#B00040">void</span><br>
<span style="color:#0000FF">bstar_new_passive</span> (bstar_t <span style="color:#666666">*</span>self, zloop_fn handler, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>arg)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (<span style="color:#666666">!</span>self<span style="color:#666666">-&gt;</span>passive_fn);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>passive_fn <span style="color:#666666">=</span> handler;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>passive_arg <span style="color:#666666">=</span> arg;<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Enable/disable verbose tracing, for debugging:</em></span></p>
<p><span style="color:#B00040">void</span> <span style="color:#0000FF">bstar_set_verbose</span> (bstar_t <span style="color:#666666">*</span>self, bool verbose)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zloop_set_verbose (self<span style="color:#666666">-&gt;</span>loop, verbose);<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Finally, start the configured reactor. It will end if any handler<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>returns -1 to the reactor, or if the process receives SIGINT or SIGTERM:</span></span></p>
<p><span style="color:#B00040">int</span><br>
<span style="color:#0000FF">bstar_start</span> (bstar_t <span style="color:#666666">*</span>self)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self<span style="color:#666666">-&gt;</span>voter_fn);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_update_peer_expiry (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> zloop_start (self<span style="color:#666666">-&gt;</span>loop);<br>
}</p>
</div>
<p>And here is the class implementation:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">bstar:&nbsp;Binary&nbsp;Star&nbsp;core&nbsp;class&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">bstar:&nbsp;Binary&nbsp;Star&nbsp;core&nbsp;class&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>bstar class - Binary Star reactor</span></p>
<p>#include "bstar.h"</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>States we can be in at any point in time</em></span><br>
<span style="color:#008000"><strong>typedef</strong></span> <span style="color:#008000"><strong>enum</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>STATE_PRIMARY <span style="color:#666666">=</span> <span style="color:#666666">1</span>,<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Primary, waiting for peer to connect</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>STATE_BACKUP <span style="color:#666666">=</span> <span style="color:#666666">2</span>,<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Backup, waiting for peer to connect</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>STATE_ACTIVE <span style="color:#666666">=</span> <span style="color:#666666">3</span>,<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Active - accepting connections</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>STATE_PASSIVE <span style="color:#666666">=</span> <span style="color:#666666">4</span><tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Passive - not accepting connections</em></span><br>
} state_t;</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Events, which start with the states our peer can be in</em></span><br>
<span style="color:#008000"><strong>typedef</strong></span> <span style="color:#008000"><strong>enum</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>PEER_PRIMARY <span style="color:#666666">=</span> <span style="color:#666666">1</span>,<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>HA peer is pending primary</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>PEER_BACKUP <span style="color:#666666">=</span> <span style="color:#666666">2</span>,<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>HA peer is pending backup</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>PEER_ACTIVE <span style="color:#666666">=</span> <span style="color:#666666">3</span>,<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>HA peer is active</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>PEER_PASSIVE <span style="color:#666666">=</span> <span style="color:#666666">4</span>,<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>HA peer is passive</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>CLIENT_REQUEST <span style="color:#666666">=</span> <span style="color:#666666">5</span><tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Client makes request</em></span><br>
} event_t;</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Structure of our class</em></span></p>
<p><span style="color:#008000"><strong>struct</strong></span> _bstar_t {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx;<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Our private context</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zloop_t <span style="color:#666666">*</span>loop;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Reactor loop</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>statepub;<tt><span style="white-space: pre-wrap;">             </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>State publisher</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>statesub;<tt><span style="white-space: pre-wrap;">             </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>State subscriber</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>state_t state;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Current state</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>event_t event;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Current event</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int64_t</span> peer_expiry;<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>When peer is considered 'dead'</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zloop_fn <span style="color:#666666">*</span>voter_fn;<tt><span style="white-space: pre-wrap;">         </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Voting socket handler</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>voter_arg;<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Arguments for voting handler</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zloop_fn <span style="color:#666666">*</span>active_fn;<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Call when become active</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>active_arg;<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Arguments for handler</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zloop_fn <span style="color:#666666">*</span>passive_fn;<tt><span style="white-space: pre-wrap;">         </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Call when become passive</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>passive_arg;<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Arguments for handler</em></span><br>
};<br>
<span style="color:#BC7A00"><br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The finite-state machine is the same as in the proof-of-concept server.<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>To understand this reactor in detail, first read the CZMQ zloop class.</span></p>
<p><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We send state information every this often<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If peer doesn't respond in two heartbeats, it is 'dead'<br>
#define BSTAR_HEARTBEAT<tt><span style="white-space: pre-wrap;">     </span></tt>1000<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>In msecs</em></span></p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Binary Star finite state machine (applies event to state)<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Returns -1 if there was an exception, 0 if event was valid.</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">int</span><br>
<span style="color:#0000FF">s_execute_fsm</span> (bstar_t <span style="color:#666666">*</span>self)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> rc <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Primary server is waiting for peer to connect</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Accepts CLIENT_REQUEST events in this state</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>state <span style="color:#666666">==</span> STATE_PRIMARY) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>event <span style="color:#666666">==</span> PEER_BACKUP) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zclock_log (<span style="color:#BA2121">"I: connected to backup (passive), ready as active"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>self<span style="color:#666666">-&gt;</span>state <span style="color:#666666">=</span> STATE_ACTIVE;<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>active_fn)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>(self<span style="color:#666666">-&gt;</span>active_fn) (self<span style="color:#666666">-&gt;</span>loop, <span style="color:#008000">NULL</span>, self<span style="color:#666666">-&gt;</span>active_arg);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>event <span style="color:#666666">==</span> PEER_ACTIVE) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zclock_log (<span style="color:#BA2121">"I: connected to backup (active), ready as passive"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>self<span style="color:#666666">-&gt;</span>state <span style="color:#666666">=</span> STATE_PASSIVE;<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>passive_fn)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>(self<span style="color:#666666">-&gt;</span>passive_fn) (self<span style="color:#666666">-&gt;</span>loop, <span style="color:#008000">NULL</span>, self<span style="color:#666666">-&gt;</span>passive_arg);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>event <span style="color:#666666">==</span> CLIENT_REQUEST) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span> Allow client requests to turn us into the active if we've</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span> waited sufficiently long to believe the backup is not</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span> currently acting as active (i.e., after a failover)</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>assert (self<span style="color:#666666">-&gt;</span>peer_expiry <span style="color:#666666">&gt;</span> <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (zclock_time () <span style="color:#666666">&gt;=</span> self<span style="color:#666666">-&gt;</span>peer_expiry) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zclock_log (<span style="color:#BA2121">"I: request from client, ready as active"</span>);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>self<span style="color:#666666">-&gt;</span>state <span style="color:#666666">=</span> STATE_ACTIVE;<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>active_fn)<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>(self<span style="color:#666666">-&gt;</span>active_fn) (self<span style="color:#666666">-&gt;</span>loop, <span style="color:#008000">NULL</span>, self<span style="color:#666666">-&gt;</span>active_arg);<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt> <span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span> Don't respond to clients yet - it's possible we're</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span> performing a failback and the backup is currently active</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt>rc <span style="color:#666666">=</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Backup server is waiting for peer to connect</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Rejects CLIENT_REQUEST events in this state</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>state <span style="color:#666666">==</span> STATE_BACKUP) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>event <span style="color:#666666">==</span> PEER_ACTIVE) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zclock_log (<span style="color:#BA2121">"I: connected to primary (active), ready as passive"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>self<span style="color:#666666">-&gt;</span>state <span style="color:#666666">=</span> STATE_PASSIVE;<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>passive_fn)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>(self<span style="color:#666666">-&gt;</span>passive_fn) (self<span style="color:#666666">-&gt;</span>loop, <span style="color:#008000">NULL</span>, self<span style="color:#666666">-&gt;</span>passive_arg);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>event <span style="color:#666666">==</span> CLIENT_REQUEST)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>rc <span style="color:#666666">=</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Server is active</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Accepts CLIENT_REQUEST events in this state</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The only way out of ACTIVE is death</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>state <span style="color:#666666">==</span> STATE_ACTIVE) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>event <span style="color:#666666">==</span> PEER_ACTIVE) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Two actives would mean split-brain</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zclock_log (<span style="color:#BA2121">"E: fatal error - dual actives, aborting"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>rc <span style="color:#666666">=</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Server is passive</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>CLIENT_REQUEST events can trigger failover if peer looks dead</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>state <span style="color:#666666">==</span> STATE_PASSIVE) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>event <span style="color:#666666">==</span> PEER_PRIMARY) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Peer is restarting - become active, peer will go passive</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zclock_log (<span style="color:#BA2121">"I: primary (passive) is restarting, ready as active"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>self<span style="color:#666666">-&gt;</span>state <span style="color:#666666">=</span> STATE_ACTIVE;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>event <span style="color:#666666">==</span> PEER_BACKUP) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Peer is restarting - become active, peer will go passive</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zclock_log (<span style="color:#BA2121">"I: backup (passive) is restarting, ready as active"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>self<span style="color:#666666">-&gt;</span>state <span style="color:#666666">=</span> STATE_ACTIVE;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>event <span style="color:#666666">==</span> PEER_PASSIVE) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Two passives would mean cluster would be non-responsive</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zclock_log (<span style="color:#BA2121">"E: fatal error - dual passives, aborting"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>rc <span style="color:#666666">=</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>event <span style="color:#666666">==</span> CLIENT_REQUEST) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Peer becomes active if timeout has passed</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>It's the client request that triggers the failover</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>assert (self<span style="color:#666666">-&gt;</span>peer_expiry <span style="color:#666666">&gt;</span> <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (zclock_time () <span style="color:#666666">&gt;=</span> self<span style="color:#666666">-&gt;</span>peer_expiry) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If peer is dead, switch to the active state</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zclock_log (<span style="color:#BA2121">"I: failover successful, ready as active"</span>);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>self<span style="color:#666666">-&gt;</span>state <span style="color:#666666">=</span> STATE_ACTIVE;<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If peer is alive, reject connections</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt>rc <span style="color:#666666">=</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Call state change handler if necessary</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>state <span style="color:#666666">==</span> STATE_ACTIVE <span style="color:#666666">&amp;&amp;</span> self<span style="color:#666666">-&gt;</span>active_fn)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>(self<span style="color:#666666">-&gt;</span>active_fn) (self<span style="color:#666666">-&gt;</span>loop, <span style="color:#008000">NULL</span>, self<span style="color:#666666">-&gt;</span>active_arg);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> rc;<br>
}</p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<span style="color:#0000FF">s_update_peer_expiry</span> (bstar_t <span style="color:#666666">*</span>self)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>peer_expiry <span style="color:#666666">=</span> zclock_time () <span style="color:#666666">+</span> <span style="color:#666666">2</span> <span style="color:#666666">*</span> BSTAR_HEARTBEAT;<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Reactor event handlers…</em></span></p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Publish our state to peer</em></span><br>
<span style="color:#B00040">int</span> <span style="color:#0000FF">s_send_state</span> (zloop_t <span style="color:#666666">*</span>loop, <span style="color:#B00040">int</span> timer_id, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>arg)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>bstar_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> (bstar_t <span style="color:#666666">*</span>) arg;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zstr_sendf (self<span style="color:#666666">-&gt;</span>statepub, <span style="color:#BA2121">"%d"</span>, self<span style="color:#666666">-&gt;</span>state);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Receive state from peer, execute finite state machine</em></span><br>
<span style="color:#B00040">int</span> <span style="color:#0000FF">s_recv_state</span> (zloop_t <span style="color:#666666">*</span>loop, zmq_pollitem_t <span style="color:#666666">*</span>poller, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>arg)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>bstar_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> (bstar_t <span style="color:#666666">*</span>) arg;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>state <span style="color:#666666">=</span> zstr_recv (poller<span style="color:#666666">-&gt;</span>socket);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (state) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>self<span style="color:#666666">-&gt;</span>event <span style="color:#666666">=</span> atoi (state);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>s_update_peer_expiry (self);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (state);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> s_execute_fsm (self);<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Application wants to speak to us, see if it's possible</em></span><br>
<span style="color:#B00040">int</span> <span style="color:#0000FF">s_voter_ready</span> (zloop_t <span style="color:#666666">*</span>loop, zmq_pollitem_t <span style="color:#666666">*</span>poller, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>arg)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>bstar_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> (bstar_t <span style="color:#666666">*</span>) arg;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If server can accept input now, call appl handler</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>event <span style="color:#666666">=</span> CLIENT_REQUEST;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (s_execute_fsm (self) <span style="color:#666666">==</span> <span style="color:#666666">0</span>)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>(self<span style="color:#666666">-&gt;</span>voter_fn) (self<span style="color:#666666">-&gt;</span>loop, poller, self<span style="color:#666666">-&gt;</span>voter_arg);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Destroy waiting message, no-one to read it</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_recv (poller<span style="color:#666666">-&gt;</span>socket);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>msg);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This is the constructor for our <tt>bstar</tt> class. We have to tell it<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>whether we're primary or backup server, as well as our local and<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>remote endpoints to bind and connect to:</span></span></p>
<p>bstar_t <span style="color:#666666">*</span><br>
<span style="color:#0000FF">bstar_new</span> (<span style="color:#B00040">int</span> primary, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>local, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>remote)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>bstar_t<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#666666">*</span>self;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>self <span style="color:#666666">=</span> (bstar_t <span style="color:#666666">*</span>) zmalloc (<span style="color:#008000"><strong>sizeof</strong></span> (bstar_t));</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Initialize the Binary Star</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>loop <span style="color:#666666">=</span> zloop_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>state <span style="color:#666666">=</span> primary<span style="color:#666666">?</span> STATE_PRIMARY<span style="color:#666666">:</span> STATE_BACKUP;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Create publisher for state going to peer</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>statepub <span style="color:#666666">=</span> zsocket_new (self<span style="color:#666666">-&gt;</span>ctx, ZMQ_PUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (self<span style="color:#666666">-&gt;</span>statepub, local);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Create subscriber for state coming from peer</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>statesub <span style="color:#666666">=</span> zsocket_new (self<span style="color:#666666">-&gt;</span>ctx, ZMQ_SUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_set_subscribe (self<span style="color:#666666">-&gt;</span>statesub, <span style="color:#BA2121">""</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect (self<span style="color:#666666">-&gt;</span>statesub, remote);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Set-up basic reactor events</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zloop_timer (self<span style="color:#666666">-&gt;</span>loop, BSTAR_HEARTBEAT, <span style="color:#666666">0</span>, s_send_state, self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_pollitem_t poller <span style="color:#666666">=</span> { self<span style="color:#666666">-&gt;</span>statesub, <span style="color:#666666">0</span>, ZMQ_POLLIN };<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zloop_poller (self<span style="color:#666666">-&gt;</span>loop, <span style="color:#666666">&amp;</span>poller, s_recv_state, self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> self;<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The destructor shuts down the bstar reactor:</em></span></p>
<p><span style="color:#B00040">void</span><br>
<span style="color:#0000FF">bstar_destroy</span> (bstar_t <span style="color:#666666"><span style="white-space: pre-wrap;">**</span></span>self_p)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self_p);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">*</span>self_p) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>bstar_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> <span style="color:#666666">*</span>self_p;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zloop_destroy (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>loop);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (self);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#666666">*</span>self_p <span style="color:#666666">=</span> <span style="color:#008000">NULL</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This method returns the underlying zloop reactor, so we can add<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>additional timers and readers:</span></span></p>
<p>zloop_t <span style="color:#666666">*</span><br>
<span style="color:#0000FF">bstar_zloop</span> (bstar_t <span style="color:#666666">*</span>self)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> self<span style="color:#666666">-&gt;</span>loop;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This method registers a client voter socket. Messages received<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>on this socket provide the CLIENT_REQUEST events for the Binary Star<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>FSM and are passed to the provided application handler. We require<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>exactly one voter per <tt>bstar</tt> instance:</span></span></p>
<p><span style="color:#B00040">int</span><br>
<span style="color:#0000FF">bstar_voter</span> (bstar_t <span style="color:#666666">*</span>self, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>endpoint, <span style="color:#B00040">int</span> type, zloop_fn handler,<br>
<tt><span style="white-space: pre-wrap;">             </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>arg)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Hold actual handler+arg so we can call this later</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>socket <span style="color:#666666">=</span> zsocket_new (self<span style="color:#666666">-&gt;</span>ctx, type);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (socket, endpoint);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (<span style="color:#666666">!</span>self<span style="color:#666666">-&gt;</span>voter_fn);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>voter_fn <span style="color:#666666">=</span> handler;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>voter_arg <span style="color:#666666">=</span> arg;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_pollitem_t poller <span style="color:#666666">=</span> { socket, <span style="color:#666666">0</span>, ZMQ_POLLIN };<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> zloop_poller (self<span style="color:#666666">-&gt;</span>loop, <span style="color:#666666">&amp;</span>poller, s_voter_ready, self);<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Register handlers to be called each time there's a state change:</em></span></p>
<p><span style="color:#B00040">void</span><br>
<span style="color:#0000FF">bstar_new_active</span> (bstar_t <span style="color:#666666">*</span>self, zloop_fn handler, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>arg)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (<span style="color:#666666">!</span>self<span style="color:#666666">-&gt;</span>active_fn);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>active_fn <span style="color:#666666">=</span> handler;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>active_arg <span style="color:#666666">=</span> arg;<br>
}</p>
<p><span style="color:#B00040">void</span><br>
<span style="color:#0000FF">bstar_new_passive</span> (bstar_t <span style="color:#666666">*</span>self, zloop_fn handler, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>arg)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (<span style="color:#666666">!</span>self<span style="color:#666666">-&gt;</span>passive_fn);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>passive_fn <span style="color:#666666">=</span> handler;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>passive_arg <span style="color:#666666">=</span> arg;<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Enable/disable verbose tracing, for debugging:</em></span></p>
<p><span style="color:#B00040">void</span> <span style="color:#0000FF">bstar_set_verbose</span> (bstar_t <span style="color:#666666">*</span>self, bool verbose)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zloop_set_verbose (self<span style="color:#666666">-&gt;</span>loop, verbose);<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Finally, start the configured reactor. It will end if any handler<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>returns -1 to the reactor, or if the process receives SIGINT or SIGTERM:</span></span></p>
<p><span style="color:#B00040">int</span><br>
<span style="color:#0000FF">bstar_start</span> (bstar_t <span style="color:#666666">*</span>self)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self<span style="color:#666666">-&gt;</span>voter_fn);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_update_peer_expiry (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> zloop_start (self<span style="color:#666666">-&gt;</span>loop);<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/hx:bstar" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:bstar" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/py:bstar" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/tcl:bstar" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | C# | Clojure | CL | Delphi | Erlang | F# | Felix | Go | Haskell | Lua | Node.js | Objective-C | ooc | Perl | PHP | Q | Racket | Ruby | Scala</a></span>
<p>This gives us the following short main program for the server:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">bstarsrv2:&nbsp;Binary&nbsp;Star&nbsp;server,&nbsp;using&nbsp;core&nbsp;class&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">bstarsrv2:&nbsp;Binary&nbsp;Star&nbsp;server,&nbsp;using&nbsp;core&nbsp;class&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Binary Star server, using bstar reactor</span></p>
<p><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Lets us build this source without creating a library<br>
#include "bstar.c"</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Echo service</em></span><br>
<span style="color:#B00040">int</span> <span style="color:#0000FF">s_echo</span> (zloop_t <span style="color:#666666">*</span>loop, zmq_pollitem_t <span style="color:#666666">*</span>poller, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>arg)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_recv (poller<span style="color:#666666">-&gt;</span>socket);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>msg, poller<span style="color:#666666">-&gt;</span>socket);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">int</span> argc, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>argv <span style="white-space: pre-wrap;">[]</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Arguments can be either of:</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">      </span></tt>-p<tt><span style="white-space: pre-wrap;">  </span></tt>primary server, at tcp:<span style="white-space: pre-wrap;">//</span>localhost:5001</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">      </span></tt>-b<tt><span style="white-space: pre-wrap;">  </span></tt>backup server, at tcp:<span style="white-space: pre-wrap;">//</span>localhost:5002</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>bstar_t <span style="color:#666666">*</span>bstar;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (argc <span style="color:#666666">==</span> <span style="color:#666666">2</span> <span style="color:#666666">&amp;&amp;</span> streq (argv <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>, <span style="color:#BA2121">"-p"</span>)) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"I: Primary active, waiting for backup (passive)</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>bstar <span style="color:#666666">=</span> bstar_new (BSTAR_PRIMARY,<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5003"</span>, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5004"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>bstar_voter (bstar, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5001"</span>, ZMQ_ROUTER, s_echo, <span style="color:#008000">NULL</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (argc <span style="color:#666666">==</span> <span style="color:#666666">2</span> <span style="color:#666666">&amp;&amp;</span> streq (argv <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>, <span style="color:#BA2121">"-b"</span>)) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"I: Backup passive, waiting for primary (active)</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>bstar <span style="color:#666666">=</span> bstar_new (BSTAR_BACKUP,<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5004"</span>, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5003"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>bstar_voter (bstar, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5002"</span>, ZMQ_ROUTER, s_echo, <span style="color:#008000">NULL</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"Usage: bstarsrvs { -p | -b }</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>exit (<span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>bstar_start (bstar);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>bstar_destroy (<span style="color:#666666">&amp;</span>bstar);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/hx:bstarsrv2" target="_blank">Haxe</a> | <a href="http://zguide.zeromq.org/java:bstarsrv2" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/py:bstarsrv2" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/tcl:bstarsrv2" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | C# | Clojure | CL | Delphi | Erlang | F# | Felix | Go | Haskell | Lua | Node.js | Objective-C | ooc | Perl | PHP | Q | Racket | Ruby | Scala</a></span>
<p><a name="Brokerless-Reliability-Freelance-Pattern"></a><a name="header-109"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc108"><span><a href="http://zguide.zeromq.org/page:all#Brokerless-Reliability-Freelance-Pattern">Brokerless Reliability (Freelance Pattern)</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-108">prev</a> <a href="http://zguide.zeromq.org/page:all#header-110">next</a></td>
</tr>
</tbody></table>
<p>It might seem ironic to focus so much on broker-based reliability, when we often explain ZeroMQ as "brokerless messaging". However, in messaging, as in real life, the middleman is both a burden and a benefit. In practice, most messaging architectures benefit from a mix of distributed and brokered messaging. You get the best results when you can decide freely what trade-offs you want to make. This is why I can drive twenty minutes to a wholesaler to buy five cases of wine for a party, but I can also walk ten minutes to a corner store to buy one bottle for a dinner. Our highly context-sensitive relative valuations of time, energy, and cost are essential to the real world economy. And they are essential to an optimal message-based architecture.</p>
<p>This is why ZeroMQ does not <em>impose</em> a broker-centric architecture, though it does give you the tools to build brokers, aka <em>proxies</em>, and we've built a dozen or so different ones so far, just for practice.</p>
<p>So we'll end this chapter by deconstructing the broker-based reliability we've built so far, and turning it back into a distributed peer-to-peer architecture I call the Freelance pattern. Our use case will be a name resolution service. This is a common problem with ZeroMQ architectures: how do we know the endpoint to connect to? Hard-coding TCP/IP addresses in code is insanely fragile. Using configuration files creates an administration nightmare. Imagine if you had to hand-configure your web browser, on every PC or mobile phone you used, to realize that "google.com" was "74.125.230.82".</p>
<p>A ZeroMQ name service (and we'll make a simple implementation) must do the following:</p>
<ul>
<li>Resolve a logical name into at least a bind endpoint, and a connect endpoint. A realistic name service would provide multiple bind endpoints, and possibly multiple connect endpoints as well.</li>
</ul>
<ul>
<li>Allow us to manage multiple parallel environments, e.g., "test" versus "production", without modifying code.</li>
</ul>
<ul>
<li>Be reliable, because if it is unavailable, applications won't be able to connect to the network.</li>
</ul>
<p>Putting a name service behind a service-oriented Majordomo broker is clever from some points of view. However, it's simpler and much less surprising to just expose the name service as a server to which clients can connect directly. If we do this right, the name service becomes the <em>only</em> global network endpoint we need to hard-code in our code or configuration files.</p>
<p><strong>Figure 55 - The Freelance Pattern</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig55.png" alt="fig55.png" class="image"></div>
<p>The types of failure we aim to handle are server crashes and restarts, server busy looping, server overload, and network issues. To get reliability, we'll create a pool of name servers so if one crashes or goes away, clients can connect to another, and so on. In practice, two would be enough. But for the example, we'll assume the pool can be any size.</p>
<p>In this architecture, a large set of clients connect to a small set of servers directly. The servers bind to their respective addresses. It's fundamentally different from a broker-based approach like Majordomo, where workers connect to the broker. Clients have a couple of options:</p>
<ul>
<li>Use REQ sockets and the Lazy Pirate pattern. Easy, but would need some additional intelligence so clients don't stupidly try to reconnect to dead servers over and over.</li>
</ul>
<ul>
<li>Use DEALER sockets and blast out requests (which will be load balanced to all connected servers) until they get a reply. Effective, but not elegant.</li>
</ul>
<ul>
<li>Use ROUTER sockets so clients can address specific servers. But how does the client know the identity of the server sockets? Either the server has to ping the client first (complex), or the server has to use a hard-coded, fixed identity known to the client (nasty).</li>
</ul>
<p>We'll develop each of these in the following subsections.</p>
<p><a name="Model-One-Simple-Retry-and-Failover"></a><a name="header-110"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc109"><span><a href="http://zguide.zeromq.org/page:all#Model-One-Simple-Retry-and-Failover">Model One: Simple Retry and Failover</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-109">prev</a> <a href="http://zguide.zeromq.org/page:all#header-111">next</a></td>
</tr>
</tbody></table>
<p>So our menu appears to offer: simple, brutal, complex, or nasty. Let's start with simple and then work out the kinks. We take Lazy Pirate and rewrite it to work with multiple server endpoints.</p>
<p>Start one or several servers first, specifying a bind endpoint as the argument:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">flserver1:&nbsp;Freelance&nbsp;server,&nbsp;Model&nbsp;One&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">flserver1:&nbsp;Freelance&nbsp;server,&nbsp;Model&nbsp;One&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Freelance server - Model 1<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Trivial echo service</span></p>
<p>#include "czmq.h"</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">int</span> argc, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>argv <span style="white-space: pre-wrap;">[]</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (argc <span style="color:#666666">&lt;</span> <span style="color:#666666">2</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"I: syntax: %s &lt;endpoint&gt;</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, argv <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>server <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_REP);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (server, argv <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"I: echo service is ready at %s</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, argv <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_recv (server);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>msg)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>msg, server);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (zctx_interrupted)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"W: interrupted</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cs:flserver1" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/java:flserver1" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:flserver1" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/php:flserver1" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:flserver1" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/tcl:flserver1" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | Clojure | CL | Delphi | Erlang | F# | Felix | Go | Haskell | Haxe | Node.js | Objective-C | ooc | Perl | Q | Racket | Ruby | Scala</a></span>
<p>Then start the client, specifying one or more connect endpoints as arguments:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">flclient1:&nbsp;Freelance&nbsp;client,&nbsp;Model&nbsp;One&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">flclient1:&nbsp;Freelance&nbsp;client,&nbsp;Model&nbsp;One&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Freelance client - Model 1<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Uses REQ socket to query one or more services</span></p>
<p>#include "czmq.h"<br>
#define REQUEST_TIMEOUT<tt><span style="white-space: pre-wrap;">     </span></tt>1000<br>
#define MAX_RETRIES<tt><span style="white-space: pre-wrap;">         </span></tt>3<tt><span style="white-space: pre-wrap;">       </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Before we abandon</em></span></p>
<p><span style="color:#008000"><strong>static</strong></span> zmsg_t <span style="color:#666666">*</span><br>
<span style="color:#0000FF">s_try_request</span> (zctx_t <span style="color:#666666">*</span>ctx, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>endpoint, zmsg_t <span style="color:#666666">*</span>request)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"I: trying echo service at %s…</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, endpoint);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>client <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_REQ);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect (client, endpoint);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send request, wait safely for reply</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_dup (request);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>msg, client);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_pollitem_t items <span style="white-space: pre-wrap;">[]</span> <span style="color:#666666">=</span> { { client, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> } };<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_poll (items, <span style="color:#666666">1</span>, REQUEST_TIMEOUT <span style="color:#666666">*</span> ZMQ_POLL_MSEC);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>reply <span style="color:#666666">=</span> <span style="color:#008000">NULL</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>reply <span style="color:#666666">=</span> zmsg_recv (client);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Close socket in any case, we're done with it now</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_destroy (ctx, client);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> reply;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The client uses a Lazy Pirate strategy if it only has one server to talk<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>to. If it has two or more servers to talk to, it will try each server just<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>once:</span></span></p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">int</span> argc, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>argv <span style="white-space: pre-wrap;">[]</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>request <span style="color:#666666">=</span> zmsg_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_addstr (request, <span style="color:#BA2121">"Hello world"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>reply <span style="color:#666666">=</span> <span style="color:#008000">NULL</span>;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> endpoints <span style="color:#666666">=</span> argc <span style="color:#666666">-</span> <span style="color:#666666">1</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (endpoints <span style="color:#666666">==</span> <span style="color:#666666">0</span>)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"I: syntax: %s &lt;endpoint&gt; …</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, argv <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (endpoints <span style="color:#666666">==</span> <span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>For one endpoint, we retry N times</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> retries;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>for</strong></span> (retries <span style="color:#666666">=</span> <span style="color:#666666">0</span>; retries <span style="color:#666666">&lt;</span> MAX_RETRIES; retries<span style="color:#666666">++</span>) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>endpoint <span style="color:#666666">=</span> argv <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>reply <span style="color:#666666">=</span> s_try_request (ctx, endpoint, request);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (reply)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Successful</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"W: no response from %s, retrying…</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, endpoint);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>For multiple endpoints, try each at most once</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> endpoint_nbr;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>for</strong></span> (endpoint_nbr <span style="color:#666666">=</span> <span style="color:#666666">0</span>; endpoint_nbr <span style="color:#666666">&lt;</span> endpoints; endpoint_nbr<span style="color:#666666">++</span>) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>endpoint <span style="color:#666666">=</span> argv <span style="white-space: pre-wrap;">[</span>endpoint_nbr <span style="color:#666666">+</span> <span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>reply <span style="color:#666666">=</span> s_try_request (ctx, endpoint, request);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (reply)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Successful</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"W: no response from %s</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, endpoint);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (reply)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"Service is running OK</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>request);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>reply);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cs:flclient1" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/java:flclient1" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/php:flclient1" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:flclient1" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/tcl:flclient1" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | Clojure | CL | Delphi | Erlang | F# | Felix | Go | Haskell | Haxe | Lua | Node.js | Objective-C | ooc | Perl | Q | Racket | Ruby | Scala</a></span>
<p>A sample run is:</p>
<div class="code">
<pre><code>flserver1 tcp://*:5555 &amp;
flserver1 tcp://*:5556 &amp;
flclient1 tcp://localhost:5555 tcp://localhost:5556</code>
</pre></div>
<p>Although the basic approach is Lazy Pirate, the client aims to just get one successful reply. It has two techniques, depending on whether you are running a single server or multiple servers:</p>
<ul>
<li>With a single server, the client will retry several times, exactly as for Lazy Pirate.</li>
<li>With multiple servers, the client will try each server at most once until it's received a reply or has tried all servers.</li>
</ul>
<p>This solves the main weakness of Lazy Pirate, namely that it could not fail over to backup or alternate servers.</p>
<p>However, this design won't work well in a real application. If we're connecting many sockets and our primary name server is down, we're going to experience this painful timeout each time.</p>
<p><a name="Model-Two-Brutal-Shotgun-Massacre"></a><a name="header-111"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc110"><span><a href="http://zguide.zeromq.org/page:all#Model-Two-Brutal-Shotgun-Massacre">Model Two: Brutal Shotgun Massacre</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-110">prev</a> <a href="http://zguide.zeromq.org/page:all#header-112">next</a></td>
</tr>
</tbody></table>
<p>Let's switch our client to using a DEALER socket. Our goal here is to make sure we get a reply back within the shortest possible time, no matter whether a particular server is up or down. Our client takes this approach:</p>
<ul>
<li>We set things up, connecting to all servers.</li>
<li>When we have a request, we blast it out as many times as we have servers.</li>
<li>We wait for the first reply, and take that.</li>
<li>We ignore any other replies.</li>
</ul>
<p>What will happen in practice is that when all servers are running, ZeroMQ will distribute the requests so that each server gets one request and sends one reply. When any server is offline and disconnected, ZeroMQ will distribute the requests to the remaining servers. So a server may in some cases get the same request more than once.</p>
<p>What's more annoying for the client is that we'll get multiple replies back, but there's no guarantee we'll get a precise number of replies. Requests and replies can get lost (e.g., if the server crashes while processing a request).</p>
<p>So we have to number requests and ignore any replies that don't match the request number. Our Model One server will work because it's an echo server, but coincidence is not a great basis for understanding. So we'll make a Model Two server that chews up the message and returns a correctly numbered reply with the content "OK". We'll use messages consisting of two parts: a sequence number and a body.</p>
<p>Start one or more servers, specifying a bind endpoint each time:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">flserver2:&nbsp;Freelance&nbsp;server,&nbsp;Model&nbsp;Two&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">flserver2:&nbsp;Freelance&nbsp;server,&nbsp;Model&nbsp;Two&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Freelance server - Model 2<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Does some work, replies OK, with message sequencing</span></p>
<p>#include "czmq.h"</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">int</span> argc, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>argv <span style="white-space: pre-wrap;">[]</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (argc <span style="color:#666666">&lt;</span> <span style="color:#666666">2</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"I: syntax: %s &lt;endpoint&gt;</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, argv <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>server <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_REP);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (server, argv <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"I: service is ready at %s</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, argv <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_t <span style="color:#666666">*</span>request <span style="color:#666666">=</span> zmsg_recv (server);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>request)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Fail nastily if run against wrong client</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>assert (zmsg_size (request) <span style="color:#666666">==</span> <span style="color:#666666">2</span>);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt>zframe_t <span style="color:#666666">*</span>identity <span style="color:#666666">=</span> zmsg_pop (request);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>request);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_t <span style="color:#666666">*</span>reply <span style="color:#666666">=</span> zmsg_new ();<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_add (reply, identity);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_addstr (reply, <span style="color:#BA2121">"OK"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>reply, server);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (zctx_interrupted)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"W: interrupted</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cs:flserver2" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/java:flserver2" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:flserver2" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/php:flserver2" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:flserver2" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/tcl:flserver2" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | Clojure | CL | Delphi | Erlang | F# | Felix | Go | Haskell | Haxe | Node.js | Objective-C | ooc | Perl | Q | Racket | Ruby | Scala</a></span>
<p>Then start the client, specifying the connect endpoints as arguments:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">flclient2:&nbsp;Freelance&nbsp;client,&nbsp;Model&nbsp;Two&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">flclient2:&nbsp;Freelance&nbsp;client,&nbsp;Model&nbsp;Two&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Freelance client - Model 2<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Uses DEALER socket to blast one or more services</span></p>
<p>#include "czmq.h"</p>
<p><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We design our client API as a class, using the CZMQ style<br>
#ifdef <span style="white-space: pre-wrap;">__</span>cplusplus<br>
<span style="color:#008000"><strong>extern</strong></span> <span style="color:#BA2121">"C"</span> {<br>
<span style="color:#BC7A00">#endif</span></p>
<p><span style="color:#008000"><strong>typedef</strong></span> <span style="color:#008000"><strong>struct</strong></span> _flclient_t flclient_t;<br>
flclient_t <span style="color:#666666">*</span>flclient_new (<span style="color:#B00040">void</span>);<br>
<span style="color:#B00040">void</span><tt><span style="white-space: pre-wrap;">        </span></tt>flclient_destroy (flclient_t <span style="color:#666666"><span style="white-space: pre-wrap;">**</span></span>self_p);<br>
<span style="color:#B00040">void</span><tt><span style="white-space: pre-wrap;">        </span></tt>flclient_connect (flclient_t <span style="color:#666666">*</span>self, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>endpoint);<br>
zmsg_t<tt><span style="white-space: pre-wrap;">     </span></tt><span style="color:#666666">*</span>flclient_request (flclient_t <span style="color:#666666">*</span>self, zmsg_t <span style="color:#666666"><span style="white-space: pre-wrap;">**</span></span>request_p);<br>
<span style="color:#BC7A00"><br>
#ifdef <span style="white-space: pre-wrap;">__</span>cplusplus</span><br>
}<br>
<span style="color:#BC7A00">#endif</span></p>
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If not a single service replies within this time, give up<br>
#define GLOBAL_TIMEOUT 2500</span></p>
<p><span style="color:#B00040">int</span> main (<span style="color:#B00040">int</span> argc, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>argv <span style="white-space: pre-wrap;">[]</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (argc <span style="color:#666666">==</span> <span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"I: syntax: %s &lt;endpoint&gt; …</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, argv <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Create new freelance client object</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>flclient_t <span style="color:#666666">*</span>client <span style="color:#666666">=</span> flclient_new ();</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Connect to each endpoint</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> argn;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (argn <span style="color:#666666">=</span> <span style="color:#666666">1</span>; argn <span style="color:#666666">&lt;</span> argc; argn<span style="color:#666666">++</span>)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>flclient_connect (client, argv <span style="white-space: pre-wrap;">[</span>argn<span style="white-space: pre-wrap;">]</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send a bunch of name resolution 'requests', measure time</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> requests <span style="color:#666666">=</span> <span style="color:#666666">10000</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">uint64_t</span> start <span style="color:#666666">=</span> zclock_time ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (requests<span style="color:#666666"><span style="white-space: pre-wrap;">--</span></span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_t <span style="color:#666666">*</span>request <span style="color:#666666">=</span> zmsg_new ();<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_addstr (request, <span style="color:#BA2121">"random name"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_t <span style="color:#666666">*</span>reply <span style="color:#666666">=</span> flclient_request (client, <span style="color:#666666">&amp;</span>request);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>reply) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"E: name service not available, aborting</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>reply);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"Average round trip cost: %d usec</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>,<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>(<span style="color:#B00040">int</span>) (zclock_time () <span style="color:#666666">-</span> start) <span style="color:#666666">/</span> <span style="color:#666666">10</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>flclient_destroy (<span style="color:#666666">&amp;</span>client);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Here is the <tt>flclient</tt> class implementation. Each instance has a<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>context, a DEALER socket it uses to talk to the servers, a counter<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>of how many servers it's connected to, and a request sequence number:</span></span></p>
<p><span style="color:#008000"><strong>struct</strong></span> _flclient_t {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx;<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Our context wrapper</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>socket;<tt><span style="white-space: pre-wrap;">       </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>DEALER socket talking to servers</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">size_t</span> servers;<tt><span style="white-space: pre-wrap;">     </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>How many servers we have connected to</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>uint sequence;<tt><span style="white-space: pre-wrap;">      </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Number of requests ever sent</em></span><br>
};</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Constructor</em></span></p>
<p>flclient_t <span style="color:#666666">*</span><br>
<span style="color:#0000FF">flclient_new</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>flclient_t<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#666666">*</span>self;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>self <span style="color:#666666">=</span> (flclient_t <span style="color:#666666">*</span>) zmalloc (<span style="color:#008000"><strong>sizeof</strong></span> (flclient_t));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>socket <span style="color:#666666">=</span> zsocket_new (self<span style="color:#666666">-&gt;</span>ctx, ZMQ_DEALER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> self;<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Destructor</em></span></p>
<p><span style="color:#B00040">void</span><br>
<span style="color:#0000FF">flclient_destroy</span> (flclient_t <span style="color:#666666"><span style="white-space: pre-wrap;">**</span></span>self_p)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self_p);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">*</span>self_p) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>flclient_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> <span style="color:#666666">*</span>self_p;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (self);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#666666">*</span>self_p <span style="color:#666666">=</span> <span style="color:#008000">NULL</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Connect to new server endpoint</em></span></p>
<p><span style="color:#B00040">void</span><br>
<span style="color:#0000FF">flclient_connect</span> (flclient_t <span style="color:#666666">*</span>self, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>endpoint)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect (self<span style="color:#666666">-&gt;</span>socket, endpoint);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>servers<span style="color:#666666">++</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This method does the hard work. It sends a request to all<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>connected servers in parallel (for this to work, all connections<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>must be successful and completed by this time). It then waits<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>for a single successful reply, and returns that to the caller.<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Any other replies are just dropped:</span></span></p>
<p>zmsg_t <span style="color:#666666">*</span><br>
<span style="color:#0000FF">flclient_request</span> (flclient_t <span style="color:#666666">*</span>self, zmsg_t <span style="color:#666666"><span style="white-space: pre-wrap;">**</span></span>request_p)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (<span style="color:#666666">*</span>request_p);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>request <span style="color:#666666">=</span> <span style="color:#666666">*</span>request_p;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Prefix request with sequence number and empty envelope</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> sequence_text <span style="white-space: pre-wrap;">[</span><span style="color:#666666">10</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>sprintf (sequence_text, <span style="color:#BA2121">"%u"</span>, <span style="color:#666666">++</span>self<span style="color:#666666">-&gt;</span>sequence);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_pushstr (request, sequence_text);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_pushstr (request, <span style="color:#BA2121">""</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Blast the request to all connected servers</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> server;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (server <span style="color:#666666">=</span> <span style="color:#666666">0</span>; server <span style="color:#666666">&lt;</span> self<span style="color:#666666">-&gt;</span>servers; server<span style="color:#666666">++</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_dup (request);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>msg, self<span style="color:#666666">-&gt;</span>socket);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Wait for a matching reply to arrive from anywhere</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Since we can poll several times, calculate each one</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>reply <span style="color:#666666">=</span> <span style="color:#008000">NULL</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">uint64_t</span> endtime <span style="color:#666666">=</span> zclock_time () <span style="color:#666666">+</span> GLOBAL_TIMEOUT;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (zclock_time () <span style="color:#666666">&lt;</span> endtime) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_pollitem_t items <span style="white-space: pre-wrap;">[]</span> <span style="color:#666666">=</span> { { self<span style="color:#666666">-&gt;</span>socket, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> } };<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_poll (items, <span style="color:#666666">1</span>, (endtime <span style="color:#666666">-</span> zclock_time ()) <span style="color:#666666">*</span> ZMQ_POLL_MSEC);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Reply is <span style="white-space: pre-wrap;">[</span>empty<span style="white-space: pre-wrap;">][</span>sequence<span style="white-space: pre-wrap;">][</span>OK<span style="white-space: pre-wrap;">]</span></span></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>reply <span style="color:#666666">=</span> zmsg_recv (self<span style="color:#666666">-&gt;</span>socket);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>assert (zmsg_size (reply) <span style="color:#666666">==</span> <span style="color:#666666">3</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>free (zmsg_popstr (reply));<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>sequence <span style="color:#666666">=</span> zmsg_popstr (reply);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">int</span> sequence_nbr <span style="color:#666666">=</span> atoi (sequence);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>free (sequence);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (sequence_nbr <span style="color:#666666">==</span> self<span style="color:#666666">-&gt;</span>sequence)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>reply);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_destroy (request_p);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> reply;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cs:flclient2" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/java:flclient2" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/php:flclient2" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:flclient2" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/tcl:flclient2" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | Clojure | CL | Delphi | Erlang | F# | Felix | Go | Haskell | Haxe | Lua | Node.js | Objective-C | ooc | Perl | Q | Racket | Ruby | Scala</a></span>
<p>Here are some things to note about the client implementation:</p>
<ul>
<li>The client is structured as a nice little class-based API that hides the dirty work of creating ZeroMQ contexts and sockets and talking to the server. That is, if a shotgun blast to the midriff can be called "talking".</li>
</ul>
<ul>
<li>The client will abandon the chase if it can't find <em>any</em> responsive server within a few seconds.</li>
</ul>
<ul>
<li>The client has to create a valid REP envelope, i.e., add an empty message frame to the front of the message.</li>
</ul>
<p>The client performs 10,000 name resolution requests (fake ones, as our server does essentially nothing) and measures the average cost. On my test box, talking to one server, this requires about 60 microseconds. Talking to three servers, it takes about 80 microseconds.</p>
<p>The pros and cons of our shotgun approach are:</p>
<ul>
<li>Pro: it is simple, easy to make and easy to understand.</li>
<li>Pro: it does the job of failover, and works rapidly, so long as there is at least one server running.</li>
<li>Con: it creates redundant network traffic.</li>
<li>Con: we can't prioritize our servers, i.e., Primary, then Secondary.</li>
<li>Con: the server can do at most one request at a time, period.</li>
</ul>
<p><a name="Model-Three-Complex-and-Nasty"></a><a name="header-112"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc111"><span><a href="http://zguide.zeromq.org/page:all#Model-Three-Complex-and-Nasty">Model Three: Complex and Nasty</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-111">prev</a> <a href="http://zguide.zeromq.org/page:all#header-113">next</a></td>
</tr>
</tbody></table>
<p>The shotgun approach seems too good to be true. Let's be scientific and work through all the alternatives. We're going to explore the complex/nasty option, even if it's only to finally realize that we preferred brutal. Ah, the story of my life.</p>
<p>We can solve the main problems of the client by switching to a ROUTER socket. That lets us send requests to specific servers, avoid servers we know are dead, and in general be as smart as we want to be. We can also solve the main problem of the server (single-threadedness) by switching to a ROUTER socket.</p>
<p>But doing ROUTER to ROUTER between two anonymous sockets (which haven't set an identity) is not possible. Both sides generate an identity (for the other peer) only when they receive a first message, and thus neither can talk to the other until it has first received a message. The only way out of this conundrum is to cheat, and use hard-coded identities in one direction. The proper way to cheat, in a client/server case, is to let the client "know" the identity of the server. Doing it the other way around would be insane, on top of complex and nasty, because any number of clients should be able to arise independently. Insane, complex, and nasty are great attributes for a genocidal dictator, but terrible ones for software.</p>
<p>Rather than invent yet another concept to manage, we'll use the connection endpoint as identity. This is a unique string on which both sides can agree without more prior knowledge than they already have for the shotgun model. It's a sneaky and effective way to connect two ROUTER sockets.</p>
<p>Remember how ZeroMQ identities work. The server ROUTER socket sets an identity before it binds its socket. When a client connects, they do a little handshake to exchange identities, before either side sends a real message. The client ROUTER socket, having not set an identity, sends a null identity to the server. The server generates a random UUID to designate the client for its own use. The server sends its identity (which we've agreed is going to be an endpoint string) to the client.</p>
<p>This means that our client can route a message to the server (i.e., send on its ROUTER socket, specifying the server endpoint as identity) as soon as the connection is established. That's not <em>immediately</em> after doing a <tt><a href="http://api.zeromq.org/3-2:zmq_connect">zmq_connect()</a></tt>, but some random time thereafter. Herein lies one problem: we don't know when the server will actually be available and complete its connection handshake. If the server is online, it could be after a few milliseconds. If the server is down and the sysadmin is out to lunch, it could be an hour from now.</p>
<p>There's a small paradox here. We need to know when servers become connected and available for work. In the Freelance pattern, unlike the broker-based patterns we saw earlier in this chapter, servers are silent until spoken to. Thus we can't talk to a server until it's told us it's online, which it can't do until we've asked it.</p>
<p>My solution is to mix in a little of the shotgun approach from model 2, meaning we'll fire (harmless) shots at anything we can, and if anything moves, we know it's alive. We're not going to fire real requests, but rather a kind of ping-pong heartbeat.</p>
<p>This brings us to the realm of protocols again, so here's a <a href="http://rfc.zeromq.org/spec:10">short spec that defines how a Freelance client and server exchange ping-pong commands and request-reply commands</a>.</p>
<p>It is short and sweet to implement as a server. Here's our echo server, Model Three, now speaking FLP:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">flserver3:&nbsp;Freelance&nbsp;server,&nbsp;Model&nbsp;Three&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">flserver3:&nbsp;Freelance&nbsp;server,&nbsp;Model&nbsp;Three&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Freelance server - Model 3<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Uses an ROUTER/ROUTER socket but just one thread</span></p>
<p>#include "czmq.h"</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">int</span> argc, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>argv <span style="white-space: pre-wrap;">[]</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> verbose <span style="color:#666666">=</span> (argc <span style="color:#666666">&gt;</span> <span style="color:#666666">1</span> <span style="color:#666666">&amp;&amp;</span> streq (argv <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>, <span style="color:#BA2121">"-v"</span>));</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Prepare server socket with predictable identity</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>bind_endpoint <span style="color:#666666">=</span> <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5555"</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>connect_endpoint <span style="color:#666666">=</span> <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5555"</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>server <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_ROUTER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_setsockopt (server,<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>ZMQ_IDENTITY, connect_endpoint, strlen (connect_endpoint));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (server, bind_endpoint);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"I: service is ready at %s</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, bind_endpoint);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">!</span>zctx_interrupted) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_t <span style="color:#666666">*</span>request <span style="color:#666666">=</span> zmsg_recv (server);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (verbose <span style="color:#666666">&amp;&amp;</span> request)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_dump (request);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>request)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span></p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Frame 0: identity of client</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Frame 1: PING, or client control frame</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Frame 2: request body</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_t <span style="color:#666666">*</span>identity <span style="color:#666666">=</span> zmsg_pop (request);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_t <span style="color:#666666">*</span>control <span style="color:#666666">=</span> zmsg_pop (request);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_t <span style="color:#666666">*</span>reply <span style="color:#666666">=</span> zmsg_new ();<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (zframe_streq (control, <span style="color:#BA2121">"PING"</span>))<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_addstr (reply, <span style="color:#BA2121">"PONG"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_add (reply, control);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_addstr (reply, <span style="color:#BA2121">"OK"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>request);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_prepend (reply, <span style="color:#666666">&amp;</span>identity);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (verbose <span style="color:#666666">&amp;&amp;</span> reply)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_dump (reply);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>reply, server);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (zctx_interrupted)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"W: interrupted</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cs:flserver3" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/java:flserver3" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:flserver3" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/py:flserver3" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/tcl:flserver3" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | Clojure | CL | Delphi | Erlang | F# | Felix | Go | Haskell | Haxe | Node.js | Objective-C | ooc | Perl | PHP | Q | Racket | Ruby | Scala</a></span>
<p>The Freelance client, however, has gotten large. For clarity, it's split into an example application and a class that does the hard work. Here's the top-level application:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">flclient3:&nbsp;Freelance&nbsp;client,&nbsp;Model&nbsp;Three&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">flclient3:&nbsp;Freelance&nbsp;client,&nbsp;Model&nbsp;Three&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Freelance client - Model 3<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Uses flcliapi class to encapsulate Freelance pattern</span></p>
<p><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Lets us build this source without creating a library<br>
#include "flcliapi.c"</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Create new freelance client object</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>flcliapi_t <span style="color:#666666">*</span>client <span style="color:#666666">=</span> flcliapi_new ();</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Connect to several endpoints</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>flcliapi_connect (client, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5555"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>flcliapi_connect (client, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5556"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>flcliapi_connect (client, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5557"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send a bunch of name resolution 'requests', measure time</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> requests <span style="color:#666666">=</span> <span style="color:#666666">1000</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">uint64_t</span> start <span style="color:#666666">=</span> zclock_time ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (requests<span style="color:#666666"><span style="white-space: pre-wrap;">--</span></span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_t <span style="color:#666666">*</span>request <span style="color:#666666">=</span> zmsg_new ();<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_addstr (request, <span style="color:#BA2121">"random name"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_t <span style="color:#666666">*</span>reply <span style="color:#666666">=</span> flcliapi_request (client, <span style="color:#666666">&amp;</span>request);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>reply) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"E: name service not available, aborting</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>reply);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"Average round trip cost: %d usec</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>,<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>(<span style="color:#B00040">int</span>) (zclock_time () <span style="color:#666666">-</span> start) <span style="color:#666666">/</span> <span style="color:#666666">10</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>flcliapi_destroy (<span style="color:#666666">&amp;</span>client);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cs:flclient3" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/java:flclient3" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/py:flclient3" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/tcl:flclient3" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | Clojure | CL | Delphi | Erlang | F# | Felix | Go | Haskell | Haxe | Lua | Node.js | Objective-C | ooc | Perl | PHP | Q | Racket | Ruby | Scala</a></span>
<p>And here, almost as complex and large as the Majordomo broker, is the client API class:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">flcliapi:&nbsp;Freelance&nbsp;client&nbsp;API&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">flcliapi:&nbsp;Freelance&nbsp;client&nbsp;API&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>flcliapi class - Freelance Pattern agent class<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Implements the Freelance Protocol at http:<span style="white-space: pre-wrap;">//</span>rfc.zeromq.org/spec:10</span></p>
<p>#include "flcliapi.h"</p>
<p><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If no server replies within this time, abandon request<br>
#define GLOBAL_TIMEOUT<tt><span style="white-space: pre-wrap;">  </span></tt>3000<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>msecs</em></span><br>
<span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>PING interval for servers we think are alive<br>
#define PING_INTERVAL<tt><span style="white-space: pre-wrap;">   </span></tt>2000<tt><span style="white-space: pre-wrap;">    </span></tt></span><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>msecs</em></span><br>
<span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Server considered dead if silent for this long<br>
#define SERVER_TTL<tt><span style="white-space: pre-wrap;">      </span></tt>6000<tt><span style="white-space: pre-wrap;">    </span></tt></span><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>msecs</em></span></p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This API works in two halves, a common pattern for APIs that need to<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>run in the background. One half is an frontend object our application<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>creates and works with; the other half is a backend "agent" that runs<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>in a background thread. The frontend talks to the backend over an<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>inproc pipe socket:</span></span></p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Structure of our frontend class</em></span></p>
<p><span style="color:#008000"><strong>struct</strong></span> _flcliapi_t {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx;<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Our context wrapper</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>pipe;<tt><span style="white-space: pre-wrap;">         </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Pipe through to flcliapi agent</em></span><br>
};</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This is the thread that handles our real flcliapi class</em></span><br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span> flcliapi_agent (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>args, zctx_t <span style="color:#666666">*</span>ctx, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>pipe);</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Constructor</em></span></p>
<p>flcliapi_t <span style="color:#666666">*</span><br>
<span style="color:#0000FF">flcliapi_new</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>flcliapi_t<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#666666">*</span>self;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>self <span style="color:#666666">=</span> (flcliapi_t <span style="color:#666666">*</span>) zmalloc (<span style="color:#008000"><strong>sizeof</strong></span> (flcliapi_t));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>pipe <span style="color:#666666">=</span> zthread_fork (self<span style="color:#666666">-&gt;</span>ctx, flcliapi_agent, <span style="color:#008000">NULL</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> self;<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Destructor</em></span></p>
<p><span style="color:#B00040">void</span><br>
<span style="color:#0000FF">flcliapi_destroy</span> (flcliapi_t <span style="color:#666666"><span style="white-space: pre-wrap;">**</span></span>self_p)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self_p);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">*</span>self_p) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>flcliapi_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> <span style="color:#666666">*</span>self_p;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (self);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#666666">*</span>self_p <span style="color:#666666">=</span> <span style="color:#008000">NULL</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>To implement the connect method, the frontend object sends a multipart<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>message to the backend agent. The first part is a string "CONNECT", and<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>the second part is the endpoint. It waits 100msec for the connection to<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>come up, which isn't pretty, but saves us from sending all requests to a<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>single server, at startup time:</span></span></p>
<p><span style="color:#B00040">void</span><br>
<span style="color:#0000FF">flcliapi_connect</span> (flcliapi_t <span style="color:#666666">*</span>self, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>endpoint)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (endpoint);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_addstr (msg, <span style="color:#BA2121">"CONNECT"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_addstr (msg, endpoint);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>msg, self<span style="color:#666666">-&gt;</span>pipe);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zclock_sleep (<span style="color:#666666">100</span>);<tt><span style="white-space: pre-wrap;">      </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Allow connection to come up</em></span><br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>To implement the request method, the frontend object sends a message<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>to the backend, specifying a command "REQUEST" and the request message:</span></span></p>
<p>zmsg_t <span style="color:#666666">*</span><br>
<span style="color:#0000FF">flcliapi_request</span> (flcliapi_t <span style="color:#666666">*</span>self, zmsg_t <span style="color:#666666"><span style="white-space: pre-wrap;">**</span></span>request_p)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (<span style="color:#666666">*</span>request_p);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_pushstr (<span style="color:#666666">*</span>request_p, <span style="color:#BA2121">"REQUEST"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_send (request_p, self<span style="color:#666666">-&gt;</span>pipe);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>reply <span style="color:#666666">=</span> zmsg_recv (self<span style="color:#666666">-&gt;</span>pipe);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (reply) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>status <span style="color:#666666">=</span> zmsg_popstr (reply);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (streq (status, <span style="color:#BA2121">"FAILED"</span>))<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>reply);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (status);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> reply;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Here we see the backend agent. It runs as an attached thread, talking<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>to its parent over a pipe socket. It is a fairly complex piece of work<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>so we'll break it down into pieces. First, the agent manages a set of<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>servers, using our familiar class approach:</span></span></p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Simple class for one server we talk to</em></span></p>
<p><span style="color:#008000"><strong>typedef</strong></span> <span style="color:#008000"><strong>struct</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>endpoint;<tt><span style="white-space: pre-wrap;">             </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Server identity/endpoint</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>uint alive;<tt><span style="white-space: pre-wrap;">                 </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>1 if known to be alive</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int64_t</span> ping_at;<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Next ping at this time</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int64_t</span> expires;<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Expires at this time</em></span><br>
} server_t;</p>
<p>server_t <span style="color:#666666">*</span><br>
<span style="color:#0000FF">server_new</span> (<span style="color:#B00040">char</span> <span style="color:#666666">*</span>endpoint)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>server_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> (server_t <span style="color:#666666">*</span>) zmalloc (<span style="color:#008000"><strong>sizeof</strong></span> (server_t));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>endpoint <span style="color:#666666">=</span> strdup (endpoint);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>alive <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>ping_at <span style="color:#666666">=</span> zclock_time () <span style="color:#666666">+</span> PING_INTERVAL;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>expires <span style="color:#666666">=</span> zclock_time () <span style="color:#666666">+</span> SERVER_TTL;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> self;<br>
}</p>
<p><span style="color:#B00040">void</span><br>
<span style="color:#0000FF">server_destroy</span> (server_t <span style="color:#666666"><span style="white-space: pre-wrap;">**</span></span>self_p)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self_p);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">*</span>self_p) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>server_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> <span style="color:#666666">*</span>self_p;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (self<span style="color:#666666">-&gt;</span>endpoint);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (self);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#666666">*</span>self_p <span style="color:#666666">=</span> <span style="color:#008000">NULL</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
}</p>
<p><span style="color:#B00040">int</span><br>
<span style="color:#0000FF">server_ping</span> (<span style="color:#008000"><strong>const</strong></span> <span style="color:#B00040">char</span> <span style="color:#666666">*</span>key, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>server, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>socket)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>server_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> (server_t <span style="color:#666666">*</span>) server;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (zclock_time () <span style="color:#666666">&gt;=</span> self<span style="color:#666666">-&gt;</span>ping_at) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_t <span style="color:#666666">*</span>ping <span style="color:#666666">=</span> zmsg_new ();<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_addstr (ping, self<span style="color:#666666">-&gt;</span>endpoint);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_addstr (ping, <span style="color:#BA2121">"PING"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>ping, socket);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>self<span style="color:#666666">-&gt;</span>ping_at <span style="color:#666666">=</span> zclock_time () <span style="color:#666666">+</span> PING_INTERVAL;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
<p><span style="color:#B00040">int</span><br>
<span style="color:#0000FF">server_tickless</span> (<span style="color:#008000"><strong>const</strong></span> <span style="color:#B00040">char</span> <span style="color:#666666">*</span>key, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>server, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>arg)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>server_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> (server_t <span style="color:#666666">*</span>) server;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">uint64_t</span> <span style="color:#666666">*</span>tickless <span style="color:#666666">=</span> (<span style="color:#B00040">uint64_t</span> <span style="color:#666666">*</span>) arg;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">*</span>tickless <span style="color:#666666">&gt;</span> self<span style="color:#666666">-&gt;</span>ping_at)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#666666">*</span>tickless <span style="color:#666666">=</span> self<span style="color:#666666">-&gt;</span>ping_at;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We build the agent as a class that's capable of processing messages<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>coming in from its various sockets:</span></span></p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Simple class for one background agent</em></span></p>
<p><span style="color:#008000"><strong>typedef</strong></span> <span style="color:#008000"><strong>struct</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx;<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Own context</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>pipe;<tt><span style="white-space: pre-wrap;">                 </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Socket to talk back to application</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>router;<tt><span style="white-space: pre-wrap;">               </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Socket to talk to servers</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zhash_t <span style="color:#666666">*</span>servers;<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Servers we've connected to</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zlist_t <span style="color:#666666">*</span>actives;<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Servers we know are alive</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>uint sequence;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Number of requests ever sent</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>request;<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Current request if any</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>reply;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Current reply if any</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int64_t</span> expires;<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Timeout for request/reply</em></span><br>
} agent_t;</p>
<p>agent_t <span style="color:#666666">*</span><br>
<span style="color:#0000FF">agent_new</span> (zctx_t <span style="color:#666666">*</span>ctx, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>pipe)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>agent_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> (agent_t <span style="color:#666666">*</span>) zmalloc (<span style="color:#008000"><strong>sizeof</strong></span> (agent_t));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>ctx <span style="color:#666666">=</span> ctx;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>pipe <span style="color:#666666">=</span> pipe;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>router <span style="color:#666666">=</span> zsocket_new (self<span style="color:#666666">-&gt;</span>ctx, ZMQ_ROUTER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>servers <span style="color:#666666">=</span> zhash_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>actives <span style="color:#666666">=</span> zlist_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> self;<br>
}</p>
<p><span style="color:#B00040">void</span><br>
<span style="color:#0000FF">agent_destroy</span> (agent_t <span style="color:#666666"><span style="white-space: pre-wrap;">**</span></span>self_p)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self_p);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">*</span>self_p) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>agent_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> <span style="color:#666666">*</span>self_p;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zhash_destroy (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>servers);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zlist_destroy (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>actives);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>request);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>reply);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (self);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#666666">*</span>self_p <span style="color:#666666">=</span> <span style="color:#008000">NULL</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This method processes one message from our frontend class<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>(it's going to be CONNECT or REQUEST):</span></span></p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Callback when we remove server from agent 'servers' hash table</em></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<span style="color:#0000FF">s_server_free</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>argument)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>server_t <span style="color:#666666">*</span>server <span style="color:#666666">=</span> (server_t <span style="color:#666666">*</span>) argument;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>server_destroy (<span style="color:#666666">&amp;</span>server);<br>
}</p>
<p><span style="color:#B00040">void</span><br>
<span style="color:#0000FF">agent_control_message</span> (agent_t <span style="color:#666666">*</span>self)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_recv (self<span style="color:#666666">-&gt;</span>pipe);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>command <span style="color:#666666">=</span> zmsg_popstr (msg);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (streq (command, <span style="color:#BA2121">"CONNECT"</span>)) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>endpoint <span style="color:#666666">=</span> zmsg_popstr (msg);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"I: connecting to %s…</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, endpoint);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> rc <span style="color:#666666">=</span> zmq_connect (self<span style="color:#666666">-&gt;</span>router, endpoint);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>assert (rc <span style="color:#666666">==</span> <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>server_t <span style="color:#666666">*</span>server <span style="color:#666666">=</span> server_new (endpoint);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zhash_insert (self<span style="color:#666666">-&gt;</span>servers, endpoint, server);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zhash_freefn (self<span style="color:#666666">-&gt;</span>servers, endpoint, s_server_free);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zlist_append (self<span style="color:#666666">-&gt;</span>actives, server);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>server<span style="color:#666666">-&gt;</span>ping_at <span style="color:#666666">=</span> zclock_time () <span style="color:#666666">+</span> PING_INTERVAL;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>server<span style="color:#666666">-&gt;</span>expires <span style="color:#666666">=</span> zclock_time () <span style="color:#666666">+</span> SERVER_TTL;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (endpoint);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (streq (command, <span style="color:#BA2121">"REQUEST"</span>)) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>assert (<span style="color:#666666">!</span>self<span style="color:#666666">-&gt;</span>request);<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Strict request-reply cycle</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Prefix request with sequence number and empty envelope</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> sequence_text <span style="white-space: pre-wrap;">[</span><span style="color:#666666">10</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>sprintf (sequence_text, <span style="color:#BA2121">"%u"</span>, <span style="color:#666666">++</span>self<span style="color:#666666">-&gt;</span>sequence);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_pushstr (msg, sequence_text);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Take ownership of request message</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>self<span style="color:#666666">-&gt;</span>request <span style="color:#666666">=</span> msg;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>msg <span style="color:#666666">=</span> <span style="color:#008000">NULL</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Request expires after global timeout</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>self<span style="color:#666666">-&gt;</span>expires <span style="color:#666666">=</span> zclock_time () <span style="color:#666666">+</span> GLOBAL_TIMEOUT;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>free (command);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>msg);<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This method processes one message from a connected<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>server:</span></span></p>
<p><span style="color:#B00040">void</span><br>
<span style="color:#0000FF">agent_router_message</span> (agent_t <span style="color:#666666">*</span>self)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>reply <span style="color:#666666">=</span> zmsg_recv (self<span style="color:#666666">-&gt;</span>router);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Frame 0 is server that replied</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>endpoint <span style="color:#666666">=</span> zmsg_popstr (reply);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>server_t <span style="color:#666666">*</span>server <span style="color:#666666">=</span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>(server_t <span style="color:#666666">*</span>) zhash_lookup (self<span style="color:#666666">-&gt;</span>servers, endpoint);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (server);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>free (endpoint);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>server<span style="color:#666666">-&gt;</span>alive) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zlist_append (self<span style="color:#666666">-&gt;</span>actives, server);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>server<span style="color:#666666">-&gt;</span>alive <span style="color:#666666">=</span> <span style="color:#666666">1</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>server<span style="color:#666666">-&gt;</span>ping_at <span style="color:#666666">=</span> zclock_time () <span style="color:#666666">+</span> PING_INTERVAL;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>server<span style="color:#666666">-&gt;</span>expires <span style="color:#666666">=</span> zclock_time () <span style="color:#666666">+</span> SERVER_TTL;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Frame 1 may be sequence number for reply</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>sequence <span style="color:#666666">=</span> zmsg_popstr (reply);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (atoi (sequence) <span style="color:#666666">==</span> self<span style="color:#666666">-&gt;</span>sequence) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_pushstr (reply, <span style="color:#BA2121">"OK"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>reply, self<span style="color:#666666">-&gt;</span>pipe);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>request);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>reply);<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Finally, here's the agent task itself, which polls its two sockets<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>and processes incoming messages:</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<span style="color:#0000FF">flcliapi_agent</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>args, zctx_t <span style="color:#666666">*</span>ctx, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>pipe)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>agent_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> agent_new (ctx, pipe);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zmq_pollitem_t items <span style="white-space: pre-wrap;">[]</span> <span style="color:#666666">=</span> {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>{ self<span style="color:#666666">-&gt;</span>pipe, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> },<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>{ self<span style="color:#666666">-&gt;</span>router, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> }<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">!</span>zctx_interrupted) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Calculate tickless timer, up to 1 hour</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">uint64_t</span> tickless <span style="color:#666666">=</span> zclock_time () <span style="color:#666666">+</span> <span style="color:#666666">1000</span> <span style="color:#666666">*</span> <span style="color:#666666">3600</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>request<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#666666">&amp;&amp;</span><tt><span style="white-space: pre-wrap;">  </span></tt>tickless <span style="color:#666666">&gt;</span> self<span style="color:#666666">-&gt;</span>expires)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>tickless <span style="color:#666666">=</span> self<span style="color:#666666">-&gt;</span>expires;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zhash_foreach (self<span style="color:#666666">-&gt;</span>servers, server_tickless, <span style="color:#666666">&amp;</span>tickless);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> rc <span style="color:#666666">=</span> zmq_poll (items, <span style="color:#666666">2</span>,<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>(tickless <span style="color:#666666">-</span> zclock_time ()) <span style="color:#666666">*</span> ZMQ_POLL_MSEC);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (rc <span style="color:#666666">==</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Context has been shut down</em></span></p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>agent_control_message (self);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>agent_router_message (self);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If we're processing a request, dispatch to next server</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>request) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (zclock_time () <span style="color:#666666">&gt;=</span> self<span style="color:#666666">-&gt;</span>expires) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Request expired, kill it</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zstr_send (self<span style="color:#666666">-&gt;</span>pipe, <span style="color:#BA2121">"FAILED"</span>);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>request);<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>else</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Find server to talk to, remove any expired ones</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>while</strong></span> (zlist_size (self<span style="color:#666666">-&gt;</span>actives)) {<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>server_t <span style="color:#666666">*</span>server <span style="color:#666666">=</span><br>
<tt><span style="white-space: pre-wrap;">                        </span></tt>(server_t <span style="color:#666666">*</span>) zlist_first (self<span style="color:#666666">-&gt;</span>actives);<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt><span style="color:#008000"><strong>if</strong></span> (zclock_time () <span style="color:#666666">&gt;=</span> server<span style="color:#666666">-&gt;</span>expires) {<br>
<tt><span style="white-space: pre-wrap;">                        </span></tt>zlist_pop (self<span style="color:#666666">-&gt;</span>actives);<br>
<tt><span style="white-space: pre-wrap;">                        </span></tt>server<span style="color:#666666">-&gt;</span>alive <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">                    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">                    </span></tt><span style="color:#008000"><strong>else</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">                        </span></tt>zmsg_t <span style="color:#666666">*</span>request <span style="color:#666666">=</span> zmsg_dup (self<span style="color:#666666">-&gt;</span>request);<br>
<tt><span style="white-space: pre-wrap;">                        </span></tt>zmsg_pushstr (request, server<span style="color:#666666">-&gt;</span>endpoint);<br>
<tt><span style="white-space: pre-wrap;">                        </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>request, self<span style="color:#666666">-&gt;</span>router);<br>
<tt><span style="white-space: pre-wrap;">                        </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">                    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">                </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Disconnect and delete any expired servers</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send heartbeats to idle servers if needed</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zhash_foreach (self<span style="color:#666666">-&gt;</span>servers, server_ping, self<span style="color:#666666">-&gt;</span>router);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>agent_destroy (<span style="color:#666666">&amp;</span>self);<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cs:flcliapi" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/java:flcliapi" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/py:flcliapi" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/tcl:flcliapi" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | Clojure | CL | Delphi | Erlang | F# | Felix | Go | Haskell | Haxe | Lua | Node.js | Objective-C | ooc | Perl | PHP | Q | Racket | Ruby | Scala</a></span>
<p>This API implementation is fairly sophisticated and uses a couple of techniques that we've not seen before.</p>
<ul>
<li><strong>Multithreaded API</strong>: the client API consists of two parts, a synchronous <tt>flcliapi</tt> class that runs in the application thread, and an asynchronous <em>agent</em> class that runs as a background thread. Remember how ZeroMQ makes it easy to create multithreaded apps. The flcliapi and agent classes talk to each other with messages over an <tt>inproc</tt> socket. All ZeroMQ aspects (such as creating and destroying a context) are hidden in the API. The agent in effect acts like a mini-broker, talking to servers in the background, so that when we make a request, it can make a best effort to reach a server it believes is available.</li>
</ul>
<ul>
<li><strong>Tickless poll timer</strong>: in previous poll loops we always used a fixed tick interval, e.g., 1 second, which is simple enough but not excellent on power-sensitive clients (such as notebooks or mobile phones), where waking the CPU costs power. For fun, and to help save the planet, the agent uses a <em>tickless timer</em>, which calculates the poll delay based on the next timeout we're expecting. A proper implementation would keep an ordered list of timeouts. We just check all timeouts and calculate the poll delay until the next one.</li>
</ul>
<p><a name="Conclusion"></a><a name="header-113"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc112"><span><a href="http://zguide.zeromq.org/page:all#Conclusion">Conclusion</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-112">prev</a> <a href="http://zguide.zeromq.org/page:all#header-114">next</a></td>
</tr>
</tbody></table>
<p>In this chapter, we've seen a variety of reliable request-reply mechanisms, each with certain costs and benefits. The example code is largely ready for real use, though it is not optimized. Of all the different patterns, the two that stand out for production use are the Majordomo pattern, for broker-based reliability, and the Freelance pattern, for brokerless reliability.</p>
<p><a name="advanced-pub-sub"></a><br>
<a name="Chapter-Advanced-Pub-Sub-Patterns"></a><a name="header-114"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h2 id="toc113"><span><a href="http://zguide.zeromq.org/page:all#Chapter-Advanced-Pub-Sub-Patterns">Chapter 5 - Advanced Pub-Sub Patterns</a></span></h2>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-113">prev</a> <a href="http://zguide.zeromq.org/page:all#header-115">next</a></td>
</tr>
</tbody></table>
<p>In <a href="http://zguide.zeromq.org/page:all#advanced-request-reply">Chapter 3 - Advanced Request-Reply Patterns</a> and <a href="http://zguide.zeromq.org/page:all#reliable-request-reply">Chapter 4 - Reliable Request-Reply Patterns</a> we looked at advanced use of ZeroMQ's request-reply pattern. If you managed to digest all that, congratulations. In this chapter we'll focus on publish-subscribe and extend ZeroMQ's core pub-sub pattern with higher-level patterns for performance, reliability, state distribution, and monitoring.</p>
<p>We'll cover:</p>
<ul>
<li>When to use publish-subscribe</li>
<li>How to handle too-slow subscribers (the <em>Suicidal Snail</em> pattern)</li>
<li>How to design high-speed subscribers (the <em>Black Box</em> pattern)</li>
<li>How to monitor a pub-sub network (the <em>Espresso</em> pattern)</li>
<li>How to build a shared key-value store (the <em>Clone</em> pattern)</li>
<li>How to use reactors to simplify complex servers</li>
<li>How to use the Binary Star pattern to add failover to a server</li>
</ul>
<p><a name="Pros-and-Cons-of-Pub-Sub"></a><a name="header-115"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc114"><span><a href="http://zguide.zeromq.org/page:all#Pros-and-Cons-of-Pub-Sub">Pros and Cons of Pub-Sub</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-114">prev</a> <a href="http://zguide.zeromq.org/page:all#header-116">next</a></td>
</tr>
</tbody></table>
<p>ZeroMQ's low-level patterns have their different characters. Pub-sub addresses an old messaging problem, which is <em>multicast</em> or <em>group messaging</em>. It has that unique mix of meticulous simplicity and brutal indifference that characterizes ZeroMQ. It's worth understanding the trade-offs that pub-sub makes, how these benefit us, and how we can work around them if needed.</p>
<p>First, PUB sends each message to "all of many", whereas PUSH and DEALER rotate messages to "one of many". You cannot simply replace PUSH with PUB or vice versa and hope that things will work. This bears repeating because people seem to quite often suggest doing this.</p>
<p>More profoundly, pub-sub is aimed at scalability. This means large volumes of data, sent rapidly to many recipients. If you need millions of messages per second sent to thousands of points, you'll appreciate pub-sub a lot more than if you need a few messages a second sent to a handful of recipients.</p>
<p>To get scalability, pub-sub uses the same trick as push-pull, which is to get rid of back-chatter. This means that recipients don't talk back to senders. There are some exceptions, e.g., SUB sockets will send subscriptions to PUB sockets, but it's anonymous and infrequent.</p>
<p>Killing back-chatter is essential to real scalability. With pub-sub, it's how the pattern can map cleanly to the PGM multicast protocol, which is handled by the network switch. In other words, subscribers don't connect to the publisher at all, they connect to a multicast <em>group</em> on the switch, to which the publisher sends its messages.</p>
<p>When we remove back-chatter, our overall message flow becomes <em>much</em> simpler, which lets us make simpler APIs, simpler protocols, and in general reach many more people. But we also remove any possibility to coordinate senders and receivers. What this means is:</p>
<ul>
<li>Publishers can't tell when subscribers are successfully connected, both on initial connections, and on reconnections after network failures.</li>
</ul>
<ul>
<li>Subscribers can't tell publishers anything that would allow publishers to control the rate of messages they send. Publishers only have one setting, which is <em>full-speed</em>, and subscribers must either keep up or lose messages.</li>
</ul>
<ul>
<li>Publishers can't tell when subscribers have disappeared due to processes crashing, networks breaking, and so on.</li>
</ul>
<p>The downside is that we actually need all of these if we want to do reliable multicast. The ZeroMQ pub-sub pattern will lose messages arbitrarily when a subscriber is connecting, when a network failure occurs, or just if the subscriber or network can't keep up with the publisher.</p>
<p>The upside is that there are many use cases where <em>almost</em> reliable multicast is just fine. When we need this back-chatter, we can either switch to using ROUTER-DEALER (which I tend to do for most normal volume cases), or we can add a separate channel for synchronization (we'll see an example of this later in this chapter).</p>
<p>Pub-sub is like a radio broadcast; you miss everything before you join, and then how much information you get depends on the quality of your reception. Surprisingly, this model is useful and widespread because it maps perfectly to real world distribution of information. Think of Facebook and Twitter, the BBC World Service, and the sports results.</p>
<p>As we did for request-reply, let's define <em>reliability</em> in terms of what can go wrong. Here are the classic failure cases for pub-sub:</p>
<ul>
<li>Subscribers join late, so they miss messages the server already sent.</li>
<li>Subscribers can fetch messages too slowly, so queues build up and then overflow.</li>
<li>Subscribers can drop off and lose messages while they are away.</li>
<li>Subscribers can crash and restart, and lose whatever data they already received.</li>
<li>Networks can become overloaded and drop data (specifically, for PGM).</li>
<li>Networks can become too slow, so publisher-side queues overflow and publishers crash.</li>
</ul>
<p>A lot more can go wrong but these are the typical failures we see in a realistic system. Since v3.x, ZeroMQ forces default limits on its internal buffers (the so-called high-water mark or HWM), so publisher crashes are rarer unless you deliberately set the HWM to infinite.</p>
<p>All of these failure cases have answers, though not always simple ones. Reliability requires complexity that most of us don't need, most of the time, which is why ZeroMQ doesn't attempt to provide it out of the box (even if there was one global design for reliability, which there isn't).</p>
<p><a name="Pub-Sub-Tracing-Espresso-Pattern"></a><a name="header-116"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc115"><span><a href="http://zguide.zeromq.org/page:all#Pub-Sub-Tracing-Espresso-Pattern">Pub-Sub Tracing (Espresso Pattern)</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-115">prev</a> <a href="http://zguide.zeromq.org/page:all#header-117">next</a></td>
</tr>
</tbody></table>
<p>Let's start this chapter by looking at a way to trace pub-sub networks. In <a href="http://zguide.zeromq.org/page:all#sockets-and-patterns">Chapter 2 - Sockets and Patterns</a> we saw a simple proxy that used these to do transport bridging. The <tt><a href="http://api.zeromq.org/3-2:zmq_proxy">zmq_proxy()</a></tt> method has three arguments: a <em>frontend</em> and <em>backend</em> socket that it bridges together, and a <em>capture</em> socket to which it will send all messages.</p>
<p>The code is deceptively simple:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">espresso:&nbsp;Espresso&nbsp;Pattern&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">espresso:&nbsp;Espresso&nbsp;Pattern&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Espresso Pattern<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This shows how to capture data using a pub-sub proxy</span></p>
<p>#include "czmq.h"</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The subscriber thread requests messages starting with<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>A and B, then reads and counts incoming messages.</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<span style="color:#0000FF">subscriber_thread</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>args, zctx_t <span style="color:#666666">*</span>ctx, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>pipe)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Subscribe to "A" and "B"</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>subscriber <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_SUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect (subscriber, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:6001"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_set_subscribe (subscriber, <span style="color:#BA2121">"A"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_set_subscribe (subscriber, <span style="color:#BA2121">"B"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> count <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (count <span style="color:#666666">&lt;</span> <span style="color:#666666">5</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>string <span style="color:#666666">=</span> zstr_recv (subscriber);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>string)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (string);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>count<span style="color:#666666">++</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_destroy (ctx, subscriber);<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The publisher sends random messages starting with A-J:</em></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<span style="color:#0000FF">publisher_thread</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>args, zctx_t <span style="color:#666666">*</span>ctx, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>pipe)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>publisher <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_PUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (publisher, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:6000"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">!</span>zctx_interrupted) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> string <span style="white-space: pre-wrap;">[</span><span style="color:#666666">10</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>sprintf (string, <span style="color:#BA2121">"%c-%05d"</span>, randof (<span style="color:#666666">10</span>) <span style="color:#666666">+</span> <span style="color:#BA2121">'A'</span>, randof (<span style="color:#666666">100000</span>));<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (zstr_send (publisher, string) <span style="color:#666666">==</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zclock_sleep (<span style="color:#666666">100</span>);<tt><span style="white-space: pre-wrap;">     </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Wait for 1/10th second</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The listener receives all messages flowing through the proxy, on its<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>pipe. In CZMQ, the pipe is a pair of ZMQ_PAIR sockets that connect<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>attached child threads. In other languages your mileage may vary:</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<span style="color:#0000FF">listener_thread</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>args, zctx_t <span style="color:#666666">*</span>ctx, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>pipe)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Print everything that arrives on pipe</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_t <span style="color:#666666">*</span>frame <span style="color:#666666">=</span> zframe_recv (pipe);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>frame)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_print (frame, <span style="color:#008000">NULL</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_destroy (<span style="color:#666666">&amp;</span>frame);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The main task starts the subscriber and publisher, and then sets<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>itself up as a listening proxy. The listener runs as a child thread:</span></span></p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Start child threads</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zthread_fork (ctx, publisher_thread, <span style="color:#008000">NULL</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zthread_fork (ctx, subscriber_thread, <span style="color:#008000">NULL</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>subscriber <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_XSUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect (subscriber, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:6000"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>publisher <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_XPUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (publisher, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:6001"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>listener <span style="color:#666666">=</span> zthread_fork (ctx, listener_thread, <span style="color:#008000">NULL</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_proxy (subscriber, publisher, listener);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>puts (<span style="color:#BA2121">" interrupted"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Tell attached threads to exit</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cs:espresso" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/java:espresso" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/py:espresso" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | Clojure | CL | Delphi | Erlang | F# | Felix | Go | Haskell | Haxe | Lua | Node.js | Objective-C | ooc | Perl | PHP | Q | Racket | Ruby | Scala | Tcl</a></span>
<p>Espresso works by creating a listener thread that reads a PAIR socket and prints anything it gets. That PAIR socket is one end of a pipe; the other end (another PAIR) is the socket we pass to <tt><a href="http://api.zeromq.org/3-2:zmq_proxy">zmq_proxy()</a></tt>. In practice, you'd filter interesting messages to get the essence of what you want to track (hence the name of the pattern).</p>
<p>The subscriber thread subscribes to "A" and "B", receives five messages, and then destroys its socket. When you run the example, the listener prints two subscription messages, five data messages, two unsubscribe messages, and then silence:</p>
<div class="code">
<pre><code>[002] 0141
[002] 0142
[007] B-91164
[007] B-12979
[007] A-52599
[007] A-06417
[007] A-45770
[002] 0041
[002] 0042</code>
</pre></div>
<p>This shows neatly how the publisher socket stops sending data when there are no subscribers for it. The publisher thread is still sending messages. The socket just drops them silently.</p>
<p><a name="Last-Value-Caching"></a><a name="header-117"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc116"><span><a href="http://zguide.zeromq.org/page:all#Last-Value-Caching">Last Value Caching</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-116">prev</a> <a href="http://zguide.zeromq.org/page:all#header-118">next</a></td>
</tr>
</tbody></table>
<p>If you've used commercial pub-sub systems, you may be used to some features that are missing in the fast and cheerful ZeroMQ pub-sub model. One of these is <em>last value caching</em> (LVC). This solves the problem of how a new subscriber catches up when it joins the network. The theory is that publishers get notified when a new subscriber joins and subscribes to some specific topics. The publisher can then rebroadcast the last message for those topics.</p>
<p>I've already explained why publishers don't get notified when there are new subscribers, because in large pub-sub systems, the volumes of data make it pretty much impossible. To make really large-scale pub-sub networks, you need a protocol like PGM that exploits an upscale Ethernet switch's ability to multicast data to thousands of subscribers. Trying to do a TCP unicast from the publisher to each of thousands of subscribers just doesn't scale. You get weird spikes, unfair distribution (some subscribers getting the message before others), network congestion, and general unhappiness.</p>
<p>PGM is a one-way protocol: the publisher sends a message to a multicast address at the switch, which then rebroadcasts that to all interested subscribers. The publisher never sees when subscribers join or leave: this all happens in the switch, which we don't really want to start reprogramming.</p>
<p>However, in a lower-volume network with a few dozen subscribers and a limited number of topics, we can use TCP and then the XSUB and XPUB sockets <em>do</em> talk to each other as we just saw in the Espresso pattern.</p>
<p>Can we make an LVC using ZeroMQ? The answer is yes, if we make a proxy that sits between the publisher and subscribers; an analog for the PGM switch, but one we can program ourselves.</p>
<p>I'll start by making a publisher and subscriber that highlight the worst case scenario. This publisher is pathological. It starts by immediately sending messages to each of a thousand topics, and then it sends one update a second to a random topic. A subscriber connects, and subscribes to a topic. Without LVC, a subscriber would have to wait an average of 500 seconds to get any data. To add some drama, let's pretend there's an escaped convict called Gregor threatening to rip the head off Roger the toy bunny if we can't fix that 8.3 minutes' delay.</p>
<p>Here's the publisher code. Note that it has the command line option to connect to some address, but otherwise binds to an endpoint. We'll use this later to connect to our last value cache:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">pathopub:&nbsp;Pathologic&nbsp;Publisher&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">pathopub:&nbsp;Pathologic&nbsp;Publisher&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Pathological publisher<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Sends out 1,000 topics and then one random update per second</span></p>
<p>#include "czmq.h"</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">int</span> argc, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>argv <span style="white-space: pre-wrap;">[]</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>publisher <span style="color:#666666">=</span> zsocket_new (context, ZMQ_PUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (argc <span style="color:#666666">==</span> <span style="color:#666666">2</span>)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zsocket_bind (publisher, argv <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zsocket_bind (publisher, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5556"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Ensure subscriber connection has time to complete</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>sleep (<span style="color:#666666">1</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send out all 1,000 topic messages</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> topic_nbr;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (topic_nbr <span style="color:#666666">=</span> <span style="color:#666666">0</span>; topic_nbr <span style="color:#666666">&lt;</span> <span style="color:#666666">1000</span>; topic_nbr<span style="color:#666666">++</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zstr_sendfm (publisher, <span style="color:#BA2121">"%03d"</span>, topic_nbr);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zstr_send (publisher, <span style="color:#BA2121">"Save Roger"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send one random update per second</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>srandom ((<span style="color:#B00040">unsigned</span>) time (<span style="color:#008000">NULL</span>));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">!</span>zctx_interrupted) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>sleep (<span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zstr_sendfm (publisher, <span style="color:#BA2121">"%03d"</span>, randof (<span style="color:#666666">1000</span>));<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zstr_send (publisher, <span style="color:#BA2121">"Off with his head!"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>context);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cs:pathopub" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/java:pathopub" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/py:pathopub" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rb:pathopub" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | Clojure | CL | Delphi | Erlang | F# | Felix | Go | Haskell | Haxe | Lua | Node.js | Objective-C | ooc | Perl | PHP | Q | Racket | Scala | Tcl</a></span>
<p>And here's the subscriber:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">pathosub:&nbsp;Pathologic&nbsp;Subscriber&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">pathosub:&nbsp;Pathologic&nbsp;Subscriber&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Pathological subscriber<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Subscribes to one random topic and prints received messages</span></p>
<p>#include "czmq.h"</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">int</span> argc, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>argv <span style="white-space: pre-wrap;">[]</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>subscriber <span style="color:#666666">=</span> zsocket_new (context, ZMQ_SUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (argc <span style="color:#666666">==</span> <span style="color:#666666">2</span>)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zsocket_connect (subscriber, argv <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zsocket_connect (subscriber, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5556"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>srandom ((<span style="color:#B00040">unsigned</span>) time (<span style="color:#008000">NULL</span>));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> subscription <span style="white-space: pre-wrap;">[</span><span style="color:#666666">5</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>sprintf (subscription, <span style="color:#BA2121">"%03d"</span>, randof (<span style="color:#666666">1000</span>));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_set_subscribe (subscriber, subscription);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>topic <span style="color:#666666">=</span> zstr_recv (subscriber);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>topic)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>data <span style="color:#666666">=</span> zstr_recv (subscriber);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>assert (streq (topic, subscription));<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>puts (data);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (topic);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (data);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>context);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cs:pathosub" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/java:pathosub" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/py:pathosub" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rb:pathosub" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | Clojure | CL | Delphi | Erlang | F# | Felix | Go | Haskell | Haxe | Lua | Node.js | Objective-C | ooc | Perl | PHP | Q | Racket | Scala | Tcl</a></span>
<p>Try building and running these: first the subscriber, then the publisher. You'll see the subscriber reports getting "Save Roger" as you'd expect:</p>
<div class="code">
<pre><code>./pathosub &amp;
./pathopub</code>
</pre></div>
<p>It's when you run a second subscriber that you understand Roger's predicament. You have to leave it an awful long time before it reports getting any data. So, here's our last value cache. As I promised, it's a proxy that binds to two sockets and then handles messages on both:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">lvcache:&nbsp;Last&nbsp;Value&nbsp;Caching&nbsp;Proxy&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">lvcache:&nbsp;Last&nbsp;Value&nbsp;Caching&nbsp;Proxy&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Last value cache<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Uses XPUB subscription messages to re-send data</span></span></p>
<p><span style="color:#BC7A00">#include "czmq.h"</span></p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">zctx_t</span> <span style="color:#666666">*</span>context <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>frontend <span style="color:#666666">=</span> zsocket_new (context, ZMQ_SUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect (frontend, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5557"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>backend <span style="color:#666666">=</span> zsocket_new (context, ZMQ_XPUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (backend, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5558"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Subscribe to every single topic from publisher</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_set_subscribe (frontend, <span style="color:#BA2121">""</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Store last instance of each topic in a cache</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">zhash_t</span> <span style="color:#666666">*</span>cache <span style="color:#666666">=</span> zhash_new ();</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We route topic updates from frontend to backend, and</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>we handle subscriptions by sending whatever we cached,</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>if anything:</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">zmq_pollitem_t</span> items <span style="white-space: pre-wrap;">[]</span> <span style="color:#666666">=</span> {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>{ frontend, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> },<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>{ backend,<tt><span style="white-space: pre-wrap;">  </span></tt><span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> }<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (zmq_poll (items, <span style="color:#666666">2</span>, <span style="color:#666666">1000</span> <span style="color:#666666">*</span> ZMQ_POLL_MSEC) <span style="color:#666666">==</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span></p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Any new topic data we cache and then forward</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>topic <span style="color:#666666">=</span> zstr_recv (frontend);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>current <span style="color:#666666">=</span> zstr_recv (frontend);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>topic)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>previous <span style="color:#666666">=</span> zhash_lookup (cache, topic);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (previous) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zhash_delete (cache, topic);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>free (previous);<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zhash_insert (cache, topic, current);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zstr_sendm (backend, topic);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zstr_send (backend, current);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>free (topic);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>When we get a new subscription, we pull data from the cache:</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">zframe_t</span> <span style="color:#666666">*</span>frame <span style="color:#666666">=</span> zframe_recv (backend);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>frame)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Event is one byte 0=unsub or 1=sub, followed by topic</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>byte <span style="color:#666666">*</span>event <span style="color:#666666">=</span> zframe_data (frame);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (event <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span> <span style="color:#666666">==</span> <span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>topic <span style="color:#666666">=</span> zmalloc (zframe_size (frame));<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>memcpy (topic, event <span style="color:#666666">+</span> <span style="color:#666666">1</span>, zframe_size (frame) <span style="color:#666666">-</span> <span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>printf (<span style="color:#BA2121">"Sending cached topic %s</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, topic);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>previous <span style="color:#666666">=</span> zhash_lookup (cache, topic);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>if</strong></span> (previous) {<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>zstr_sendm (backend, topic);<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>zstr_send (backend, previous);<br>
<tt><span style="white-space: pre-wrap;">                </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">                </span></tt>free (topic);<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_destroy (<span style="color:#666666">&amp;</span>frame);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>context);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zhash_destroy (<span style="color:#666666">&amp;</span>cache);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cs:lvcache" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/java:lvcache" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/py:lvcache" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/rb:lvcache" target="_blank">Ruby</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | Clojure | CL | Delphi | Erlang | F# | Felix | Go | Haskell | Haxe | Lua | Node.js | Objective-C | ooc | Perl | PHP | Q | Racket | Scala | Tcl</a></span>
<p>Now, run the proxy, and then the publisher:</p>
<div class="code">
<pre><code>./lvcache &amp;
./pathopub tcp://localhost:5557</code>
</pre></div>
<p>And now run as many instances of the subscriber as you want to try, each time connecting to the proxy on port 5558:</p>
<div class="code">
<pre><code>./pathosub tcp://localhost:5558</code>
</pre></div>
<p>Each subscriber happily reports "Save Roger", and Gregor the Escaped Convict slinks back to his seat for dinner and a nice cup of hot milk, which is all he really wanted in the first place.</p>
<p>One note: by default, the XPUB socket does not report duplicate subscriptions, which is what you want when you're naively connecting an XPUB to an XSUB. Our example sneakily gets around this by using random topics so the chance of it not working is one in a million. In a real LVC proxy, you'll want to use the <tt>ZMQ_XPUB_VERBOSE</tt> option that we implement in <a href="http://zguide.zeromq.org/page:all#the-community">Chapter 6 - The ZeroMQ Community</a> as an exercise.</p>
<p><a name="Slow-Subscriber-Detection-Suicidal-Snail-Pattern"></a><a name="header-118"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc117"><span><a href="http://zguide.zeromq.org/page:all#Slow-Subscriber-Detection-Suicidal-Snail-Pattern">Slow Subscriber Detection (Suicidal Snail Pattern)</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-117">prev</a> <a href="http://zguide.zeromq.org/page:all#header-119">next</a></td>
</tr>
</tbody></table>
<p>A common problem you will hit when using the pub-sub pattern in real life is the slow subscriber. In an ideal world, we stream data at full speed from publishers to subscribers. In reality, subscriber applications are often written in interpreted languages, or just do a lot of work, or are just badly written, to the extent that they can't keep up with publishers.</p>
<p>How do we handle a slow subscriber? The ideal fix is to make the subscriber faster, but that might take work and time. Some of the classic strategies for handling a slow subscriber are:</p>
<ul>
<li><strong>Queue messages on the publisher</strong>. This is what Gmail does when I don't read my email for a couple of hours. But in high-volume messaging, pushing queues upstream has the thrilling but unprofitable result of making publishers run out of memory and crash—especially if there are lots of subscribers and it's not possible to flush to disk for performance reasons.</li>
</ul>
<ul>
<li><strong>Queue messages on the subscriber</strong>. This is much better, and it's what ZeroMQ does by default if the network can keep up with things. If anyone's going to run out of memory and crash, it'll be the subscriber rather than the publisher, which is fair. This is perfect for "peaky" streams where a subscriber can't keep up for a while, but can catch up when the stream slows down. However, it's no answer to a subscriber that's simply too slow in general.</li>
</ul>
<ul>
<li><strong>Stop queuing new messages after a while</strong>. This is what Gmail does when my mailbox overflows its precious gigabytes of space. New messages just get rejected or dropped. This is a great strategy from the perspective of the publisher, and it's what ZeroMQ does when the publisher sets a HWM. However, it still doesn't help us fix the slow subscriber. Now we just get gaps in our message stream.</li>
</ul>
<ul>
<li><strong>Punish slow subscribers with disconnect</strong>. This is what Hotmail (remember that?) did when I didn't log in for two weeks, which is why I was on my fifteenth Hotmail account when it hit me that there was perhaps a better way. It's a nice brutal strategy that forces subscribers to sit up and pay attention and would be ideal, but ZeroMQ doesn't do this, and there's no way to layer it on top because subscribers are invisible to publisher applications.</li>
</ul>
<p>None of these classic strategies fit, so we need to get creative. Rather than disconnect the publisher, let's convince the subscriber to kill itself. This is the Suicidal Snail pattern. When a subscriber detects that it's running too slowly (where "too slowly" is presumably a configured option that really means "so slowly that if you ever get here, shout really loudly because I need to know, so I can fix this!"), it croaks and dies.</p>
<p>How can a subscriber detect this? One way would be to sequence messages (number them in order) and use a HWM at the publisher. Now, if the subscriber detects a gap (i.e., the numbering isn't consecutive), it knows something is wrong. We then tune the HWM to the "croak and die if you hit this" level.</p>
<p>There are two problems with this solution. One, if we have many publishers, how do we sequence messages? The solution is to give each publisher a unique ID and add that to the sequencing. Second, if subscribers use <tt>ZMQ_SUBSCRIBE</tt> filters, they will get gaps by definition. Our precious sequencing will be for nothing.</p>
<p>Some use cases won't use filters, and sequencing will work for them. But a more general solution is that the publisher timestamps each message. When a subscriber gets a message, it checks the time, and if the difference is more than, say, one second, it does the "croak and die" thing, possibly firing off a squawk to some operator console first.</p>
<p>The Suicide Snail pattern works especially when subscribers have their own clients and service-level agreements and need to guarantee certain maximum latencies. Aborting a subscriber may not seem like a constructive way to guarantee a maximum latency, but it's the assertion model. Abort today, and the problem will be fixed. Allow late data to flow downstream, and the problem may cause wider damage and take longer to appear on the radar.</p>
<p>Here is a minimal example of a Suicidal Snail:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">suisnail:&nbsp;Suicidal&nbsp;Snail&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">suisnail:&nbsp;Suicidal&nbsp;Snail&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Suicidal Snail</span></p>
<p>#include "czmq.h"</p>
<p><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This is our subscriber. It connects to the publisher and subscribes<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>to everything. It sleeps for a short time between messages to<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>simulate doing too much work. If a message is more than one second<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>late, it croaks.</p>
<p>#define MAX_ALLOWED_DELAY<tt><span style="white-space: pre-wrap;">   </span></tt>1000<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>msecs</em></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<span style="color:#0000FF">subscriber</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>args, zctx_t <span style="color:#666666">*</span>ctx, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>pipe)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Subscribe to everything</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>subscriber <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_SUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_set_subscribe (subscriber, <span style="color:#BA2121">""</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect (subscriber, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5556"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Get and process messages</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>string <span style="color:#666666">=</span> zstr_recv (subscriber);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf(<span style="color:#BA2121">"%s</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, string);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int64_t</span> clock;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> terms <span style="color:#666666">=</span> sscanf (string, <span style="color:#BA2121">"%"</span> PRId64, <span style="color:#666666">&amp;</span>clock);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>assert (terms <span style="color:#666666">==</span> <span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (string);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Suicide snail logic</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (zclock_time () <span style="color:#666666">-</span> clock <span style="color:#666666">&gt;</span> MAX_ALLOWED_DELAY) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>fprintf (stderr, <span style="color:#BA2121">"E: subscriber cannot keep up, aborting</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Work for 1 msec plus some random additional time</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zclock_sleep (<span style="color:#666666">1</span> <span style="color:#666666">+</span> randof (<span style="color:#666666">2</span>));<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zstr_send (pipe, <span style="color:#BA2121">"gone and died"</span>);<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This is our publisher task. It publishes a time-stamped message to its<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>PUB socket every millisecond:</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<span style="color:#0000FF">publisher</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>args, zctx_t <span style="color:#666666">*</span>ctx, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>pipe)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Prepare publisher</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>publisher <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_PUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (publisher, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5556"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send current clock (msecs) to subscribers</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> string <span style="white-space: pre-wrap;">[</span><span style="color:#666666">20</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>sprintf (string, <span style="color:#BA2121">"%"</span> PRId64, zclock_time ());<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zstr_send (publisher, string);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>signal <span style="color:#666666">=</span> zstr_recv_nowait (pipe);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (signal) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>free (signal);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zclock_sleep (<span style="color:#666666">1</span>);<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>1msec wait</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The main task simply starts a client and a server, and then<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>waits for the client to signal that it has died:</span></span></p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>pubpipe <span style="color:#666666">=</span> zthread_fork (ctx, publisher, <span style="color:#008000">NULL</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>subpipe <span style="color:#666666">=</span> zthread_fork (ctx, subscriber, <span style="color:#008000">NULL</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>free (zstr_recv (subpipe));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zstr_send (pubpipe, <span style="color:#BA2121">"break"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zclock_sleep (<span style="color:#666666">100</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/cpp:suisnail" target="_blank">C++</a> | <a href="http://zguide.zeromq.org/cs:suisnail" target="_blank">C#</a> | <a href="http://zguide.zeromq.org/java:suisnail" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/lua:suisnail" target="_blank">Lua</a> | <a href="http://zguide.zeromq.org/php:suisnail" target="_blank">PHP</a> | <a href="http://zguide.zeromq.org/py:suisnail" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/tcl:suisnail" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | Clojure | CL | Delphi | Erlang | F# | Felix | Go | Haskell | Haxe | Node.js | Objective-C | ooc | Perl | Q | Racket | Ruby | Scala</a></span>
<p>Here are some things to note about the Suicidal Snail example:</p>
<ul>
<li>The message here consists simply of the current system clock as a number of milliseconds. In a realistic application, you'd have at least a message header with the timestamp and a message body with data.</li>
</ul>
<ul>
<li>The example has subscriber and publisher in a single process as two threads. In reality, they would be separate processes. Using threads is just convenient for the demonstration.</li>
</ul>
<p><a name="High-Speed-Subscribers-Black-Box-Pattern"></a><a name="header-119"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc118"><span><a href="http://zguide.zeromq.org/page:all#High-Speed-Subscribers-Black-Box-Pattern">High-Speed Subscribers (Black Box Pattern)</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-118">prev</a> <a href="http://zguide.zeromq.org/page:all#header-120">next</a></td>
</tr>
</tbody></table>
<p>Now lets look at one way to make our subscribers faster. A common use case for pub-sub is distributing large data streams like market data coming from stock exchanges. A typical setup would have a publisher connected to a stock exchange, taking price quotes, and sending them out to a number of subscribers. If there are a handful of subscribers, we could use TCP. If we have a larger number of subscribers, we'd probably use reliable multicast, i.e., PGM.</p>
<p><strong>Figure 56 - The Simple Black Box Pattern</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig56.png" alt="fig56.png" class="image"></div>
<p>Let's imagine our feed has an average of 100,000&nbsp;100-byte messages a second. That's a typical rate, after filtering market data we don't need to send on to subscribers. Now we decide to record a day's data (maybe 250&nbsp;GB in 8 hours), and then replay it to a simulation network, i.e., a small group of subscribers. While 100K messages a second is easy for a ZeroMQ application, we want to replay it <em>much faster</em>.</p>
<p>So we set up our architecture with a bunch of boxes—one for the publisher and one for each subscriber. These are well-specified boxes—eight cores, twelve for the publisher.</p>
<p>And as we pump data into our subscribers, we notice two things:</p>
<ol>
<li>When we do even the slightest amount of work with a message, it slows down our subscriber to the point where it can't catch up with the publisher again.</li>
</ol>
<ol>
<li>We're hitting a ceiling, at both publisher and subscriber, to around 6M messages a second, even after careful optimization and TCP tuning.</li>
</ol>
<p>The first thing we have to do is break our subscriber into a multithreaded design so that we can do work with messages in one set of threads, while reading messages in another. Typically, we don't want to process every message the same way. Rather, the subscriber will filter some messages, perhaps by prefix key. When a message matches some criteria, the subscriber will call a worker to deal with it. In ZeroMQ terms, this means sending the message to a worker thread.</p>
<p>So the subscriber looks something like a queue device. We could use various sockets to connect the subscriber and workers. If we assume one-way traffic and workers that are all identical, we can use PUSH and PULL and delegate all the routing work to ZeroMQ. This is the simplest and fastest approach.</p>
<p>The subscriber talks to the publisher over TCP or PGM. The subscriber talks to its workers, which are all in the same process, over <tt>inproc:<span style="white-space: pre-wrap;">//</span></tt>.</p>
<p><strong>Figure 57 - Mad Black Box Pattern</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig57.png" alt="fig57.png" class="image"></div>
<p>Now to break that ceiling. The subscriber thread hits 100% of CPU and because it is one thread, it cannot use more than one core. A single thread will always hit a ceiling, be it at 2M, 6M, or more messages per second. We want to split the work across multiple threads that can run in parallel.</p>
<p>The approach used by many high-performance products, which works here, is <em>sharding</em>. Using sharding, we split the work into parallel and independent streams, such as half of the topic keys in one stream, and half in another. We could use many streams, but performance won't scale unless we have free cores. So let's see how to shard into two streams.</p>
<p>With two streams, working at full speed, we would configure ZeroMQ as follows:</p>
<ul>
<li>Two I/O threads, rather than one.</li>
<li>Two network interfaces (NIC), one per subscriber.</li>
<li>Each I/O thread bound to a specific NIC.</li>
<li>Two subscriber threads, bound to specific cores.</li>
<li>Two SUB sockets, one per subscriber thread.</li>
<li>The remaining cores assigned to worker threads.</li>
<li>Worker threads connected to both subscriber PUSH sockets.</li>
</ul>
<p>Ideally, we want to match the number of fully-loaded threads in our architecture with the number of cores. When threads start to fight for cores and CPU cycles, the cost of adding more threads outweighs the benefits. There would be no benefit, for example, in creating more I/O threads.</p>
<p><a name="Reliable-Pub-Sub-Clone-Pattern"></a><a name="header-120"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc119"><span><a href="http://zguide.zeromq.org/page:all#Reliable-Pub-Sub-Clone-Pattern">Reliable Pub-Sub (Clone Pattern)</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-119">prev</a> <a href="http://zguide.zeromq.org/page:all#header-121">next</a></td>
</tr>
</tbody></table>
<p>As a larger worked example, we'll take the problem of making a reliable pub-sub architecture. We'll develop this in stages. The goal is to allow a set of applications to share some common state. Here are our technical challenges:</p>
<ul>
<li>We have a large set of client applications, say thousands or tens of thousands.</li>
<li>They will join and leave the network arbitrarily.</li>
<li>These applications must share a single eventually-consistent <em>state</em>.</li>
<li>Any application can update the state at any point in time.</li>
</ul>
<p>Let's say that updates are reasonably low-volume. We don't have real time goals. The whole state can fit into memory. Some plausible use cases are:</p>
<ul>
<li>A configuration that is shared by a group of cloud servers.</li>
<li>Some game state shared by a group of players.</li>
<li>Exchange rate data that is updated in real time and available to applications.</li>
</ul>
<p><a name="Centralized-Versus-Decentralized"></a><a name="header-121"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc120"><span><a href="http://zguide.zeromq.org/page:all#Centralized-Versus-Decentralized">Centralized Versus Decentralized</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-120">prev</a> <a href="http://zguide.zeromq.org/page:all#header-122">next</a></td>
</tr>
</tbody></table>
<p>A first decision we have to make is whether we work with a central server or not. It makes a big difference in the resulting design. The trade-offs are these:</p>
<ul>
<li>Conceptually, a central server is simpler to understand because networks are not naturally symmetrical. With a central server, we avoid all questions of discovery, bind versus connect, and so on.</li>
</ul>
<ul>
<li>Generally, a fully-distributed architecture is technically more challenging but ends up with simpler protocols. That is, each node must act as server and client in the right way, which is delicate. When done right, the results are simpler than using a central server. We saw this in the Freelance pattern in <a href="http://zguide.zeromq.org/page:all#reliable-request-reply">Chapter 4 - Reliable Request-Reply Patterns</a>.</li>
</ul>
<ul>
<li>A central server will become a bottleneck in high-volume use cases. If handling scale in the order of millions of messages a second is required, we should aim for decentralization right away.</li>
</ul>
<ul>
<li>Ironically, a centralized architecture will scale to more nodes more easily than a decentralized one. That is, it's easier to connect 10,000 nodes to one server than to each other.</li>
</ul>
<p>So, for the Clone pattern we'll work with a <em>server</em> that publishes state updates and a set of <em>clients</em> that represent applications.</p>
<p><a name="Representing-State-as-Key-Value-Pairs"></a><a name="header-122"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc121"><span><a href="http://zguide.zeromq.org/page:all#Representing-State-as-Key-Value-Pairs">Representing State as Key-Value Pairs</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-121">prev</a> <a href="http://zguide.zeromq.org/page:all#header-123">next</a></td>
</tr>
</tbody></table>
<p>We'll develop Clone in stages, solving one problem at a time. First, let's look at how to update a shared state across a set of clients. We need to decide how to represent our state, as well as the updates. The simplest plausible format is a key-value store, where one key-value pair represents an atomic unit of change in the shared state.</p>
<p>We have a simple pub-sub example in <a href="http://zguide.zeromq.org/page:all#basics">Chapter 1 - Basics</a>, the weather server and client. Let's change the server to send key-value pairs, and the client to store these in a hash table. This lets us send updates from one server to a set of clients using the classic pub-sub model.</p>
<p>An update is either a new key-value pair, a modified value for an existing key, or a deleted key. We can assume for now that the whole store fits in memory and that applications access it by key, such as by using a hash table or dictionary. For larger stores and some kind of persistence we'd probably store the state in a database, but that's not relevant here.</p>
<p>This is the server:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">clonesrv1:&nbsp;Clone&nbsp;server,&nbsp;Model&nbsp;One&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">clonesrv1:&nbsp;Clone&nbsp;server,&nbsp;Model&nbsp;One&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Clone server Model One</span></p>
<p>#include "kvsimple.c"</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Prepare our context and publisher socket</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>publisher <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_PUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (publisher, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5556"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zclock_sleep (<span style="color:#666666">200</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zhash_t <span style="color:#666666">*</span>kvmap <span style="color:#666666">=</span> zhash_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int64_t</span> sequence <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>srandom ((<span style="color:#B00040">unsigned</span>) time (<span style="color:#008000">NULL</span>));</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">!</span>zctx_interrupted) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Distribute as key-value message</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_t <span style="color:#666666">*</span>kvmsg <span style="color:#666666">=</span> kvmsg_new (<span style="color:#666666">++</span>sequence);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_fmt_key<tt><span style="white-space: pre-wrap;">  </span></tt>(kvmsg, <span style="color:#BA2121">"%d"</span>, randof (<span style="color:#666666">10000</span>));<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_fmt_body (kvmsg, <span style="color:#BA2121">"%d"</span>, randof (<span style="color:#666666">1000000</span>));<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_send<tt><span style="white-space: pre-wrap;">     </span></tt>(kvmsg, publisher);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_store<tt><span style="white-space: pre-wrap;">   </span></tt>(<span style="color:#666666">&amp;</span>kvmsg, kvmap);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">" Interrupted</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">%d messages out</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, (<span style="color:#B00040">int</span>) sequence);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zhash_destroy (<span style="color:#666666">&amp;</span>kvmap);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/java:clonesrv1" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/py:clonesrv1" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/tcl:clonesrv1" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | C# | Clojure | CL | Delphi | Erlang | F# | Felix | Go | Haskell | Haxe | Lua | Node.js | Objective-C | ooc | Perl | PHP | Q | Racket | Ruby | Scala</a></span>
<p>And here is the client:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">clonecli1:&nbsp;Clone&nbsp;client,&nbsp;Model&nbsp;One&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">clonecli1:&nbsp;Clone&nbsp;client,&nbsp;Model&nbsp;One&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Clone client Model One</span></p>
<p>#include "kvsimple.c"</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Prepare our context and updates socket</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>updates <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_SUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_set_subscribe (updates, <span style="color:#BA2121">""</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect (updates, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5556"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zhash_t <span style="color:#666666">*</span>kvmap <span style="color:#666666">=</span> zhash_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int64_t</span> sequence <span style="color:#666666">=</span> <span style="color:#666666">0</span>;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_t <span style="color:#666666">*</span>kvmsg <span style="color:#666666">=</span> kvmsg_recv (updates);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>kvmsg)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_store (<span style="color:#666666">&amp;</span>kvmsg, kvmap);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>sequence<span style="color:#666666">++</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">" Interrupted</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">%d messages in</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, (<span style="color:#B00040">int</span>) sequence);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zhash_destroy (<span style="color:#666666">&amp;</span>kvmap);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/java:clonecli1" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/py:clonecli1" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/tcl:clonecli1" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | C# | Clojure | CL | Delphi | Erlang | F# | Felix | Go | Haskell | Haxe | Lua | Node.js | Objective-C | ooc | Perl | PHP | Q | Racket | Ruby | Scala</a></span>
<p><strong>Figure 58 - Publishing State Updates</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig58.png" alt="fig58.png" class="image"></div>
<p>Here are some things to note about this first model:</p>
<ul>
<li>All the hard work is done in a <tt>kvmsg</tt> class. This class works with key-value message objects, which are multipart ZeroMQ messages structured as three frames: a key (a ZeroMQ string), a sequence number (64-bit value, in network byte order), and a binary body (holds everything else).</li>
</ul>
<ul>
<li>The server generates messages with a randomized 4-digit key, which lets us simulate a large but not enormous hash table (10K entries).</li>
</ul>
<ul>
<li>We don't implement deletions in this version: all messages are inserts or updates.</li>
</ul>
<ul>
<li>The server does a 200 millisecond pause after binding its socket. This is to prevent <em>slow joiner syndrome</em>, where the subscriber loses messages as it connects to the server's socket. We'll remove that in later versions of the Clone code.</li>
</ul>
<ul>
<li>We'll use the terms <em>publisher</em> and <em>subscriber</em> in the code to refer to sockets. This will help later when we have multiple sockets doing different things.</li>
</ul>
<p>Here is the <tt>kvmsg</tt> class, in the simplest form that works for now:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">kvsimple:&nbsp;Key-value&nbsp;message&nbsp;class&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">kvsimple:&nbsp;Key-value&nbsp;message&nbsp;class&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>kvsimple class - key-value message class for example applications</span></p>
<p>#include "kvsimple.h"<br>
#include "zlist.h"</p>
<p><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Keys are short strings<br>
#define KVMSG_KEY_MAX<tt><span style="white-space: pre-wrap;">   </span></tt>255</p>
<p><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Message is formatted on wire as 3 frames:<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>frame 0: key (0MQ string)<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>frame 1: sequence (8 bytes, network order)<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>frame 2: body (blob)<br>
#define FRAME_KEY<tt><span style="white-space: pre-wrap;">       </span></tt>0<br>
#define FRAME_SEQ<tt><span style="white-space: pre-wrap;">       </span></tt>1<br>
#define FRAME_BODY<tt><span style="white-space: pre-wrap;">      </span></tt>2<br>
#define KVMSG_FRAMES<tt><span style="white-space: pre-wrap;">    </span></tt>3</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The kvmsg class holds a single key-value message consisting of a<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>list of 0 or more frames:</span></span></p>
<p><span style="color:#008000"><strong>struct</strong></span> _kvmsg {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Presence indicators for each frame</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> present <span style="white-space: pre-wrap;">[</span>KVMSG_FRAMES<span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Corresponding 0MQ message frames, if any</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_msg_t frame <span style="white-space: pre-wrap;">[</span>KVMSG_FRAMES<span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Key, copied into safe C string</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> key <span style="white-space: pre-wrap;">[</span>KVMSG_KEY_MAX <span style="color:#666666">+</span> <span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>;<br>
};</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Here are the constructor and destructor for the class:</em></span></p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Constructor, takes a sequence number for the new kvmsg instance:</em></span><br>
kvmsg_t <span style="color:#666666">*</span><br>
<span style="color:#0000FF">kvmsg_new</span> (<span style="color:#B00040">int64_t</span> sequence)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_t<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#666666">*</span>self;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>self <span style="color:#666666">=</span> (kvmsg_t <span style="color:#666666">*</span>) zmalloc (<span style="color:#008000"><strong>sizeof</strong></span> (kvmsg_t));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_set_sequence (self, sequence);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> self;<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>zhash_free_fn callback helper that does the low level destruction:</em></span><br>
<span style="color:#B00040">void</span><br>
<span style="color:#0000FF">kvmsg_free</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>ptr)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (ptr) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> (kvmsg_t <span style="color:#666666">*</span>) ptr;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Destroy message frames if any</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> frame_nbr;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>for</strong></span> (frame_nbr <span style="color:#666666">=</span> <span style="color:#666666">0</span>; frame_nbr <span style="color:#666666">&lt;</span> KVMSG_FRAMES; frame_nbr<span style="color:#666666">++</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>frame_nbr<span style="white-space: pre-wrap;">]</span>)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmq_msg_close (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>frame <span style="white-space: pre-wrap;">[</span>frame_nbr<span style="white-space: pre-wrap;">]</span>);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Free object itself</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (self);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Destructor</em></span><br>
<span style="color:#B00040">void</span><br>
<span style="color:#0000FF">kvmsg_destroy</span> (kvmsg_t <span style="color:#666666"><span style="white-space: pre-wrap;">**</span></span>self_p)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self_p);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">*</span>self_p) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_free (<span style="color:#666666">*</span>self_p);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#666666">*</span>self_p <span style="color:#666666">=</span> <span style="color:#008000">NULL</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This method reads a key-value message from socket, and returns a new<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt><tt>kvmsg</tt> instance:</span></span></p>
<p>kvmsg_t <span style="color:#666666">*</span><br>
<span style="color:#0000FF">kvmsg_recv</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>socket)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (socket);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> kvmsg_new (<span style="color:#666666">0</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Read all frames off the wire, reject if bogus</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> frame_nbr;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (frame_nbr <span style="color:#666666">=</span> <span style="color:#666666">0</span>; frame_nbr <span style="color:#666666">&lt;</span> KVMSG_FRAMES; frame_nbr<span style="color:#666666">++</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>frame_nbr<span style="white-space: pre-wrap;">]</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmq_msg_close (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>frame <span style="white-space: pre-wrap;">[</span>frame_nbr<span style="white-space: pre-wrap;">]</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_msg_init (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>frame <span style="white-space: pre-wrap;">[</span>frame_nbr<span style="white-space: pre-wrap;">]</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>self<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>frame_nbr<span style="white-space: pre-wrap;">]</span> <span style="color:#666666">=</span> <span style="color:#666666">1</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (zmq_msg_recv (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>frame <span style="white-space: pre-wrap;">[</span>frame_nbr<span style="white-space: pre-wrap;">]</span>, socket, <span style="color:#666666">0</span>) <span style="color:#666666">==</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_destroy (<span style="color:#666666">&amp;</span>self);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Verify multipart framing</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> rcvmore <span style="color:#666666">=</span> (frame_nbr <span style="color:#666666">&lt;</span> KVMSG_FRAMES <span style="color:#666666">-</span> <span style="color:#666666">1</span>)<span style="color:#666666">?</span> <span style="color:#666666">1</span><span style="color:#666666">:</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (zsocket_rcvmore (socket) <span style="color:#666666">!=</span> rcvmore) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_destroy (<span style="color:#666666">&amp;</span>self);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> self;<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This method sends a multiframe key-value message to a socket:</em></span></p>
<p><span style="color:#B00040">void</span><br>
<span style="color:#0000FF">kvmsg_send</span> (kvmsg_t <span style="color:#666666">*</span>self, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>socket)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (socket);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> frame_nbr;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (frame_nbr <span style="color:#666666">=</span> <span style="color:#666666">0</span>; frame_nbr <span style="color:#666666">&lt;</span> KVMSG_FRAMES; frame_nbr<span style="color:#666666">++</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_msg_t copy;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_msg_init (<span style="color:#666666">&amp;</span>copy);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>frame_nbr<span style="white-space: pre-wrap;">]</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmq_msg_copy (<span style="color:#666666">&amp;</span>copy, <span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>frame <span style="white-space: pre-wrap;">[</span>frame_nbr<span style="white-space: pre-wrap;">]</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_msg_send (<span style="color:#666666">&amp;</span>copy, socket,<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>(frame_nbr <span style="color:#666666">&lt;</span> KVMSG_FRAMES <span style="color:#666666">-</span> <span style="color:#666666">1</span>)<span style="color:#666666">?</span> ZMQ_SNDMORE<span style="color:#666666">:</span> <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_msg_close (<span style="color:#666666">&amp;</span>copy);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>These methods let the caller get and set the message key, as a<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>fixed string and as a printf formatted string:</span></span></p>
<p><span style="color:#B00040">char</span> <span style="color:#666666">*</span><br>
<span style="color:#0000FF">kvmsg_key</span> (kvmsg_t <span style="color:#666666">*</span>self)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>FRAME_KEY<span style="white-space: pre-wrap;">]</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!*</span>self<span style="color:#666666">-&gt;</span>key) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">size_t</span> size <span style="color:#666666">=</span> zmq_msg_size (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>frame <span style="white-space: pre-wrap;">[</span>FRAME_KEY<span style="white-space: pre-wrap;">]</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (size <span style="color:#666666">&gt;</span> KVMSG_KEY_MAX)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>size <span style="color:#666666">=</span> KVMSG_KEY_MAX;<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>memcpy (self<span style="color:#666666">-&gt;</span>key,<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmq_msg_data (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>frame <span style="white-space: pre-wrap;">[</span>FRAME_KEY<span style="white-space: pre-wrap;">]</span>), size);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>self<span style="color:#666666">-&gt;</span>key <span style="white-space: pre-wrap;">[</span>size<span style="white-space: pre-wrap;">]</span> <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>return</strong></span> self<span style="color:#666666">-&gt;</span>key;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#008000">NULL</span>;<br>
}</p>
<p><span style="color:#B00040">void</span><br>
<span style="color:#0000FF">kvmsg_set_key</span> (kvmsg_t <span style="color:#666666">*</span>self, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>key)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_msg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> <span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>frame <span style="white-space: pre-wrap;">[</span>FRAME_KEY<span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>FRAME_KEY<span style="white-space: pre-wrap;">]</span>)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_msg_close (msg);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_msg_init_size (msg, strlen (key));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>memcpy (zmq_msg_data (msg), key, strlen (key));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>FRAME_KEY<span style="white-space: pre-wrap;">]</span> <span style="color:#666666">=</span> <span style="color:#666666">1</span>;<br>
}</p>
<p><span style="color:#B00040">void</span><br>
<span style="color:#0000FF">kvmsg_fmt_key</span> (kvmsg_t <span style="color:#666666">*</span>self, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>format, …)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> value <span style="white-space: pre-wrap;">[</span>KVMSG_KEY_MAX <span style="color:#666666">+</span> <span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">va_list</span> args;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>va_start (args, format);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>vsnprintf (value, KVMSG_KEY_MAX, format, args);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>va_end (args);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_set_key (self, value);<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>These two methods let the caller get and set the message sequence number:</em></span></p>
<p><span style="color:#B00040">int64_t</span><br>
<span style="color:#0000FF">kvmsg_sequence</span> (kvmsg_t <span style="color:#666666">*</span>self)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>FRAME_SEQ<span style="white-space: pre-wrap;">]</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>assert (zmq_msg_size (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>frame <span style="white-space: pre-wrap;">[</span>FRAME_SEQ<span style="white-space: pre-wrap;">]</span>) <span style="color:#666666">==</span> <span style="color:#666666">8</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>byte <span style="color:#666666">*</span>source <span style="color:#666666">=</span> zmq_msg_data (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>frame <span style="white-space: pre-wrap;">[</span>FRAME_SEQ<span style="white-space: pre-wrap;">]</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int64_t</span> sequence <span style="color:#666666">=</span> ((<span style="color:#B00040">int64_t</span>) (source <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>) <span style="color:#666666"><span style="white-space: pre-wrap;">&lt;&lt;</span></span> <span style="color:#666666">56</span>)<br>
<tt><span style="white-space: pre-wrap;">                         </span></tt><span style="color:#666666">+</span> ((<span style="color:#B00040">int64_t</span>) (source <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>) <span style="color:#666666"><span style="white-space: pre-wrap;">&lt;&lt;</span></span> <span style="color:#666666">48</span>)<br>
<tt><span style="white-space: pre-wrap;">                         </span></tt><span style="color:#666666">+</span> ((<span style="color:#B00040">int64_t</span>) (source <span style="white-space: pre-wrap;">[</span><span style="color:#666666">2</span><span style="white-space: pre-wrap;">]</span>) <span style="color:#666666"><span style="white-space: pre-wrap;">&lt;&lt;</span></span> <span style="color:#666666">40</span>)<br>
<tt><span style="white-space: pre-wrap;">                         </span></tt><span style="color:#666666">+</span> ((<span style="color:#B00040">int64_t</span>) (source <span style="white-space: pre-wrap;">[</span><span style="color:#666666">3</span><span style="white-space: pre-wrap;">]</span>) <span style="color:#666666"><span style="white-space: pre-wrap;">&lt;&lt;</span></span> <span style="color:#666666">32</span>)<br>
<tt><span style="white-space: pre-wrap;">                         </span></tt><span style="color:#666666">+</span> ((<span style="color:#B00040">int64_t</span>) (source <span style="white-space: pre-wrap;">[</span><span style="color:#666666">4</span><span style="white-space: pre-wrap;">]</span>) <span style="color:#666666"><span style="white-space: pre-wrap;">&lt;&lt;</span></span> <span style="color:#666666">24</span>)<br>
<tt><span style="white-space: pre-wrap;">                         </span></tt><span style="color:#666666">+</span> ((<span style="color:#B00040">int64_t</span>) (source <span style="white-space: pre-wrap;">[</span><span style="color:#666666">5</span><span style="white-space: pre-wrap;">]</span>) <span style="color:#666666"><span style="white-space: pre-wrap;">&lt;&lt;</span></span> <span style="color:#666666">16</span>)<br>
<tt><span style="white-space: pre-wrap;">                         </span></tt><span style="color:#666666">+</span> ((<span style="color:#B00040">int64_t</span>) (source <span style="white-space: pre-wrap;">[</span><span style="color:#666666">6</span><span style="white-space: pre-wrap;">]</span>) <span style="color:#666666"><span style="white-space: pre-wrap;">&lt;&lt;</span></span> <span style="color:#666666">8</span>)<br>
<tt><span style="white-space: pre-wrap;">                         </span></tt><span style="color:#666666">+</span><tt><span style="white-space: pre-wrap;">  </span></tt>(<span style="color:#B00040">int64_t</span>) (source <span style="white-space: pre-wrap;">[</span><span style="color:#666666">7</span><span style="white-space: pre-wrap;">]</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>return</strong></span> sequence;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
<p><span style="color:#B00040">void</span><br>
<span style="color:#0000FF">kvmsg_set_sequence</span> (kvmsg_t <span style="color:#666666">*</span>self, <span style="color:#B00040">int64_t</span> sequence)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_msg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> <span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>frame <span style="white-space: pre-wrap;">[</span>FRAME_SEQ<span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>FRAME_SEQ<span style="white-space: pre-wrap;">]</span>)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_msg_close (msg);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_msg_init_size (msg, <span style="color:#666666">8</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>byte <span style="color:#666666">*</span>source <span style="color:#666666">=</span> zmq_msg_data (msg);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>source <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span> <span style="color:#666666">=</span> (byte) ((sequence <span style="color:#666666"><span style="white-space: pre-wrap;">&gt;&gt;</span></span> <span style="color:#666666">56</span>) <span style="color:#666666">&amp;</span> <span style="color:#666666">255</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>source <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span> <span style="color:#666666">=</span> (byte) ((sequence <span style="color:#666666"><span style="white-space: pre-wrap;">&gt;&gt;</span></span> <span style="color:#666666">48</span>) <span style="color:#666666">&amp;</span> <span style="color:#666666">255</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>source <span style="white-space: pre-wrap;">[</span><span style="color:#666666">2</span><span style="white-space: pre-wrap;">]</span> <span style="color:#666666">=</span> (byte) ((sequence <span style="color:#666666"><span style="white-space: pre-wrap;">&gt;&gt;</span></span> <span style="color:#666666">40</span>) <span style="color:#666666">&amp;</span> <span style="color:#666666">255</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>source <span style="white-space: pre-wrap;">[</span><span style="color:#666666">3</span><span style="white-space: pre-wrap;">]</span> <span style="color:#666666">=</span> (byte) ((sequence <span style="color:#666666"><span style="white-space: pre-wrap;">&gt;&gt;</span></span> <span style="color:#666666">32</span>) <span style="color:#666666">&amp;</span> <span style="color:#666666">255</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>source <span style="white-space: pre-wrap;">[</span><span style="color:#666666">4</span><span style="white-space: pre-wrap;">]</span> <span style="color:#666666">=</span> (byte) ((sequence <span style="color:#666666"><span style="white-space: pre-wrap;">&gt;&gt;</span></span> <span style="color:#666666">24</span>) <span style="color:#666666">&amp;</span> <span style="color:#666666">255</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>source <span style="white-space: pre-wrap;">[</span><span style="color:#666666">5</span><span style="white-space: pre-wrap;">]</span> <span style="color:#666666">=</span> (byte) ((sequence <span style="color:#666666"><span style="white-space: pre-wrap;">&gt;&gt;</span></span> <span style="color:#666666">16</span>) <span style="color:#666666">&amp;</span> <span style="color:#666666">255</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>source <span style="white-space: pre-wrap;">[</span><span style="color:#666666">6</span><span style="white-space: pre-wrap;">]</span> <span style="color:#666666">=</span> (byte) ((sequence <span style="color:#666666"><span style="white-space: pre-wrap;">&gt;&gt;</span></span> <span style="color:#666666">8</span>)<tt><span style="white-space: pre-wrap;">  </span></tt><span style="color:#666666">&amp;</span> <span style="color:#666666">255</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>source <span style="white-space: pre-wrap;">[</span><span style="color:#666666">7</span><span style="white-space: pre-wrap;">]</span> <span style="color:#666666">=</span> (byte) ((sequence)<tt><span style="white-space: pre-wrap;">       </span></tt><span style="color:#666666">&amp;</span> <span style="color:#666666">255</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>FRAME_SEQ<span style="white-space: pre-wrap;">]</span> <span style="color:#666666">=</span> <span style="color:#666666">1</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>These methods let the caller get and set the message body as a<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>fixed string and as a printf formatted string:</span></span></p>
<p>byte <span style="color:#666666">*</span><br>
<span style="color:#0000FF">kvmsg_body</span> (kvmsg_t <span style="color:#666666">*</span>self)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>FRAME_BODY<span style="white-space: pre-wrap;">]</span>)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>return</strong></span> (byte <span style="color:#666666">*</span>) zmq_msg_data (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>frame <span style="white-space: pre-wrap;">[</span>FRAME_BODY<span style="white-space: pre-wrap;">]</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#008000">NULL</span>;<br>
}</p>
<p><span style="color:#B00040">void</span><br>
<span style="color:#0000FF">kvmsg_set_body</span> (kvmsg_t <span style="color:#666666">*</span>self, byte <span style="color:#666666">*</span>body, <span style="color:#B00040">size_t</span> size)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_msg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> <span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>frame <span style="white-space: pre-wrap;">[</span>FRAME_BODY<span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>FRAME_BODY<span style="white-space: pre-wrap;">]</span>)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_msg_close (msg);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>FRAME_BODY<span style="white-space: pre-wrap;">]</span> <span style="color:#666666">=</span> <span style="color:#666666">1</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_msg_init_size (msg, size);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>memcpy (zmq_msg_data (msg), body, size);<br>
}</p>
<p><span style="color:#B00040">void</span><br>
<span style="color:#0000FF">kvmsg_fmt_body</span> (kvmsg_t <span style="color:#666666">*</span>self, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>format, …)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> value <span style="white-space: pre-wrap;">[</span><span style="color:#666666">255</span> <span style="color:#666666">+</span> <span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">va_list</span> args;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>va_start (args, format);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>vsnprintf (value, <span style="color:#666666">255</span>, format, args);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>va_end (args);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_set_body (self, (byte <span style="color:#666666">*</span>) value, strlen (value));<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This method returns the body size of the most recently read message,<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>if any exists:</span></span></p>
<p><span style="color:#B00040">size_t</span><br>
<span style="color:#0000FF">kvmsg_size</span> (kvmsg_t <span style="color:#666666">*</span>self)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>FRAME_BODY<span style="white-space: pre-wrap;">]</span>)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>return</strong></span> zmq_msg_size (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>frame <span style="white-space: pre-wrap;">[</span>FRAME_BODY<span style="white-space: pre-wrap;">]</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This method stores the key-value message into a hash map, unless<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>the key and value are both null. It nullifies the <tt>kvmsg</tt> reference<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>so that the object is owned by the hash map, not the caller:</span></span></p>
<p><span style="color:#B00040">void</span><br>
<span style="color:#0000FF">kvmsg_store</span> (kvmsg_t <span style="color:#666666"><span style="white-space: pre-wrap;">**</span></span>self_p, zhash_t <span style="color:#666666">*</span>hash)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self_p);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">*</span>self_p) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> <span style="color:#666666">*</span>self_p;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>FRAME_KEY<span style="white-space: pre-wrap;">]</span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#666666">&amp;&amp;</span><tt><span style="white-space: pre-wrap;">  </span></tt>self<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>FRAME_BODY<span style="white-space: pre-wrap;">]</span>) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zhash_update (hash, kvmsg_key (self), self);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zhash_freefn (hash, kvmsg_key (self), kvmsg_free);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#666666">*</span>self_p <span style="color:#666666">=</span> <span style="color:#008000">NULL</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This method prints the key-value message to stderr for<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>debugging and tracing:</span></span></p>
<p><span style="color:#B00040">void</span><br>
<span style="color:#0000FF">kvmsg_dump</span> (kvmsg_t <span style="color:#666666">*</span>self)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>self) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>fprintf (stderr, <span style="color:#BA2121">"NULL"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>return</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">size_t</span> size <span style="color:#666666">=</span> kvmsg_size (self);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>byte<tt><span style="white-space: pre-wrap;">  </span></tt><span style="color:#666666">*</span>body <span style="color:#666666">=</span> kvmsg_body (self);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>fprintf (stderr, <span style="color:#BA2121">"<span style="white-space: pre-wrap;">[</span>seq:%"</span> PRId64 <span style="color:#BA2121">"<span style="white-space: pre-wrap;">]</span>"</span>, kvmsg_sequence (self));<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>fprintf (stderr, <span style="color:#BA2121">"<span style="white-space: pre-wrap;">[</span>key:%s<span style="white-space: pre-wrap;">]</span>"</span>, kvmsg_key (self));<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>fprintf (stderr, <span style="color:#BA2121">"<span style="white-space: pre-wrap;">[</span>size:%zd<span style="white-space: pre-wrap;">]</span> "</span>, size);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> char_nbr;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>for</strong></span> (char_nbr <span style="color:#666666">=</span> <span style="color:#666666">0</span>; char_nbr <span style="color:#666666">&lt;</span> size; char_nbr<span style="color:#666666">++</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>fprintf (stderr, <span style="color:#BA2121">"%02X"</span>, body <span style="white-space: pre-wrap;">[</span>char_nbr<span style="white-space: pre-wrap;">]</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>fprintf (stderr, <span style="color:#BA2121">"</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>fprintf (stderr, <span style="color:#BA2121">"NULL message</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>It's good practice to have a self-test method that tests the class; this<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>also shows how it's used in applications:</span></span></p>
<p><span style="color:#B00040">int</span><br>
<span style="color:#0000FF">kvmsg_test</span> (<span style="color:#B00040">int</span> verbose)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_t<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#666666">*</span>kvmsg;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">" * kvmsg: "</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Prepare our context and sockets</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>output <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_DEALER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> rc <span style="color:#666666">=</span> zmq_bind (output, <span style="color:#BA2121">"ipc:<span style="white-space: pre-wrap;">//</span>kvmsg_selftest.ipc"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (rc <span style="color:#666666">==</span> <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>input <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_DEALER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>rc <span style="color:#666666">=</span> zmq_connect (input, <span style="color:#BA2121">"ipc:<span style="white-space: pre-wrap;">//</span>kvmsg_selftest.ipc"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (rc <span style="color:#666666">==</span> <span style="color:#666666">0</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zhash_t <span style="color:#666666">*</span>kvmap <span style="color:#666666">=</span> zhash_new ();</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Test send and receive of simple message</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg <span style="color:#666666">=</span> kvmsg_new (<span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_set_key<tt><span style="white-space: pre-wrap;">  </span></tt>(kvmsg, <span style="color:#BA2121">"key"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_set_body (kvmsg, (byte <span style="color:#666666">*</span>) <span style="color:#BA2121">"body"</span>, <span style="color:#666666">4</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (verbose)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_dump (kvmsg);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_send (kvmsg, output);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_store (<span style="color:#666666">&amp;</span>kvmsg, kvmap);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg <span style="color:#666666">=</span> kvmsg_recv (input);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (verbose)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_dump (kvmsg);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (streq (kvmsg_key (kvmsg), <span style="color:#BA2121">"key"</span>));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_store (<span style="color:#666666">&amp;</span>kvmsg, kvmap);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Shutdown and destroy all objects</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zhash_destroy (<span style="color:#666666">&amp;</span>kvmap);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"OK</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/java:kvsimple" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/py:kvsimple" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/tcl:kvsimple" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | C# | Clojure | CL | Delphi | Erlang | F# | Felix | Go | Haskell | Haxe | Lua | Node.js | Objective-C | ooc | Perl | PHP | Q | Racket | Ruby | Scala</a></span>
<p>Later, we'll make a more sophisticated <tt>kvmsg</tt> class that will work in real applications.</p>
<p>Both the server and client maintain hash tables, but this first model only works properly if we start all clients before the server and the clients never crash. That's very artificial.</p>
<p><a name="Getting-an-Out-of-Band-Snapshot"></a><a name="header-123"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc122"><span><a href="http://zguide.zeromq.org/page:all#Getting-an-Out-of-Band-Snapshot">Getting an Out-of-Band Snapshot</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-122">prev</a> <a href="http://zguide.zeromq.org/page:all#header-124">next</a></td>
</tr>
</tbody></table>
<p>So now we have our second problem: how to deal with late-joining clients or clients that crash and then restart.</p>
<p>In order to allow a late (or recovering) client to catch up with a server, it has to get a snapshot of the server's state. Just as we've reduced "message" to mean "a sequenced key-value pair", we can reduce "state" to mean "a hash table". To get the server state, a client opens a DEALER socket and asks for it explicitly.</p>
<p>To make this work, we have to solve a problem of timing. Getting a state snapshot will take a certain time, possibly fairly long if the snapshot is large. We need to correctly apply updates to the snapshot. But the server won't know when to start sending us updates. One way would be to start subscribing, get a first update, and then ask for "state for update N". This would require the server storing one snapshot for each update, which isn't practical.</p>
<p><strong>Figure 59 - State Replication</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig59.png" alt="fig59.png" class="image"></div>
<p>So we will do the synchronization in the client, as follows:</p>
<ul>
<li>The client first subscribes to updates and then makes a state request. This guarantees that the state is going to be newer than the oldest update it has.</li>
</ul>
<ul>
<li>The client waits for the server to reply with state, and meanwhile queues all updates. It does this simply by not reading them: ZeroMQ keeps them queued on the socket queue.</li>
</ul>
<ul>
<li>When the client receives its state update, it begins once again to read updates. However, it discards any updates that are older than the state update. So if the state update includes updates up to 200, the client will discard updates up to 201.</li>
</ul>
<ul>
<li>The client then applies updates to its own state snapshot.</li>
</ul>
<p>It's a simple model that exploits ZeroMQ's own internal queues. Here's the server:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">clonesrv2:&nbsp;Clone&nbsp;server,&nbsp;Model&nbsp;Two&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">clonesrv2:&nbsp;Clone&nbsp;server,&nbsp;Model&nbsp;Two&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Clone server - Model Two</span></p>
<p><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Lets us build this source without creating a library<br>
#include "kvsimple.c"</p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">int</span> s_send_single (<span style="color:#008000"><strong>const</strong></span> <span style="color:#B00040">char</span> <span style="color:#666666">*</span>key, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>data, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>args);<br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span> state_manager (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>args, zctx_t <span style="color:#666666">*</span>ctx, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>pipe);</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Prepare our context and sockets</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>publisher <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_PUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (publisher, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5557"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int64_t</span> sequence <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>srandom ((<span style="color:#B00040">unsigned</span>) time (<span style="color:#008000">NULL</span>));</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Start state manager and wait for synchronization signal</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>updates <span style="color:#666666">=</span> zthread_fork (ctx, state_manager, <span style="color:#008000">NULL</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>free (zstr_recv (updates));</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">!</span>zctx_interrupted) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Distribute as key-value message</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_t <span style="color:#666666">*</span>kvmsg <span style="color:#666666">=</span> kvmsg_new (<span style="color:#666666">++</span>sequence);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_fmt_key<tt><span style="white-space: pre-wrap;">  </span></tt>(kvmsg, <span style="color:#BA2121">"%d"</span>, randof (<span style="color:#666666">10000</span>));<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_fmt_body (kvmsg, <span style="color:#BA2121">"%d"</span>, randof (<span style="color:#666666">1000000</span>));<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_send<tt><span style="white-space: pre-wrap;">     </span></tt>(kvmsg, publisher);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_send<tt><span style="white-space: pre-wrap;">     </span></tt>(kvmsg, updates);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_destroy (<span style="color:#666666">&amp;</span>kvmsg);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">" Interrupted</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">%d messages out</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, (<span style="color:#B00040">int</span>) sequence);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Routing information for a key-value snapshot</em></span><br>
<span style="color:#008000"><strong>typedef</strong></span> <span style="color:#008000"><strong>struct</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>socket;<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>ROUTER socket to send to</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zframe_t <span style="color:#666666">*</span>identity;<tt><span style="white-space: pre-wrap;">     </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Identity of peer who requested state</em></span><br>
} kvroute_t;</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send one state snapshot key-value pair to a socket<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Hash item data is our kvmsg object, ready to send</span></span><br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">int</span><br>
<span style="color:#0000FF">s_send_single</span> (<span style="color:#008000"><strong>const</strong></span> <span style="color:#B00040">char</span> <span style="color:#666666">*</span>key, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>data, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>args)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvroute_t <span style="color:#666666">*</span>kvroute <span style="color:#666666">=</span> (kvroute_t <span style="color:#666666">*</span>) args;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send identity of recipient first</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zframe_send (<span style="color:#666666">&amp;</span>kvroute<span style="color:#666666">-&gt;</span>identity,<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvroute<span style="color:#666666">-&gt;</span>socket, ZFRAME_MORE <span style="color:#666666">+</span> ZFRAME_REUSE);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_t <span style="color:#666666">*</span>kvmsg <span style="color:#666666">=</span> (kvmsg_t <span style="color:#666666">*</span>) data;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_send (kvmsg, kvroute<span style="color:#666666">-&gt;</span>socket);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The state manager task maintains the state and handles requests from<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>clients for snapshots:</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<span style="color:#0000FF">state_manager</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>args, zctx_t <span style="color:#666666">*</span>ctx, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>pipe)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zhash_t <span style="color:#666666">*</span>kvmap <span style="color:#666666">=</span> zhash_new ();</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zstr_send (pipe, <span style="color:#BA2121">"READY"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>snapshot <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_ROUTER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (snapshot, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5556"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zmq_pollitem_t items <span style="white-space: pre-wrap;">[]</span> <span style="color:#666666">=</span> {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>{ pipe, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> },<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>{ snapshot, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> }<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int64_t</span> sequence <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<tt><span style="white-space: pre-wrap;">       </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Current snapshot version number</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">!</span>zctx_interrupted) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> rc <span style="color:#666666">=</span> zmq_poll (items, <span style="color:#666666">2</span>, <span style="color:#666666">-</span><span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (rc <span style="color:#666666">==</span> <span style="color:#666666">-</span><span style="color:#666666">1</span> <span style="color:#666666">&amp;&amp;</span> errno <span style="color:#666666">==</span> ETERM)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Context has been shut down</em></span></p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Apply state update from main thread</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_t <span style="color:#666666">*</span>kvmsg <span style="color:#666666">=</span> kvmsg_recv (pipe);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>kvmsg)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>sequence <span style="color:#666666">=</span> kvmsg_sequence (kvmsg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_store (<span style="color:#666666">&amp;</span>kvmsg, kvmap);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Execute state snapshot request</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_t <span style="color:#666666">*</span>identity <span style="color:#666666">=</span> zframe_recv (snapshot);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>identity)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span></p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Request is in second frame of message</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>request <span style="color:#666666">=</span> zstr_recv (snapshot);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (streq (request, <span style="color:#BA2121">"ICANHAZ?"</span>))<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>free (request);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>else</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>printf (<span style="color:#BA2121">"E: bad request, aborting</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send state snapshot to client</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvroute_t routing <span style="color:#666666">=</span> { snapshot, identity };</p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>For each entry in kvmap, send kvmsg to client</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zhash_foreach (kvmap, s_send_single, <span style="color:#666666">&amp;</span>routing);</p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Now send END message with sequence number</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"Sending state shapshot=%d</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, (<span style="color:#B00040">int</span>) sequence);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_send (<span style="color:#666666">&amp;</span>identity, snapshot, ZFRAME_MORE);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_t <span style="color:#666666">*</span>kvmsg <span style="color:#666666">=</span> kvmsg_new (sequence);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_set_key<tt><span style="white-space: pre-wrap;">  </span></tt>(kvmsg, <span style="color:#BA2121">"KTHXBAI"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_set_body (kvmsg, (byte <span style="color:#666666">*</span>) <span style="color:#BA2121">""</span>, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_send<tt><span style="white-space: pre-wrap;">     </span></tt>(kvmsg, snapshot);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_destroy (<span style="color:#666666">&amp;</span>kvmsg);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zhash_destroy (<span style="color:#666666">&amp;</span>kvmap);<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/java:clonesrv2" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/py:clonesrv2" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/tcl:clonesrv2" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | C# | Clojure | CL | Delphi | Erlang | F# | Felix | Go | Haskell | Haxe | Lua | Node.js | Objective-C | ooc | Perl | PHP | Q | Racket | Ruby | Scala</a></span>
<p>And here is the client:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">clonecli2:&nbsp;Clone&nbsp;client,&nbsp;Model&nbsp;Two&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">clonecli2:&nbsp;Clone&nbsp;client,&nbsp;Model&nbsp;Two&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Clone client - Model Two</span></p>
<p><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Lets us build this source without creating a library<br>
#include "kvsimple.c"</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Prepare our context and subscriber</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>snapshot <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_DEALER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect (snapshot, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5556"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>subscriber <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_SUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_set_subscribe (subscriber, <span style="color:#BA2121">""</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect (subscriber, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5557"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zhash_t <span style="color:#666666">*</span>kvmap <span style="color:#666666">=</span> zhash_new ();</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Get state snapshot</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int64_t</span> sequence <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zstr_send (snapshot, <span style="color:#BA2121">"ICANHAZ?"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_t <span style="color:#666666">*</span>kvmsg <span style="color:#666666">=</span> kvmsg_recv (snapshot);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>kvmsg)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (streq (kvmsg_key (kvmsg), <span style="color:#BA2121">"KTHXBAI"</span>)) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>sequence <span style="color:#666666">=</span> kvmsg_sequence (kvmsg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"Received snapshot=%d</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, (<span style="color:#B00040">int</span>) sequence);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_destroy (<span style="color:#666666">&amp;</span>kvmsg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Done</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_store (<span style="color:#666666">&amp;</span>kvmsg, kvmap);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Now apply pending updates, discard out-of-sequence messages</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">!</span>zctx_interrupted) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_t <span style="color:#666666">*</span>kvmsg <span style="color:#666666">=</span> kvmsg_recv (subscriber);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>kvmsg)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (kvmsg_sequence (kvmsg) <span style="color:#666666">&gt;</span> sequence) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>sequence <span style="color:#666666">=</span> kvmsg_sequence (kvmsg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_store (<span style="color:#666666">&amp;</span>kvmsg, kvmap);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_destroy (<span style="color:#666666">&amp;</span>kvmsg);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zhash_destroy (<span style="color:#666666">&amp;</span>kvmap);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/java:clonecli2" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/py:clonecli2" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/tcl:clonecli2" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | C# | Clojure | CL | Delphi | Erlang | F# | Felix | Go | Haskell | Haxe | Lua | Node.js | Objective-C | ooc | Perl | PHP | Q | Racket | Ruby | Scala</a></span>
<p>Here are some things to note about these two programs:</p>
<ul>
<li>The server uses two tasks. One thread produces the updates (randomly) and sends these to the main PUB socket, while the other thread handles state requests on the ROUTER socket. The two communicate across PAIR sockets over an <tt>inproc:<span style="white-space: pre-wrap;">//</span></tt> connection.</li>
</ul>
<ul>
<li>The client is really simple. In C, it consists of about fifty lines of code. A lot of the heavy lifting is done in the <tt>kvmsg</tt> class. Even so, the basic Clone pattern is easier to implement than it seemed at first.</li>
</ul>
<ul>
<li>We don't use anything fancy for serializing the state. The hash table holds a set of <tt>kvmsg</tt> objects, and the server sends these, as a batch of messages, to the client requesting state. If multiple clients request state at once, each will get a different snapshot.</li>
</ul>
<ul>
<li>We assume that the client has exactly one server to talk to. The server must be running; we do not try to solve the question of what happens if the server crashes.</li>
</ul>
<p>Right now, these two programs don't do anything real, but they correctly synchronize state. It's a neat example of how to mix different patterns: PAIR-PAIR, PUB-SUB, and ROUTER-DEALER.</p>
<p><a name="Republishing-Updates-from-Clients"></a><a name="header-124"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc123"><span><a href="http://zguide.zeromq.org/page:all#Republishing-Updates-from-Clients">Republishing Updates from Clients</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-123">prev</a> <a href="http://zguide.zeromq.org/page:all#header-125">next</a></td>
</tr>
</tbody></table>
<p>In our second model, changes to the key-value store came from the server itself. This is a centralized model that is useful, for example if we have a central configuration file we want to distribute, with local caching on each node. A more interesting model takes updates from clients, not the server. The server thus becomes a stateless broker. This gives us some benefits:</p>
<ul>
<li>We're less worried about the reliability of the server. If it crashes, we can start a new instance and feed it new values.</li>
</ul>
<ul>
<li>We can use the key-value store to share knowledge between active peers.</li>
</ul>
<p>To send updates from clients back to the server, we could use a variety of socket patterns. The simplest plausible solution is a PUSH-PULL combination.</p>
<p>Why don't we allow clients to publish updates directly to each other? While this would reduce latency, it would remove the guarantee of consistency. You can't get consistent shared state if you allow the order of updates to change depending on who receives them. Say we have two clients, changing different keys. This will work fine. But if the two clients try to change the same key at roughly the same time, they'll end up with different notions of its value.</p>
<p>There are a few strategies for obtaining consistency when changes happen in multiple places at once. We'll use the approach of centralizing all change. No matter the precise timing of the changes that clients make, they are all pushed through the server, which enforces a single sequence according to the order in which it gets updates.</p>
<p><strong>Figure 60 - Republishing Updates</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig60.png" alt="fig60.png" class="image"></div>
<p>By mediating all changes, the server can also add a unique sequence number to all updates. With unique sequencing, clients can detect the nastier failures, including network congestion and queue overflow. If a client discovers that its incoming message stream has a hole, it can take action. It seems sensible that the client contact the server and ask for the missing messages, but in practice that isn't useful. If there are holes, they're caused by network stress, and adding more stress to the network will make things worse. All the client can do is warn its users that it is "unable to continue", stop, and not restart until someone has manually checked the cause of the problem.</p>
<p>We'll now generate state updates in the client. Here's the server:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">clonesrv3:&nbsp;Clone&nbsp;server,&nbsp;Model&nbsp;Three&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">clonesrv3:&nbsp;Clone&nbsp;server,&nbsp;Model&nbsp;Three&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Clone server - Model Three</span></p>
<p><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Lets us build this source without creating a library<br>
#include "kvsimple.c"</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Routing information for a key-value snapshot</em></span><br>
<span style="color:#008000"><strong>typedef</strong></span> <span style="color:#008000"><strong>struct</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>socket;<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>ROUTER socket to send to</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zframe_t <span style="color:#666666">*</span>identity;<tt><span style="white-space: pre-wrap;">     </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Identity of peer who requested state</em></span><br>
} kvroute_t;</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send one state snapshot key-value pair to a socket<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Hash item data is our kvmsg object, ready to send</span></span><br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">int</span><br>
<span style="color:#0000FF">s_send_single</span> (<span style="color:#008000"><strong>const</strong></span> <span style="color:#B00040">char</span> <span style="color:#666666">*</span>key, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>data, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>args)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvroute_t <span style="color:#666666">*</span>kvroute <span style="color:#666666">=</span> (kvroute_t <span style="color:#666666">*</span>) args;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send identity of recipient first</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zframe_send (<span style="color:#666666">&amp;</span>kvroute<span style="color:#666666">-&gt;</span>identity,<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvroute<span style="color:#666666">-&gt;</span>socket, ZFRAME_MORE <span style="color:#666666">+</span> ZFRAME_REUSE);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_t <span style="color:#666666">*</span>kvmsg <span style="color:#666666">=</span> (kvmsg_t <span style="color:#666666">*</span>) data;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_send (kvmsg, kvroute<span style="color:#666666">-&gt;</span>socket);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Prepare our context and sockets</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>snapshot <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_ROUTER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (snapshot, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5556"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>publisher <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_PUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (publisher, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5557"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>collector <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_PULL);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (collector, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5558"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The body of the main task collects updates from clients and</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>publishes them back out to clients:</em></span></p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int64_t</span> sequence <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zhash_t <span style="color:#666666">*</span>kvmap <span style="color:#666666">=</span> zhash_new ();</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zmq_pollitem_t items <span style="white-space: pre-wrap;">[]</span> <span style="color:#666666">=</span> {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>{ collector, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> },<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>{ snapshot, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> }<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">!</span>zctx_interrupted) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> rc <span style="color:#666666">=</span> zmq_poll (items, <span style="color:#666666">2</span>, <span style="color:#666666">1000</span> <span style="color:#666666">*</span> ZMQ_POLL_MSEC);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Apply state update sent from client</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_t <span style="color:#666666">*</span>kvmsg <span style="color:#666666">=</span> kvmsg_recv (collector);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>kvmsg)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_set_sequence (kvmsg, <span style="color:#666666">++</span>sequence);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_send (kvmsg, publisher);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_store (<span style="color:#666666">&amp;</span>kvmsg, kvmap);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"I: publishing update %5d</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, (<span style="color:#B00040">int</span>) sequence);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Execute state snapshot request</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_t <span style="color:#666666">*</span>identity <span style="color:#666666">=</span> zframe_recv (snapshot);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>identity)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span></p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Request is in second frame of message</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>request <span style="color:#666666">=</span> zstr_recv (snapshot);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (streq (request, <span style="color:#BA2121">"ICANHAZ?"</span>))<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>free (request);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>else</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>printf (<span style="color:#BA2121">"E: bad request, aborting</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send state snapshot to client</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvroute_t routing <span style="color:#666666">=</span> { snapshot, identity };</p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>For each entry in kvmap, send kvmsg to client</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zhash_foreach (kvmap, s_send_single, <span style="color:#666666">&amp;</span>routing);</p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Now send END message with sequence number</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"I: sending shapshot=%d</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, (<span style="color:#B00040">int</span>) sequence);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_send (<span style="color:#666666">&amp;</span>identity, snapshot, ZFRAME_MORE);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_t <span style="color:#666666">*</span>kvmsg <span style="color:#666666">=</span> kvmsg_new (sequence);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_set_key<tt><span style="white-space: pre-wrap;">  </span></tt>(kvmsg, <span style="color:#BA2121">"KTHXBAI"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_set_body (kvmsg, (byte <span style="color:#666666">*</span>) <span style="color:#BA2121">""</span>, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_send<tt><span style="white-space: pre-wrap;">     </span></tt>(kvmsg, snapshot);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_destroy (<span style="color:#666666">&amp;</span>kvmsg);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">" Interrupted</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">%d messages handled</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, (<span style="color:#B00040">int</span>) sequence);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zhash_destroy (<span style="color:#666666">&amp;</span>kvmap);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/java:clonesrv3" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/py:clonesrv3" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/tcl:clonesrv3" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | C# | Clojure | CL | Delphi | Erlang | F# | Felix | Go | Haskell | Haxe | Lua | Node.js | Objective-C | ooc | Perl | PHP | Q | Racket | Ruby | Scala</a></span>
<p>And here is the client:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">clonecli3:&nbsp;Clone&nbsp;client,&nbsp;Model&nbsp;Three&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">clonecli3:&nbsp;Clone&nbsp;client,&nbsp;Model&nbsp;Three&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Clone client - Model Three</span></p>
<p><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Lets us build this source without creating a library<br>
#include "kvsimple.c"</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Prepare our context and subscriber</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>snapshot <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_DEALER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect (snapshot, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5556"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>subscriber <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_SUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_set_subscribe (subscriber, <span style="color:#BA2121">""</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect (subscriber, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5557"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>publisher <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_PUSH);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect (publisher, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5558"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zhash_t <span style="color:#666666">*</span>kvmap <span style="color:#666666">=</span> zhash_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>srandom ((<span style="color:#B00040">unsigned</span>) time (<span style="color:#008000">NULL</span>));</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We first request a state snapshot:</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int64_t</span> sequence <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zstr_send (snapshot, <span style="color:#BA2121">"ICANHAZ?"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_t <span style="color:#666666">*</span>kvmsg <span style="color:#666666">=</span> kvmsg_recv (snapshot);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>kvmsg)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (streq (kvmsg_key (kvmsg), <span style="color:#BA2121">"KTHXBAI"</span>)) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>sequence <span style="color:#666666">=</span> kvmsg_sequence (kvmsg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"I: received snapshot=%d</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, (<span style="color:#B00040">int</span>) sequence);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_destroy (<span style="color:#666666">&amp;</span>kvmsg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Done</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_store (<span style="color:#666666">&amp;</span>kvmsg, kvmap);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Now we wait for updates from the server and every so often, we</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>send a random key-value update to the server:</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int64_t</span> alarm <span style="color:#666666">=</span> zclock_time () <span style="color:#666666">+</span> <span style="color:#666666">1000</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">!</span>zctx_interrupted) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_pollitem_t items <span style="white-space: pre-wrap;">[]</span> <span style="color:#666666">=</span> { { subscriber, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> } };<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> tickless <span style="color:#666666">=</span> (<span style="color:#B00040">int</span>) ((alarm <span style="color:#666666">-</span> zclock_time ()));<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (tickless <span style="color:#666666">&lt;</span> <span style="color:#666666">0</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>tickless <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> rc <span style="color:#666666">=</span> zmq_poll (items, <span style="color:#666666">1</span>, tickless <span style="color:#666666">*</span> ZMQ_POLL_MSEC);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (rc <span style="color:#666666">==</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Context has been shut down</em></span></p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_t <span style="color:#666666">*</span>kvmsg <span style="color:#666666">=</span> kvmsg_recv (subscriber);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>kvmsg)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span></p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Discard out-of-sequence kvmsgs, incl. heartbeats</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (kvmsg_sequence (kvmsg) <span style="color:#666666">&gt;</span> sequence) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>sequence <span style="color:#666666">=</span> kvmsg_sequence (kvmsg);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>kvmsg_store (<span style="color:#666666">&amp;</span>kvmsg, kvmap);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>printf (<span style="color:#BA2121">"I: received update=%d</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, (<span style="color:#B00040">int</span>) sequence);<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt>kvmsg_destroy (<span style="color:#666666">&amp;</span>kvmsg);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If we timed out, generate a random kvmsg</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (zclock_time () <span style="color:#666666">&gt;=</span> alarm) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_t <span style="color:#666666">*</span>kvmsg <span style="color:#666666">=</span> kvmsg_new (<span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_fmt_key<tt><span style="white-space: pre-wrap;">  </span></tt>(kvmsg, <span style="color:#BA2121">"%d"</span>, randof (<span style="color:#666666">10000</span>));<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_fmt_body (kvmsg, <span style="color:#BA2121">"%d"</span>, randof (<span style="color:#666666">1000000</span>));<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_send<tt><span style="white-space: pre-wrap;">     </span></tt>(kvmsg, publisher);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_destroy (<span style="color:#666666">&amp;</span>kvmsg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>alarm <span style="color:#666666">=</span> zclock_time () <span style="color:#666666">+</span> <span style="color:#666666">1000</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">" Interrupted</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">%d messages in</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, (<span style="color:#B00040">int</span>) sequence);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zhash_destroy (<span style="color:#666666">&amp;</span>kvmap);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/java:clonecli3" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/py:clonecli3" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/tcl:clonecli3" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | C# | Clojure | CL | Delphi | Erlang | F# | Felix | Go | Haskell | Haxe | Lua | Node.js | Objective-C | ooc | Perl | PHP | Q | Racket | Ruby | Scala</a></span>
<p>Here are some things to note about this third design:</p>
<ul>
<li>The server has collapsed to a single task. It manages a PULL socket for incoming updates, a ROUTER socket for state requests, and a PUB socket for outgoing updates.</li>
</ul>
<ul>
<li>The client uses a simple tickless timer to send a random update to the server once a second. In a real implementation, we would drive updates from application code.</li>
</ul>
<p><a name="Working-with-Subtrees"></a><a name="header-125"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc124"><span><a href="http://zguide.zeromq.org/page:all#Working-with-Subtrees">Working with Subtrees</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-124">prev</a> <a href="http://zguide.zeromq.org/page:all#header-126">next</a></td>
</tr>
</tbody></table>
<p>As we grow the number of clients, the size of our shared store will also grow. It stops being reasonable to send everything to every client. This is the classic story with pub-sub: when you have a very small number of clients, you can send every message to all clients. As you grow the architecture, this becomes inefficient. Clients specialize in different areas.</p>
<p>So even when working with a shared store, some clients will want to work only with a part of that store, which we call a <em>subtree</em>. The client has to request the subtree when it makes a state request, and it must specify the same subtree when it subscribes to updates.</p>
<p>There are a couple of common syntaxes for trees. One is the <em>path hierarchy</em>, and another is the <em>topic tree</em>. These look like this:</p>
<ul>
<li>Path hierarchy: <tt>/some/list/of/paths</tt></li>
<li>Topic tree: <tt>some.list.of.topics</tt></li>
</ul>
<p>We'll use the path hierarchy, and extend our client and server so that a client can work with a single subtree. Once you see how to work with a single subtree you'll be able to extend this yourself to handle multiple subtrees, if your use case demands it.</p>
<p>Here's the server implementing subtrees, a small variation on Model Three:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">clonesrv4:&nbsp;Clone&nbsp;server,&nbsp;Model&nbsp;Four&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">clonesrv4:&nbsp;Clone&nbsp;server,&nbsp;Model&nbsp;Four&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Clone server - Model Four</span></p>
<p><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Lets us build this source without creating a library<br>
#include "kvsimple.c"</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Routing information for a key-value snapshot</em></span><br>
<span style="color:#008000"><strong>typedef</strong></span> <span style="color:#008000"><strong>struct</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>socket;<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>ROUTER socket to send to</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zframe_t <span style="color:#666666">*</span>identity;<tt><span style="white-space: pre-wrap;">     </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Identity of peer who requested state</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>subtree;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Client subtree specification</em></span><br>
} kvroute_t;</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send one state snapshot key-value pair to a socket<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Hash item data is our kvmsg object, ready to send</span></span><br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">int</span><br>
<span style="color:#0000FF">s_send_single</span> (<span style="color:#008000"><strong>const</strong></span> <span style="color:#B00040">char</span> <span style="color:#666666">*</span>key, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>data, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>args)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvroute_t <span style="color:#666666">*</span>kvroute <span style="color:#666666">=</span> (kvroute_t <span style="color:#666666">*</span>) args;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_t <span style="color:#666666">*</span>kvmsg <span style="color:#666666">=</span> (kvmsg_t <span style="color:#666666">*</span>) data;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (strlen (kvroute<span style="color:#666666">-&gt;</span>subtree) <span style="color:#666666">&lt;=</span> strlen (kvmsg_key (kvmsg))<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#666666">&amp;&amp;</span><tt><span style="white-space: pre-wrap;">  </span></tt>memcmp (kvroute<span style="color:#666666">-&gt;</span>subtree,<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>kvmsg_key (kvmsg), strlen (kvroute<span style="color:#666666">-&gt;</span>subtree)) <span style="color:#666666">==</span> <span style="color:#666666">0</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send identity of recipient first</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_send (<span style="color:#666666">&amp;</span>kvroute<span style="color:#666666">-&gt;</span>identity,<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvroute<span style="color:#666666">-&gt;</span>socket, ZFRAME_MORE <span style="color:#666666">+</span> ZFRAME_REUSE);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_send (kvmsg, kvroute<span style="color:#666666">-&gt;</span>socket);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The main task is identical to clonesrv3 except for where it<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>handles subtrees.</span></span></p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Prepare our context and sockets</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>snapshot <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_ROUTER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (snapshot, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5556"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>publisher <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_PUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (publisher, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5557"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>collector <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_PULL);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (collector, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5558"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int64_t</span> sequence <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zhash_t <span style="color:#666666">*</span>kvmap <span style="color:#666666">=</span> zhash_new ();</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zmq_pollitem_t items <span style="white-space: pre-wrap;">[]</span> <span style="color:#666666">=</span> {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>{ collector, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> },<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>{ snapshot, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> }<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">!</span>zctx_interrupted) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> rc <span style="color:#666666">=</span> zmq_poll (items, <span style="color:#666666">2</span>, <span style="color:#666666">1000</span> <span style="color:#666666">*</span> ZMQ_POLL_MSEC);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Apply state update sent from client</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_t <span style="color:#666666">*</span>kvmsg <span style="color:#666666">=</span> kvmsg_recv (collector);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>kvmsg)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_set_sequence (kvmsg, <span style="color:#666666">++</span>sequence);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_send (kvmsg, publisher);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_store (<span style="color:#666666">&amp;</span>kvmsg, kvmap);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"I: publishing update %5d</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, (<span style="color:#B00040">int</span>) sequence);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Execute state snapshot request</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_t <span style="color:#666666">*</span>identity <span style="color:#666666">=</span> zframe_recv (snapshot);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>identity)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span></p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Request is in second frame of message</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>request <span style="color:#666666">=</span> zstr_recv (snapshot);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>subtree <span style="color:#666666">=</span> <span style="color:#008000">NULL</span>;<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (streq (request, <span style="color:#BA2121">"ICANHAZ?"</span>)) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>free (request);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>subtree <span style="color:#666666">=</span> zstr_recv (snapshot);<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>else</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>printf (<span style="color:#BA2121">"E: bad request, aborting</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send state snapshot to client</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvroute_t routing <span style="color:#666666">=</span> { snapshot, identity, subtree };</p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>For each entry in kvmap, send kvmsg to client</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zhash_foreach (kvmap, s_send_single, <span style="color:#666666">&amp;</span>routing);</p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Now send END message with sequence number</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"I: sending shapshot=%d</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, (<span style="color:#B00040">int</span>) sequence);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_send (<span style="color:#666666">&amp;</span>identity, snapshot, ZFRAME_MORE);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_t <span style="color:#666666">*</span>kvmsg <span style="color:#666666">=</span> kvmsg_new (sequence);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_set_key<tt><span style="white-space: pre-wrap;">  </span></tt>(kvmsg, <span style="color:#BA2121">"KTHXBAI"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_set_body (kvmsg, (byte <span style="color:#666666">*</span>) subtree, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_send<tt><span style="white-space: pre-wrap;">     </span></tt>(kvmsg, snapshot);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_destroy (<span style="color:#666666">&amp;</span>kvmsg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>free (subtree);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">" Interrupted</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">%d messages handled</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, (<span style="color:#B00040">int</span>) sequence);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zhash_destroy (<span style="color:#666666">&amp;</span>kvmap);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/java:clonesrv4" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/py:clonesrv4" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/tcl:clonesrv4" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | C# | Clojure | CL | Delphi | Erlang | F# | Felix | Go | Haskell | Haxe | Lua | Node.js | Objective-C | ooc | Perl | PHP | Q | Racket | Ruby | Scala</a></span>
<p>And here is the corresponding client:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">clonecli4:&nbsp;Clone&nbsp;client,&nbsp;Model&nbsp;Four&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">clonecli4:&nbsp;Clone&nbsp;client,&nbsp;Model&nbsp;Four&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Clone client - Model Four</span></p>
<p><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Lets us build this source without creating a library<br>
#include "kvsimple.c"</p>
<p><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This client is identical to clonecli3 except for where we<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>handles subtrees.<br>
#define SUBTREE "/client/"</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Prepare our context and subscriber</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>snapshot <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_DEALER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect (snapshot, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5556"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>subscriber <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_SUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_set_subscribe (subscriber, <span style="color:#BA2121">""</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect (subscriber, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5557"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_set_subscribe (subscriber, SUBTREE);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>publisher <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_PUSH);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect (publisher, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5558"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zhash_t <span style="color:#666666">*</span>kvmap <span style="color:#666666">=</span> zhash_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>srandom ((<span style="color:#B00040">unsigned</span>) time (<span style="color:#008000">NULL</span>));</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We first request a state snapshot:</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int64_t</span> sequence <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zstr_sendm (snapshot, <span style="color:#BA2121">"ICANHAZ?"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zstr_send<tt><span style="white-space: pre-wrap;">  </span></tt>(snapshot, SUBTREE);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_t <span style="color:#666666">*</span>kvmsg <span style="color:#666666">=</span> kvmsg_recv (snapshot);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>kvmsg)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (streq (kvmsg_key (kvmsg), <span style="color:#BA2121">"KTHXBAI"</span>)) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>sequence <span style="color:#666666">=</span> kvmsg_sequence (kvmsg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"I: received snapshot=%d</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, (<span style="color:#B00040">int</span>) sequence);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_destroy (<span style="color:#666666">&amp;</span>kvmsg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Done</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_store (<span style="color:#666666">&amp;</span>kvmsg, kvmap);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int64_t</span> alarm <span style="color:#666666">=</span> zclock_time () <span style="color:#666666">+</span> <span style="color:#666666">1000</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">!</span>zctx_interrupted) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_pollitem_t items <span style="white-space: pre-wrap;">[]</span> <span style="color:#666666">=</span> { { subscriber, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> } };<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> tickless <span style="color:#666666">=</span> (<span style="color:#B00040">int</span>) ((alarm <span style="color:#666666">-</span> zclock_time ()));<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (tickless <span style="color:#666666">&lt;</span> <span style="color:#666666">0</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>tickless <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> rc <span style="color:#666666">=</span> zmq_poll (items, <span style="color:#666666">1</span>, tickless <span style="color:#666666">*</span> ZMQ_POLL_MSEC);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (rc <span style="color:#666666">==</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Context has been shut down</em></span></p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (items <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_t <span style="color:#666666">*</span>kvmsg <span style="color:#666666">=</span> kvmsg_recv (subscriber);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>kvmsg)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span></p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Discard out-of-sequence kvmsgs, incl. heartbeats</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (kvmsg_sequence (kvmsg) <span style="color:#666666">&gt;</span> sequence) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>sequence <span style="color:#666666">=</span> kvmsg_sequence (kvmsg);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>kvmsg_store (<span style="color:#666666">&amp;</span>kvmsg, kvmap);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>printf (<span style="color:#BA2121">"I: received update=%d</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, (<span style="color:#B00040">int</span>) sequence);<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt>kvmsg_destroy (<span style="color:#666666">&amp;</span>kvmsg);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If we timed out, generate a random kvmsg</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (zclock_time () <span style="color:#666666">&gt;=</span> alarm) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_t <span style="color:#666666">*</span>kvmsg <span style="color:#666666">=</span> kvmsg_new (<span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_fmt_key<tt><span style="white-space: pre-wrap;">  </span></tt>(kvmsg, <span style="color:#BA2121">"%s%d"</span>, SUBTREE, randof (<span style="color:#666666">10000</span>));<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_fmt_body (kvmsg, <span style="color:#BA2121">"%d"</span>, randof (<span style="color:#666666">1000000</span>));<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_send<tt><span style="white-space: pre-wrap;">     </span></tt>(kvmsg, publisher);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_destroy (<span style="color:#666666">&amp;</span>kvmsg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>alarm <span style="color:#666666">=</span> zclock_time () <span style="color:#666666">+</span> <span style="color:#666666">1000</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">" Interrupted</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">%d messages in</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, (<span style="color:#B00040">int</span>) sequence);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zhash_destroy (<span style="color:#666666">&amp;</span>kvmap);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/java:clonecli4" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/py:clonecli4" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/tcl:clonecli4" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | C# | Clojure | CL | Delphi | Erlang | F# | Felix | Go | Haskell | Haxe | Lua | Node.js | Objective-C | ooc | Perl | PHP | Q | Racket | Ruby | Scala</a></span>
<p><a name="Ephemeral-Values"></a><a name="header-126"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc125"><span><a href="http://zguide.zeromq.org/page:all#Ephemeral-Values">Ephemeral Values</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-125">prev</a> <a href="http://zguide.zeromq.org/page:all#header-127">next</a></td>
</tr>
</tbody></table>
<p>An ephemeral value is one that expires automatically unless regularly refreshed. If you think of Clone being used for a registration service, then ephemeral values would let you do dynamic values. A node joins the network, publishes its address, and refreshes this regularly. If the node dies, its address eventually gets removed.</p>
<p>The usual abstraction for ephemeral values is to attach them to a <em>session</em>, and delete them when the session ends. In Clone, sessions would be defined by clients, and would end if the client died. A simpler alternative is to attach a <em>time to live</em> (TTL) to ephemeral values, which the server uses to expire values that haven't been refreshed in time.</p>
<p>A good design principle that I use whenever possible is to <em>not invent concepts that are not absolutely essential</em>. If we have very large numbers of ephemeral values, sessions will offer better performance. If we use a handful of ephemeral values, it's fine to set a TTL on each one. If we use masses of ephemeral values, it's more efficient to attach them to sessions and expire them in bulk. This isn't a problem we face at this stage, and may never face, so sessions go out the window.</p>
<p>Now we will implement ephemeral values. First, we need a way to encode the TTL in the key-value message. We could add a frame. The problem with using ZeroMQ frames for properties is that each time we want to add a new property, we have to change the message structure. It breaks compatibility. So let's add a properties frame to the message, and write the code to let us get and put property values.</p>
<p>Next, we need a way to say, "delete this value". Up until now, servers and clients have always blindly inserted or updated new values into their hash table. We'll say that if the value is empty, that means "delete this key".</p>
<p>Here's a more complete version of the <tt>kvmsg</tt> class, which implements the properties frame (and adds a UUID frame, which we'll need later on). It also handles empty values by deleting the key from the hash, if necessary:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">kvmsg:&nbsp;Key-value&nbsp;message&nbsp;class:&nbsp;full&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">kvmsg:&nbsp;Key-value&nbsp;message&nbsp;class:&nbsp;full&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>kvmsg class - key-value message class for example applications</span></p>
<p>#include "kvmsg.h"<br>
#include &lt;uuid/uuid.h&gt;<br>
#include "zlist.h"</p>
<p><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Keys are short strings<br>
#define KVMSG_KEY_MAX<tt><span style="white-space: pre-wrap;">   </span></tt>255</p>
<p><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Message is formatted on wire as 5 frames:<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>frame 0: key (0MQ string)<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>frame 1: sequence (8 bytes, network order)<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>frame 2: uuid (blob, 16 bytes)<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>frame 3: properties (0MQ string)<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>frame 4: body (blob)<br>
#define FRAME_KEY<tt><span style="white-space: pre-wrap;">       </span></tt>0<br>
#define FRAME_SEQ<tt><span style="white-space: pre-wrap;">       </span></tt>1<br>
#define FRAME_UUID<tt><span style="white-space: pre-wrap;">      </span></tt>2<br>
#define FRAME_PROPS<tt><span style="white-space: pre-wrap;">     </span></tt>3<br>
#define FRAME_BODY<tt><span style="white-space: pre-wrap;">      </span></tt>4<br>
#define KVMSG_FRAMES<tt><span style="white-space: pre-wrap;">    </span></tt>5</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Structure of our class</em></span><br>
<span style="color:#008000"><strong>struct</strong></span> _kvmsg {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Presence indicators for each frame</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> present <span style="white-space: pre-wrap;">[</span>KVMSG_FRAMES<span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Corresponding 0MQ message frames, if any</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_msg_t frame <span style="white-space: pre-wrap;">[</span>KVMSG_FRAMES<span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Key, copied into safe C string</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> key <span style="white-space: pre-wrap;">[</span>KVMSG_KEY_MAX <span style="color:#666666">+</span> <span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>List of properties, as name=value strings</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zlist_t <span style="color:#666666">*</span>props;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">size_t</span> props_size;<br>
};</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>These two helpers serialize a list of properties to and from a<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>message frame:</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<span style="color:#0000FF">s_encode_props</span> (kvmsg_t <span style="color:#666666">*</span>self)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_msg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> <span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>frame <span style="white-space: pre-wrap;">[</span>FRAME_PROPS<span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>FRAME_PROPS<span style="white-space: pre-wrap;">]</span>)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_msg_close (msg);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zmq_msg_init_size (msg, self<span style="color:#666666">-&gt;</span>props_size);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>prop <span style="color:#666666">=</span> zlist_first (self<span style="color:#666666">-&gt;</span>props);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>dest <span style="color:#666666">=</span> (<span style="color:#B00040">char</span> <span style="color:#666666">*</span>) zmq_msg_data (msg);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (prop) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>strcpy (dest, prop);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>dest <span style="color:#666666">+=</span> strlen (prop);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#666666">*</span>dest<span style="color:#666666">++</span> <span style="color:#666666">=</span> <span style="color:#BA2121">'\n'</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>prop <span style="color:#666666">=</span> zlist_next (self<span style="color:#666666">-&gt;</span>props);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>FRAME_PROPS<span style="white-space: pre-wrap;">]</span> <span style="color:#666666">=</span> <span style="color:#666666">1</span>;<br>
}</p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<span style="color:#0000FF">s_decode_props</span> (kvmsg_t <span style="color:#666666">*</span>self)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_msg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> <span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>frame <span style="white-space: pre-wrap;">[</span>FRAME_PROPS<span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>props_size <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (zlist_size (self<span style="color:#666666">-&gt;</span>props))<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (zlist_pop (self<span style="color:#666666">-&gt;</span>props));</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">size_t</span> remainder <span style="color:#666666">=</span> zmq_msg_size (msg);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>prop <span style="color:#666666">=</span> (<span style="color:#B00040">char</span> <span style="color:#666666">*</span>) zmq_msg_data (msg);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>eoln <span style="color:#666666">=</span> memchr (prop, <span style="color:#BA2121">'\n'</span>, remainder);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (eoln) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#666666">*</span>eoln <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zlist_append (self<span style="color:#666666">-&gt;</span>props, strdup (prop));<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>self<span style="color:#666666">-&gt;</span>props_size <span style="color:#666666">+=</span> strlen (prop) <span style="color:#666666">+</span> <span style="color:#666666">1</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>remainder <span style="color:#666666">-=</span> strlen (prop) <span style="color:#666666">+</span> <span style="color:#666666">1</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>prop <span style="color:#666666">=</span> eoln <span style="color:#666666">+</span> <span style="color:#666666">1</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>eoln <span style="color:#666666">=</span> memchr (prop, <span style="color:#BA2121">'\n'</span>, remainder);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Here are the constructor and destructor for the class:</em></span></p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Constructor, takes a sequence number for the new kvmsg instance:</em></span><br>
kvmsg_t <span style="color:#666666">*</span><br>
<span style="color:#0000FF">kvmsg_new</span> (<span style="color:#B00040">int64_t</span> sequence)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_t<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#666666">*</span>self;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>self <span style="color:#666666">=</span> (kvmsg_t <span style="color:#666666">*</span>) zmalloc (<span style="color:#008000"><strong>sizeof</strong></span> (kvmsg_t));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>props <span style="color:#666666">=</span> zlist_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_set_sequence (self, sequence);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> self;<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>zhash_free_fn callback helper that does the low level destruction:</em></span><br>
<span style="color:#B00040">void</span><br>
<span style="color:#0000FF">kvmsg_free</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>ptr)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (ptr) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> (kvmsg_t <span style="color:#666666">*</span>) ptr;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Destroy message frames if any</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> frame_nbr;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>for</strong></span> (frame_nbr <span style="color:#666666">=</span> <span style="color:#666666">0</span>; frame_nbr <span style="color:#666666">&lt;</span> KVMSG_FRAMES; frame_nbr<span style="color:#666666">++</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>frame_nbr<span style="white-space: pre-wrap;">]</span>)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmq_msg_close (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>frame <span style="white-space: pre-wrap;">[</span>frame_nbr<span style="white-space: pre-wrap;">]</span>);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Destroy property list</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>while</strong></span> (zlist_size (self<span style="color:#666666">-&gt;</span>props))<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>free (zlist_pop (self<span style="color:#666666">-&gt;</span>props));<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zlist_destroy (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>props);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Free object itself</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (self);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Destructor</em></span><br>
<span style="color:#B00040">void</span><br>
<span style="color:#0000FF">kvmsg_destroy</span> (kvmsg_t <span style="color:#666666"><span style="white-space: pre-wrap;">**</span></span>self_p)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self_p);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">*</span>self_p) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_free (<span style="color:#666666">*</span>self_p);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#666666">*</span>self_p <span style="color:#666666">=</span> <span style="color:#008000">NULL</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This method reads a key-value message from the socket and returns a<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>new <tt>kvmsg</tt> instance:</span></span></p>
<p>kvmsg_t <span style="color:#666666">*</span><br>
<span style="color:#0000FF">kvmsg_recv</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>socket)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This method is almost unchanged from kvsimple</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (socket);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> kvmsg_new (<span style="color:#666666">0</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Read all frames off the wire, reject if bogus</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> frame_nbr;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (frame_nbr <span style="color:#666666">=</span> <span style="color:#666666">0</span>; frame_nbr <span style="color:#666666">&lt;</span> KVMSG_FRAMES; frame_nbr<span style="color:#666666">++</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>frame_nbr<span style="white-space: pre-wrap;">]</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmq_msg_close (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>frame <span style="white-space: pre-wrap;">[</span>frame_nbr<span style="white-space: pre-wrap;">]</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_msg_init (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>frame <span style="white-space: pre-wrap;">[</span>frame_nbr<span style="white-space: pre-wrap;">]</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>self<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>frame_nbr<span style="white-space: pre-wrap;">]</span> <span style="color:#666666">=</span> <span style="color:#666666">1</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (zmq_msg_recv (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>frame <span style="white-space: pre-wrap;">[</span>frame_nbr<span style="white-space: pre-wrap;">]</span>, socket, <span style="color:#666666">0</span>) <span style="color:#666666">==</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_destroy (<span style="color:#666666">&amp;</span>self);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Verify multipart framing</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> rcvmore <span style="color:#666666">=</span> (frame_nbr <span style="color:#666666">&lt;</span> KVMSG_FRAMES <span style="color:#666666">-</span> <span style="color:#666666">1</span>)<span style="color:#666666">?</span> <span style="color:#666666">1</span><span style="color:#666666">:</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (zsocket_rcvmore (socket) <span style="color:#666666">!=</span> rcvmore) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_destroy (<span style="color:#666666">&amp;</span>self);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>s_decode_props (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> self;<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send key-value message to socket; any empty frames are sent as such.</em></span><br>
<span style="color:#B00040">void</span><br>
<span style="color:#0000FF">kvmsg_send</span> (kvmsg_t <span style="color:#666666">*</span>self, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>socket)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (socket);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>s_encode_props (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The rest of the method is unchanged from kvsimple</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> frame_nbr;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (frame_nbr <span style="color:#666666">=</span> <span style="color:#666666">0</span>; frame_nbr <span style="color:#666666">&lt;</span> KVMSG_FRAMES; frame_nbr<span style="color:#666666">++</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_msg_t copy;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_msg_init (<span style="color:#666666">&amp;</span>copy);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>frame_nbr<span style="white-space: pre-wrap;">]</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmq_msg_copy (<span style="color:#666666">&amp;</span>copy, <span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>frame <span style="white-space: pre-wrap;">[</span>frame_nbr<span style="white-space: pre-wrap;">]</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_msg_send (<span style="color:#666666">&amp;</span>copy, socket,<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>(frame_nbr <span style="color:#666666">&lt;</span> KVMSG_FRAMES <span style="color:#666666">-</span> <span style="color:#666666">1</span>)<span style="color:#666666">?</span> ZMQ_SNDMORE<span style="color:#666666">:</span> <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_msg_close (<span style="color:#666666">&amp;</span>copy);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This method duplicates a <tt>kvmsg</tt> instance, returns the new instance:</em></span></p>
<p>kvmsg_t <span style="color:#666666">*</span><br>
<span style="color:#0000FF">kvmsg_dup</span> (kvmsg_t <span style="color:#666666">*</span>self)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_t <span style="color:#666666">*</span>kvmsg <span style="color:#666666">=</span> kvmsg_new (<span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> frame_nbr;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>for</strong></span> (frame_nbr <span style="color:#666666">=</span> <span style="color:#666666">0</span>; frame_nbr <span style="color:#666666">&lt;</span> KVMSG_FRAMES; frame_nbr<span style="color:#666666">++</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>frame_nbr<span style="white-space: pre-wrap;">]</span>) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmq_msg_t <span style="color:#666666">*</span>src <span style="color:#666666">=</span> <span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>frame <span style="white-space: pre-wrap;">[</span>frame_nbr<span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmq_msg_t <span style="color:#666666">*</span>dst <span style="color:#666666">=</span> <span style="color:#666666">&amp;</span>kvmsg<span style="color:#666666">-&gt;</span>frame <span style="white-space: pre-wrap;">[</span>frame_nbr<span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmq_msg_init_size (dst, zmq_msg_size (src));<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>memcpy (zmq_msg_data (dst),<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>zmq_msg_data (src), zmq_msg_size (src));<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>frame_nbr<span style="white-space: pre-wrap;">]</span> <span style="color:#666666">=</span> <span style="color:#666666">1</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg<span style="color:#666666">-&gt;</span>props_size <span style="color:#666666">=</span> zlist_size (self<span style="color:#666666">-&gt;</span>props);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>prop <span style="color:#666666">=</span> (<span style="color:#B00040">char</span> <span style="color:#666666">*</span>) zlist_first (self<span style="color:#666666">-&gt;</span>props);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (prop) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zlist_append (kvmsg<span style="color:#666666">-&gt;</span>props, strdup (prop));<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>prop <span style="color:#666666">=</span> (<span style="color:#B00040">char</span> <span style="color:#666666">*</span>) zlist_next (self<span style="color:#666666">-&gt;</span>props);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> kvmsg;<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The key, sequence, body, and size methods are the same as in kvsimple.</em></span></p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Return key from last read message, if any, else NULL</em></span><br>
<span style="color:#B00040">char</span> <span style="color:#666666">*</span><br>
<span style="color:#0000FF">kvmsg_key</span> (kvmsg_t <span style="color:#666666">*</span>self)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>FRAME_KEY<span style="white-space: pre-wrap;">]</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!*</span>self<span style="color:#666666">-&gt;</span>key) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">size_t</span> size <span style="color:#666666">=</span> zmq_msg_size (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>frame <span style="white-space: pre-wrap;">[</span>FRAME_KEY<span style="white-space: pre-wrap;">]</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (size <span style="color:#666666">&gt;</span> KVMSG_KEY_MAX)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>size <span style="color:#666666">=</span> KVMSG_KEY_MAX;<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>memcpy (self<span style="color:#666666">-&gt;</span>key,<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zmq_msg_data (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>frame <span style="white-space: pre-wrap;">[</span>FRAME_KEY<span style="white-space: pre-wrap;">]</span>), size);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>self<span style="color:#666666">-&gt;</span>key <span style="white-space: pre-wrap;">[</span>size<span style="white-space: pre-wrap;">]</span> <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>return</strong></span> self<span style="color:#666666">-&gt;</span>key;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#008000">NULL</span>;<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Set message key as provided</em></span><br>
<span style="color:#B00040">void</span><br>
<span style="color:#0000FF">kvmsg_set_key</span> (kvmsg_t <span style="color:#666666">*</span>self, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>key)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_msg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> <span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>frame <span style="white-space: pre-wrap;">[</span>FRAME_KEY<span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>FRAME_KEY<span style="white-space: pre-wrap;">]</span>)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_msg_close (msg);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_msg_init_size (msg, strlen (key));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>memcpy (zmq_msg_data (msg), key, strlen (key));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>FRAME_KEY<span style="white-space: pre-wrap;">]</span> <span style="color:#666666">=</span> <span style="color:#666666">1</span>;<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Set message key using printf format</em></span><br>
<span style="color:#B00040">void</span><br>
<span style="color:#0000FF">kvmsg_fmt_key</span> (kvmsg_t <span style="color:#666666">*</span>self, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>format, …)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> value <span style="white-space: pre-wrap;">[</span>KVMSG_KEY_MAX <span style="color:#666666">+</span> <span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">va_list</span> args;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>va_start (args, format);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>vsnprintf (value, KVMSG_KEY_MAX, format, args);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>va_end (args);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_set_key (self, value);<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Return sequence nbr from last read message, if any</em></span><br>
<span style="color:#B00040">int64_t</span><br>
<span style="color:#0000FF">kvmsg_sequence</span> (kvmsg_t <span style="color:#666666">*</span>self)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>FRAME_SEQ<span style="white-space: pre-wrap;">]</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>assert (zmq_msg_size (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>frame <span style="white-space: pre-wrap;">[</span>FRAME_SEQ<span style="white-space: pre-wrap;">]</span>) <span style="color:#666666">==</span> <span style="color:#666666">8</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>byte <span style="color:#666666">*</span>source <span style="color:#666666">=</span> zmq_msg_data (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>frame <span style="white-space: pre-wrap;">[</span>FRAME_SEQ<span style="white-space: pre-wrap;">]</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int64_t</span> sequence <span style="color:#666666">=</span> ((<span style="color:#B00040">int64_t</span>) (source <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>) <span style="color:#666666"><span style="white-space: pre-wrap;">&lt;&lt;</span></span> <span style="color:#666666">56</span>)<br>
<tt><span style="white-space: pre-wrap;">                         </span></tt><span style="color:#666666">+</span> ((<span style="color:#B00040">int64_t</span>) (source <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>) <span style="color:#666666"><span style="white-space: pre-wrap;">&lt;&lt;</span></span> <span style="color:#666666">48</span>)<br>
<tt><span style="white-space: pre-wrap;">                         </span></tt><span style="color:#666666">+</span> ((<span style="color:#B00040">int64_t</span>) (source <span style="white-space: pre-wrap;">[</span><span style="color:#666666">2</span><span style="white-space: pre-wrap;">]</span>) <span style="color:#666666"><span style="white-space: pre-wrap;">&lt;&lt;</span></span> <span style="color:#666666">40</span>)<br>
<tt><span style="white-space: pre-wrap;">                         </span></tt><span style="color:#666666">+</span> ((<span style="color:#B00040">int64_t</span>) (source <span style="white-space: pre-wrap;">[</span><span style="color:#666666">3</span><span style="white-space: pre-wrap;">]</span>) <span style="color:#666666"><span style="white-space: pre-wrap;">&lt;&lt;</span></span> <span style="color:#666666">32</span>)<br>
<tt><span style="white-space: pre-wrap;">                         </span></tt><span style="color:#666666">+</span> ((<span style="color:#B00040">int64_t</span>) (source <span style="white-space: pre-wrap;">[</span><span style="color:#666666">4</span><span style="white-space: pre-wrap;">]</span>) <span style="color:#666666"><span style="white-space: pre-wrap;">&lt;&lt;</span></span> <span style="color:#666666">24</span>)<br>
<tt><span style="white-space: pre-wrap;">                         </span></tt><span style="color:#666666">+</span> ((<span style="color:#B00040">int64_t</span>) (source <span style="white-space: pre-wrap;">[</span><span style="color:#666666">5</span><span style="white-space: pre-wrap;">]</span>) <span style="color:#666666"><span style="white-space: pre-wrap;">&lt;&lt;</span></span> <span style="color:#666666">16</span>)<br>
<tt><span style="white-space: pre-wrap;">                         </span></tt><span style="color:#666666">+</span> ((<span style="color:#B00040">int64_t</span>) (source <span style="white-space: pre-wrap;">[</span><span style="color:#666666">6</span><span style="white-space: pre-wrap;">]</span>) <span style="color:#666666"><span style="white-space: pre-wrap;">&lt;&lt;</span></span> <span style="color:#666666">8</span>)<br>
<tt><span style="white-space: pre-wrap;">                         </span></tt><span style="color:#666666">+</span><tt><span style="white-space: pre-wrap;">  </span></tt>(<span style="color:#B00040">int64_t</span>) (source <span style="white-space: pre-wrap;">[</span><span style="color:#666666">7</span><span style="white-space: pre-wrap;">]</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>return</strong></span> sequence;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Set message sequence number</em></span><br>
<span style="color:#B00040">void</span><br>
<span style="color:#0000FF">kvmsg_set_sequence</span> (kvmsg_t <span style="color:#666666">*</span>self, <span style="color:#B00040">int64_t</span> sequence)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_msg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> <span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>frame <span style="white-space: pre-wrap;">[</span>FRAME_SEQ<span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>FRAME_SEQ<span style="white-space: pre-wrap;">]</span>)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_msg_close (msg);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_msg_init_size (msg, <span style="color:#666666">8</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>byte <span style="color:#666666">*</span>source <span style="color:#666666">=</span> zmq_msg_data (msg);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>source <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span> <span style="color:#666666">=</span> (byte) ((sequence <span style="color:#666666"><span style="white-space: pre-wrap;">&gt;&gt;</span></span> <span style="color:#666666">56</span>) <span style="color:#666666">&amp;</span> <span style="color:#666666">255</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>source <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span> <span style="color:#666666">=</span> (byte) ((sequence <span style="color:#666666"><span style="white-space: pre-wrap;">&gt;&gt;</span></span> <span style="color:#666666">48</span>) <span style="color:#666666">&amp;</span> <span style="color:#666666">255</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>source <span style="white-space: pre-wrap;">[</span><span style="color:#666666">2</span><span style="white-space: pre-wrap;">]</span> <span style="color:#666666">=</span> (byte) ((sequence <span style="color:#666666"><span style="white-space: pre-wrap;">&gt;&gt;</span></span> <span style="color:#666666">40</span>) <span style="color:#666666">&amp;</span> <span style="color:#666666">255</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>source <span style="white-space: pre-wrap;">[</span><span style="color:#666666">3</span><span style="white-space: pre-wrap;">]</span> <span style="color:#666666">=</span> (byte) ((sequence <span style="color:#666666"><span style="white-space: pre-wrap;">&gt;&gt;</span></span> <span style="color:#666666">32</span>) <span style="color:#666666">&amp;</span> <span style="color:#666666">255</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>source <span style="white-space: pre-wrap;">[</span><span style="color:#666666">4</span><span style="white-space: pre-wrap;">]</span> <span style="color:#666666">=</span> (byte) ((sequence <span style="color:#666666"><span style="white-space: pre-wrap;">&gt;&gt;</span></span> <span style="color:#666666">24</span>) <span style="color:#666666">&amp;</span> <span style="color:#666666">255</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>source <span style="white-space: pre-wrap;">[</span><span style="color:#666666">5</span><span style="white-space: pre-wrap;">]</span> <span style="color:#666666">=</span> (byte) ((sequence <span style="color:#666666"><span style="white-space: pre-wrap;">&gt;&gt;</span></span> <span style="color:#666666">16</span>) <span style="color:#666666">&amp;</span> <span style="color:#666666">255</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>source <span style="white-space: pre-wrap;">[</span><span style="color:#666666">6</span><span style="white-space: pre-wrap;">]</span> <span style="color:#666666">=</span> (byte) ((sequence <span style="color:#666666"><span style="white-space: pre-wrap;">&gt;&gt;</span></span> <span style="color:#666666">8</span>)<tt><span style="white-space: pre-wrap;">  </span></tt><span style="color:#666666">&amp;</span> <span style="color:#666666">255</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>source <span style="white-space: pre-wrap;">[</span><span style="color:#666666">7</span><span style="white-space: pre-wrap;">]</span> <span style="color:#666666">=</span> (byte) ((sequence)<tt><span style="white-space: pre-wrap;">       </span></tt><span style="color:#666666">&amp;</span> <span style="color:#666666">255</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>FRAME_SEQ<span style="white-space: pre-wrap;">]</span> <span style="color:#666666">=</span> <span style="color:#666666">1</span>;<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Return body from last read message, if any, else NULL</em></span><br>
byte <span style="color:#666666">*</span><br>
<span style="color:#0000FF">kvmsg_body</span> (kvmsg_t <span style="color:#666666">*</span>self)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>FRAME_BODY<span style="white-space: pre-wrap;">]</span>)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>return</strong></span> (byte <span style="color:#666666">*</span>) zmq_msg_data (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>frame <span style="white-space: pre-wrap;">[</span>FRAME_BODY<span style="white-space: pre-wrap;">]</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#008000">NULL</span>;<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Set message body</em></span><br>
<span style="color:#B00040">void</span><br>
<span style="color:#0000FF">kvmsg_set_body</span> (kvmsg_t <span style="color:#666666">*</span>self, byte <span style="color:#666666">*</span>body, <span style="color:#B00040">size_t</span> size)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_msg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> <span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>frame <span style="white-space: pre-wrap;">[</span>FRAME_BODY<span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>FRAME_BODY<span style="white-space: pre-wrap;">]</span>)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_msg_close (msg);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>FRAME_BODY<span style="white-space: pre-wrap;">]</span> <span style="color:#666666">=</span> <span style="color:#666666">1</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_msg_init_size (msg, size);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>memcpy (zmq_msg_data (msg), body, size);<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Set message body using printf format</em></span><br>
<span style="color:#B00040">void</span><br>
<span style="color:#0000FF">kvmsg_fmt_body</span> (kvmsg_t <span style="color:#666666">*</span>self, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>format, …)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> value <span style="white-space: pre-wrap;">[</span><span style="color:#666666">255</span> <span style="color:#666666">+</span> <span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">va_list</span> args;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>va_start (args, format);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>vsnprintf (value, <span style="color:#666666">255</span>, format, args);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>va_end (args);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_set_body (self, (byte <span style="color:#666666">*</span>) value, strlen (value));<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Return body size from last read message, if any, else zero</em></span><br>
<span style="color:#B00040">size_t</span><br>
<span style="color:#0000FF">kvmsg_size</span> (kvmsg_t <span style="color:#666666">*</span>self)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>FRAME_BODY<span style="white-space: pre-wrap;">]</span>)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>return</strong></span> zmq_msg_size (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>frame <span style="white-space: pre-wrap;">[</span>FRAME_BODY<span style="white-space: pre-wrap;">]</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>These methods get and set the UUID for the key-value message:</em></span></p>
<p>byte <span style="color:#666666">*</span><br>
<span style="color:#0000FF">kvmsg_uuid</span> (kvmsg_t <span style="color:#666666">*</span>self)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>FRAME_UUID<span style="white-space: pre-wrap;">]</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#666666">&amp;&amp;</span><tt><span style="white-space: pre-wrap;">  </span></tt>zmq_msg_size (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>frame <span style="white-space: pre-wrap;">[</span>FRAME_UUID<span style="white-space: pre-wrap;">]</span>) <span style="color:#666666">==</span> <span style="color:#008000"><strong>sizeof</strong></span> (uuid_t))<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>return</strong></span> (byte <span style="color:#666666">*</span>) zmq_msg_data (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>frame <span style="white-space: pre-wrap;">[</span>FRAME_UUID<span style="white-space: pre-wrap;">]</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#008000">NULL</span>;<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Sets the UUID to a randomly generated value</em></span><br>
<span style="color:#B00040">void</span><br>
<span style="color:#0000FF">kvmsg_set_uuid</span> (kvmsg_t <span style="color:#666666">*</span>self)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_msg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> <span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>frame <span style="white-space: pre-wrap;">[</span>FRAME_UUID<span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>uuid_t uuid;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>uuid_generate (uuid);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>FRAME_UUID<span style="white-space: pre-wrap;">]</span>)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_msg_close (msg);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_msg_init_size (msg, <span style="color:#008000"><strong>sizeof</strong></span> (uuid));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>memcpy (zmq_msg_data (msg), uuid, <span style="color:#008000"><strong>sizeof</strong></span> (uuid));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>FRAME_UUID<span style="white-space: pre-wrap;">]</span> <span style="color:#666666">=</span> <span style="color:#666666">1</span>;<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>These methods get and set a specified message property:</em></span></p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Get message property, return "" if no such property is defined.</em></span><br>
<span style="color:#B00040">char</span> <span style="color:#666666">*</span><br>
<span style="color:#0000FF">kvmsg_get_prop</span> (kvmsg_t <span style="color:#666666">*</span>self, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>name)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (strchr (name, <span style="color:#BA2121">'='</span>) <span style="color:#666666">==</span> <span style="color:#008000">NULL</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>prop <span style="color:#666666">=</span> zlist_first (self<span style="color:#666666">-&gt;</span>props);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">size_t</span> namelen <span style="color:#666666">=</span> strlen (name);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (prop) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (strlen (prop) <span style="color:#666666">&gt;</span> namelen<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#666666">&amp;&amp;</span><tt><span style="white-space: pre-wrap;">  </span></tt>memcmp (prop, name, namelen) <span style="color:#666666">==</span> <span style="color:#666666">0</span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#666666">&amp;&amp;</span><tt><span style="white-space: pre-wrap;">  </span></tt>prop <span style="white-space: pre-wrap;">[</span>namelen<span style="white-space: pre-wrap;">]</span> <span style="color:#666666">==</span> <span style="color:#BA2121">'='</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>return</strong></span> prop <span style="color:#666666">+</span> namelen <span style="color:#666666">+</span> <span style="color:#666666">1</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>prop <span style="color:#666666">=</span> zlist_next (self<span style="color:#666666">-&gt;</span>props);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#BA2121">""</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Set message property. Property name cannot contain '='. Max length of<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>value is 255 chars.</span></span><br>
<span style="color:#B00040">void</span><br>
<span style="color:#0000FF">kvmsg_set_prop</span> (kvmsg_t <span style="color:#666666">*</span>self, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>name, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>format, …)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (strchr (name, <span style="color:#BA2121">'='</span>) <span style="color:#666666">==</span> <span style="color:#008000">NULL</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> value <span style="white-space: pre-wrap;">[</span><span style="color:#666666">255</span> <span style="color:#666666">+</span> <span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">va_list</span> args;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>va_start (args, format);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>vsnprintf (value, <span style="color:#666666">255</span>, format, args);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>va_end (args);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Allocate name=value string</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>prop <span style="color:#666666">=</span> malloc (strlen (name) <span style="color:#666666">+</span> strlen (value) <span style="color:#666666">+</span> <span style="color:#666666">2</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Remove existing property if any</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>sprintf (prop, <span style="color:#BA2121">"%s="</span>, name);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>existing <span style="color:#666666">=</span> zlist_first (self<span style="color:#666666">-&gt;</span>props);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (existing) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (memcmp (prop, existing, strlen (prop)) <span style="color:#666666">==</span> <span style="color:#666666">0</span>) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>self<span style="color:#666666">-&gt;</span>props_size <span style="color:#666666">-=</span> strlen (existing) <span style="color:#666666">+</span> <span style="color:#666666">1</span>;<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zlist_remove (self<span style="color:#666666">-&gt;</span>props, existing);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>free (existing);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>existing <span style="color:#666666">=</span> zlist_next (self<span style="color:#666666">-&gt;</span>props);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Add new name=value property string</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>strcat (prop, value);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zlist_append (self<span style="color:#666666">-&gt;</span>props, prop);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>props_size <span style="color:#666666">+=</span> strlen (prop) <span style="color:#666666">+</span> <span style="color:#666666">1</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This method stores the key-value message into a hash map, unless<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>the key and value are both null. It nullifies the <tt>kvmsg</tt> reference<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>so that the object is owned by the hash map, not the caller:</span></span></p>
<p><span style="color:#B00040">void</span><br>
<span style="color:#0000FF">kvmsg_store</span> (kvmsg_t <span style="color:#666666"><span style="white-space: pre-wrap;">**</span></span>self_p, zhash_t <span style="color:#666666">*</span>hash)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self_p);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">*</span>self_p) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> <span style="color:#666666">*</span>self_p;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (kvmsg_size (self)) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>FRAME_KEY<span style="white-space: pre-wrap;">]</span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#666666">&amp;&amp;</span><tt><span style="white-space: pre-wrap;">  </span></tt>self<span style="color:#666666">-&gt;</span>present <span style="white-space: pre-wrap;">[</span>FRAME_BODY<span style="white-space: pre-wrap;">]</span>) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zhash_update (hash, kvmsg_key (self), self);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zhash_freefn (hash, kvmsg_key (self), kvmsg_free);<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zhash_delete (hash, kvmsg_key (self));</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#666666">*</span>self_p <span style="color:#666666">=</span> <span style="color:#008000">NULL</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This method extends the <tt>kvsimple</tt> implementation with support for<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>message properties:</span></span></p>
<p><span style="color:#B00040">void</span><br>
<span style="color:#0000FF">kvmsg_dump</span> (kvmsg_t <span style="color:#666666">*</span>self)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>self) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>fprintf (stderr, <span style="color:#BA2121">"NULL"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>return</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">size_t</span> size <span style="color:#666666">=</span> kvmsg_size (self);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>byte<tt><span style="white-space: pre-wrap;">  </span></tt><span style="color:#666666">*</span>body <span style="color:#666666">=</span> kvmsg_body (self);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>fprintf (stderr, <span style="color:#BA2121">"<span style="white-space: pre-wrap;">[</span>seq:%"</span> PRId64 <span style="color:#BA2121">"<span style="white-space: pre-wrap;">]</span>"</span>, kvmsg_sequence (self));<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>fprintf (stderr, <span style="color:#BA2121">"<span style="white-space: pre-wrap;">[</span>key:%s<span style="white-space: pre-wrap;">]</span>"</span>, kvmsg_key (self));<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>fprintf (stderr, <span style="color:#BA2121">"<span style="white-space: pre-wrap;">[</span>size:%zd<span style="white-space: pre-wrap;">]</span> "</span>, size);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (zlist_size (self<span style="color:#666666">-&gt;</span>props)) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>fprintf (stderr, <span style="color:#BA2121">"<span style="white-space: pre-wrap;">[</span>"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>prop <span style="color:#666666">=</span> zlist_first (self<span style="color:#666666">-&gt;</span>props);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>while</strong></span> (prop) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>fprintf (stderr, <span style="color:#BA2121">"%s;"</span>, prop);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>prop <span style="color:#666666">=</span> zlist_next (self<span style="color:#666666">-&gt;</span>props);<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>fprintf (stderr, <span style="color:#BA2121">"<span style="white-space: pre-wrap;">]</span>"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> char_nbr;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>for</strong></span> (char_nbr <span style="color:#666666">=</span> <span style="color:#666666">0</span>; char_nbr <span style="color:#666666">&lt;</span> size; char_nbr<span style="color:#666666">++</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>fprintf (stderr, <span style="color:#BA2121">"%02X"</span>, body <span style="white-space: pre-wrap;">[</span>char_nbr<span style="white-space: pre-wrap;">]</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>fprintf (stderr, <span style="color:#BA2121">"</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>fprintf (stderr, <span style="color:#BA2121">"NULL message</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This method is the same as in <tt>kvsimple</tt> with added support<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>for the uuid and property features of <tt>kvmsg</tt>:</span></span></p>
<p><span style="color:#B00040">int</span><br>
<span style="color:#0000FF">kvmsg_test</span> (<span style="color:#B00040">int</span> verbose)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_t<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#666666">*</span>kvmsg;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">" * kvmsg: "</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Prepare our context and sockets</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>output <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_DEALER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> rc <span style="color:#666666">=</span> zmq_bind (output, <span style="color:#BA2121">"ipc:<span style="white-space: pre-wrap;">//</span>kvmsg_selftest.ipc"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (rc <span style="color:#666666">==</span> <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>input <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_DEALER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>rc <span style="color:#666666">=</span> zmq_connect (input, <span style="color:#BA2121">"ipc:<span style="white-space: pre-wrap;">//</span>kvmsg_selftest.ipc"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (rc <span style="color:#666666">==</span> <span style="color:#666666">0</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zhash_t <span style="color:#666666">*</span>kvmap <span style="color:#666666">=</span> zhash_new ();</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Test send and receive of simple message</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg <span style="color:#666666">=</span> kvmsg_new (<span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_set_key<tt><span style="white-space: pre-wrap;">  </span></tt>(kvmsg, <span style="color:#BA2121">"key"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_set_uuid (kvmsg);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_set_body (kvmsg, (byte <span style="color:#666666">*</span>) <span style="color:#BA2121">"body"</span>, <span style="color:#666666">4</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (verbose)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_dump (kvmsg);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_send (kvmsg, output);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_store (<span style="color:#666666">&amp;</span>kvmsg, kvmap);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg <span style="color:#666666">=</span> kvmsg_recv (input);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (verbose)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_dump (kvmsg);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (streq (kvmsg_key (kvmsg), <span style="color:#BA2121">"key"</span>));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_store (<span style="color:#666666">&amp;</span>kvmsg, kvmap);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Test send and receive of message with properties</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg <span style="color:#666666">=</span> kvmsg_new (<span style="color:#666666">2</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_set_prop (kvmsg, <span style="color:#BA2121">"prop1"</span>, <span style="color:#BA2121">"value1"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_set_prop (kvmsg, <span style="color:#BA2121">"prop2"</span>, <span style="color:#BA2121">"value1"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_set_prop (kvmsg, <span style="color:#BA2121">"prop2"</span>, <span style="color:#BA2121">"value2"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_set_key<tt><span style="white-space: pre-wrap;">  </span></tt>(kvmsg, <span style="color:#BA2121">"key"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_set_uuid (kvmsg);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_set_body (kvmsg, (byte <span style="color:#666666">*</span>) <span style="color:#BA2121">"body"</span>, <span style="color:#666666">4</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (streq (kvmsg_get_prop (kvmsg, <span style="color:#BA2121">"prop2"</span>), <span style="color:#BA2121">"value2"</span>));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (verbose)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_dump (kvmsg);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_send (kvmsg, output);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_destroy (<span style="color:#666666">&amp;</span>kvmsg);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg <span style="color:#666666">=</span> kvmsg_recv (input);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (verbose)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_dump (kvmsg);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (streq (kvmsg_key (kvmsg), <span style="color:#BA2121">"key"</span>));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (streq (kvmsg_get_prop (kvmsg, <span style="color:#BA2121">"prop2"</span>), <span style="color:#BA2121">"value2"</span>));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_destroy (<span style="color:#666666">&amp;</span>kvmsg);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Shutdown and destroy all objects</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zhash_destroy (<span style="color:#666666">&amp;</span>kvmap);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"OK</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/java:kvmsg" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/py:kvmsg" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/tcl:kvmsg" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | C# | Clojure | CL | Delphi | Erlang | F# | Felix | Go | Haskell | Haxe | Lua | Node.js | Objective-C | ooc | Perl | PHP | Q | Racket | Ruby | Scala</a></span>
<p>The Model Five client is almost identical to Model Four. It uses the full <tt>kvmsg</tt> class now, and sets a randomized <tt>ttl</tt> property (measured in seconds) on each message:</p>
<div class="code">
<p>kvmsg_set_prop (kvmsg, <span style="color:#BA2121">"ttl"</span>, <span style="color:#BA2121">"%d"</span>, randof (<span style="color:#666666">30</span>));</p>
</div>
<p><a name="Using-a-Reactor"></a><a name="header-127"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc126"><span><a href="http://zguide.zeromq.org/page:all#Using-a-Reactor">Using a Reactor</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-126">prev</a> <a href="http://zguide.zeromq.org/page:all#header-128">next</a></td>
</tr>
</tbody></table>
<p>Until now, we have used a poll loop in the server. In this next model of the server, we switch to using a reactor. In C, we use CZMQ's <tt>zloop</tt> class. Using a reactor makes the code more verbose, but easier to understand and build out because each piece of the server is handled by a separate reactor handler.</p>
<p>We use a single thread and pass a server object around to the reactor handlers. We could have organized the server as multiple threads, each handling one socket or timer, but that works better when threads don't have to share data. In this case all work is centered around the server's hashmap, so one thread is simpler.</p>
<p>There are three reactor handlers:</p>
<ul>
<li>One to handle snapshot requests coming on the ROUTER socket;</li>
<li>One to handle incoming updates from clients, coming on the PULL socket;</li>
<li>One to expire ephemeral values that have passed their TTL.</li>
</ul>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">clonesrv5:&nbsp;Clone&nbsp;server,&nbsp;Model&nbsp;Five&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">clonesrv5:&nbsp;Clone&nbsp;server,&nbsp;Model&nbsp;Five&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Clone server - Model Five</span></p>
<p><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Lets us build this source without creating a library<br>
#include "kvmsg.c"</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>zloop reactor handlers</em></span><br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">int</span> s_snapshots (zloop_t <span style="color:#666666">*</span>loop, zmq_pollitem_t <span style="color:#666666">*</span>poller, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>args);<br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">int</span> s_collector (zloop_t <span style="color:#666666">*</span>loop, zmq_pollitem_t <span style="color:#666666">*</span>poller, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>args);<br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">int</span> s_flush_ttl (zloop_t <span style="color:#666666">*</span>loop, <span style="color:#B00040">int</span> timer_id, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>args);</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Our server is defined by these properties</em></span><br>
<span style="color:#008000"><strong>typedef</strong></span> <span style="color:#008000"><strong>struct</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx;<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Context wrapper</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zhash_t <span style="color:#666666">*</span>kvmap;<tt><span style="white-space: pre-wrap;">             </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Key-value store</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zloop_t <span style="color:#666666">*</span>loop;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>zloop reactor</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> port;<tt><span style="white-space: pre-wrap;">                   </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Main port we're working on</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int64_t</span> sequence;<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>How many updates we're at</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>snapshot;<tt><span style="white-space: pre-wrap;">             </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Handle snapshot requests</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>publisher;<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Publish updates to clients</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>collector;<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Collect updates from clients</em></span><br>
} clonesrv_t;</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>clonesrv_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> (clonesrv_t <span style="color:#666666">*</span>) zmalloc (<span style="color:#008000"><strong>sizeof</strong></span> (clonesrv_t));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>port <span style="color:#666666">=</span> <span style="color:#666666">5556</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>kvmap <span style="color:#666666">=</span> zhash_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>loop <span style="color:#666666">=</span> zloop_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zloop_set_verbose (self<span style="color:#666666">-&gt;</span>loop, <span style="color:#008000">false</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Set up our clone server sockets</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>snapshot<tt><span style="white-space: pre-wrap;">  </span></tt><span style="color:#666666">=</span> zsocket_new (self<span style="color:#666666">-&gt;</span>ctx, ZMQ_ROUTER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (self<span style="color:#666666">-&gt;</span>snapshot,<tt><span style="white-space: pre-wrap;">  </span></tt><span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:%d"</span>, self<span style="color:#666666">-&gt;</span>port);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>publisher <span style="color:#666666">=</span> zsocket_new (self<span style="color:#666666">-&gt;</span>ctx, ZMQ_PUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (self<span style="color:#666666">-&gt;</span>publisher, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:%d"</span>, self<span style="color:#666666">-&gt;</span>port <span style="color:#666666">+</span> <span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>collector <span style="color:#666666">=</span> zsocket_new (self<span style="color:#666666">-&gt;</span>ctx, ZMQ_PULL);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (self<span style="color:#666666">-&gt;</span>collector, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:%d"</span>, self<span style="color:#666666">-&gt;</span>port <span style="color:#666666">+</span> <span style="color:#666666">2</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Register our handlers with reactor</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_pollitem_t poller <span style="color:#666666">=</span> { <span style="color:#666666">0</span>, <span style="color:#666666">0</span>, ZMQ_POLLIN };<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>poller.socket <span style="color:#666666">=</span> self<span style="color:#666666">-&gt;</span>snapshot;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zloop_poller (self<span style="color:#666666">-&gt;</span>loop, <span style="color:#666666">&amp;</span>poller, s_snapshots, self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>poller.socket <span style="color:#666666">=</span> self<span style="color:#666666">-&gt;</span>collector;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zloop_poller (self<span style="color:#666666">-&gt;</span>loop, <span style="color:#666666">&amp;</span>poller, s_collector, self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zloop_timer (self<span style="color:#666666">-&gt;</span>loop, <span style="color:#666666">1000</span>, <span style="color:#666666">0</span>, s_flush_ttl, self);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Run reactor until process interrupted</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zloop_start (self<span style="color:#666666">-&gt;</span>loop);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zloop_destroy (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>loop);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zhash_destroy (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>kvmap);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>free (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We handle ICANHAZ? requests by sending snapshot data to the<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>client that requested it:</span></span></p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Routing information for a key-value snapshot</em></span><br>
<span style="color:#008000"><strong>typedef</strong></span> <span style="color:#008000"><strong>struct</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>socket;<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>ROUTER socket to send to</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zframe_t <span style="color:#666666">*</span>identity;<tt><span style="white-space: pre-wrap;">     </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Identity of peer who requested state</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>subtree;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Client subtree specification</em></span><br>
} kvroute_t;</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We call this function for each key-value pair in our hash table</em></span><br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">int</span><br>
<span style="color:#0000FF">s_send_single</span> (<span style="color:#008000"><strong>const</strong></span> <span style="color:#B00040">char</span> <span style="color:#666666">*</span>key, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>data, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>args)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvroute_t <span style="color:#666666">*</span>kvroute <span style="color:#666666">=</span> (kvroute_t <span style="color:#666666">*</span>) args;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_t <span style="color:#666666">*</span>kvmsg <span style="color:#666666">=</span> (kvmsg_t <span style="color:#666666">*</span>) data;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (strlen (kvroute<span style="color:#666666">-&gt;</span>subtree) <span style="color:#666666">&lt;=</span> strlen (kvmsg_key (kvmsg))<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#666666">&amp;&amp;</span><tt><span style="white-space: pre-wrap;">  </span></tt>memcmp (kvroute<span style="color:#666666">-&gt;</span>subtree,<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>kvmsg_key (kvmsg), strlen (kvroute<span style="color:#666666">-&gt;</span>subtree)) <span style="color:#666666">==</span> <span style="color:#666666">0</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_send (<span style="color:#666666">&amp;</span>kvroute<span style="color:#666666">-&gt;</span>identity,<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Choose recipient</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvroute<span style="color:#666666">-&gt;</span>socket, ZFRAME_MORE <span style="color:#666666">+</span> ZFRAME_REUSE);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_send (kvmsg, kvroute<span style="color:#666666">-&gt;</span>socket);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This is the reactor handler for the snapshot socket; it accepts<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>just the ICANHAZ? request and replies with a state snapshot ending<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>with a KTHXBAI message:</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">int</span><br>
<span style="color:#0000FF">s_snapshots</span> (zloop_t <span style="color:#666666">*</span>loop, zmq_pollitem_t <span style="color:#666666">*</span>poller, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>args)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>clonesrv_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> (clonesrv_t <span style="color:#666666">*</span>) args;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zframe_t <span style="color:#666666">*</span>identity <span style="color:#666666">=</span> zframe_recv (poller<span style="color:#666666">-&gt;</span>socket);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (identity) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Request is in second frame of message</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>request <span style="color:#666666">=</span> zstr_recv (poller<span style="color:#666666">-&gt;</span>socket);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>subtree <span style="color:#666666">=</span> <span style="color:#008000">NULL</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (streq (request, <span style="color:#BA2121">"ICANHAZ?"</span>)) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>free (request);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>subtree <span style="color:#666666">=</span> zstr_recv (poller<span style="color:#666666">-&gt;</span>socket);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"E: bad request, aborting</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (subtree) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send state socket to client</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvroute_t routing <span style="color:#666666">=</span> { poller<span style="color:#666666">-&gt;</span>socket, identity, subtree };<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zhash_foreach (self<span style="color:#666666">-&gt;</span>kvmap, s_send_single, <span style="color:#666666">&amp;</span>routing);</p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Now send END message with sequence number</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zclock_log (<span style="color:#BA2121">"I: sending shapshot=%d"</span>, (<span style="color:#B00040">int</span>) self<span style="color:#666666">-&gt;</span>sequence);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_send (<span style="color:#666666">&amp;</span>identity, poller<span style="color:#666666">-&gt;</span>socket, ZFRAME_MORE);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_t <span style="color:#666666">*</span>kvmsg <span style="color:#666666">=</span> kvmsg_new (self<span style="color:#666666">-&gt;</span>sequence);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_set_key<tt><span style="white-space: pre-wrap;">  </span></tt>(kvmsg, <span style="color:#BA2121">"KTHXBAI"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_set_body (kvmsg, (byte <span style="color:#666666">*</span>) subtree, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_send<tt><span style="white-space: pre-wrap;">     </span></tt>(kvmsg, poller<span style="color:#666666">-&gt;</span>socket);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_destroy (<span style="color:#666666">&amp;</span>kvmsg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>free (subtree);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_destroy(<span style="color:#666666">&amp;</span>identity);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We store each update with a new sequence number, and if necessary, a<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>time-to-live. We publish updates immediately on our publisher socket:</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">int</span><br>
<span style="color:#0000FF">s_collector</span> (zloop_t <span style="color:#666666">*</span>loop, zmq_pollitem_t <span style="color:#666666">*</span>poller, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>args)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>clonesrv_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> (clonesrv_t <span style="color:#666666">*</span>) args;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_t <span style="color:#666666">*</span>kvmsg <span style="color:#666666">=</span> kvmsg_recv (poller<span style="color:#666666">-&gt;</span>socket);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (kvmsg) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_set_sequence (kvmsg, <span style="color:#666666">++</span>self<span style="color:#666666">-&gt;</span>sequence);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_send (kvmsg, self<span style="color:#666666">-&gt;</span>publisher);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> ttl <span style="color:#666666">=</span> atoi (kvmsg_get_prop (kvmsg, <span style="color:#BA2121">"ttl"</span>));<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (ttl)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_set_prop (kvmsg, <span style="color:#BA2121">"ttl"</span>,<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#BA2121">"%"</span> PRId64, zclock_time () <span style="color:#666666">+</span> ttl <span style="color:#666666">*</span> <span style="color:#666666">1000</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_store (<span style="color:#666666">&amp;</span>kvmsg, self<span style="color:#666666">-&gt;</span>kvmap);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zclock_log (<span style="color:#BA2121">"I: publishing update=%d"</span>, (<span style="color:#B00040">int</span>) self<span style="color:#666666">-&gt;</span>sequence);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>At regular intervals, we flush ephemeral values that have expired. This<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>could be slow on very large data sets:</span></span></p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If key-value pair has expired, delete it and publish the<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>fact to listening clients.</span></span><br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">int</span><br>
<span style="color:#0000FF">s_flush_single</span> (<span style="color:#008000"><strong>const</strong></span> <span style="color:#B00040">char</span> <span style="color:#666666">*</span>key, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>data, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>args)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>clonesrv_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> (clonesrv_t <span style="color:#666666">*</span>) args;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_t <span style="color:#666666">*</span>kvmsg <span style="color:#666666">=</span> (kvmsg_t <span style="color:#666666">*</span>) data;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int64_t</span> ttl;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>sscanf (kvmsg_get_prop (kvmsg, <span style="color:#BA2121">"ttl"</span>), <span style="color:#BA2121">"%"</span> PRId64, <span style="color:#666666">&amp;</span>ttl);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (ttl <span style="color:#666666">&amp;&amp;</span> zclock_time () <span style="color:#666666">&gt;=</span> ttl) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_set_sequence (kvmsg, <span style="color:#666666">++</span>self<span style="color:#666666">-&gt;</span>sequence);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_set_body (kvmsg, (byte <span style="color:#666666">*</span>) <span style="color:#BA2121">""</span>, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_send (kvmsg, self<span style="color:#666666">-&gt;</span>publisher);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_store (<span style="color:#666666">&amp;</span>kvmsg, self<span style="color:#666666">-&gt;</span>kvmap);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zclock_log (<span style="color:#BA2121">"I: publishing delete=%d"</span>, (<span style="color:#B00040">int</span>) self<span style="color:#666666">-&gt;</span>sequence);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">int</span><br>
<span style="color:#0000FF">s_flush_ttl</span> (zloop_t <span style="color:#666666">*</span>loop, <span style="color:#B00040">int</span> timer_id, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>args)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>clonesrv_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> (clonesrv_t <span style="color:#666666">*</span>) args;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>kvmap)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zhash_foreach (self<span style="color:#666666">-&gt;</span>kvmap, s_flush_single, args);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/java:clonesrv5" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/py:clonesrv5" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/tcl:clonesrv5" target="_blank">Tcl</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | C# | Clojure | CL | Delphi | Erlang | F# | Felix | Go | Haskell | Haxe | Lua | Node.js | Objective-C | ooc | Perl | PHP | Q | Racket | Ruby | Scala</a></span>
<p><a name="Adding-the-Binary-Star-Pattern-for-Reliability"></a><a name="header-128"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc127"><span><a href="http://zguide.zeromq.org/page:all#Adding-the-Binary-Star-Pattern-for-Reliability">Adding the Binary Star Pattern for Reliability</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-127">prev</a> <a href="http://zguide.zeromq.org/page:all#header-129">next</a></td>
</tr>
</tbody></table>
<p>The Clone models we've explored up to now have been relatively simple. Now we're going to get into unpleasantly complex territory, which has me getting up for another espresso. You should appreciate that making "reliable" messaging is complex enough that you always need to ask, "Do we actually need this?" before jumping into it. If you can get away with unreliable or with "good enough" reliability, you can make a huge win in terms of cost and complexity. Sure, you may lose some data now and then. It is often a good trade-off. Having said, that, and… sips… because the espresso is really good, let's jump in.</p>
<p>As you play with the last model, you'll stop and restart the server. It might look like it recovers, but of course it's applying updates to an empty state instead of the proper current state. Any new client joining the network will only get the latest updates instead of the full historical record.</p>
<p>What we want is a way for the server to recover from being killed, or crashing. We also need to provide backup in case the server is out of commission for any length of time. When someone asks for "reliability", ask them to list the failures they want to handle. In our case, these are:</p>
<ul>
<li>The server process crashes and is automatically or manually restarted. The process loses its state and has to get it back from somewhere.</li>
</ul>
<ul>
<li>The server machine dies and is offline for a significant time. Clients have to switch to an alternate server somewhere.</li>
</ul>
<ul>
<li>The server process or machine gets disconnected from the network, e.g., a switch dies or a datacenter gets knocked out. It may come back at some point, but in the meantime clients need an alternate server.</li>
</ul>
<p>Our first step is to add a second server. We can use the Binary Star pattern from <a href="http://zguide.zeromq.org/page:all#reliable-request-reply">Chapter 4 - Reliable Request-Reply Patterns</a> to organize these into primary and backup. Binary Star is a reactor, so it's useful that we already refactored the last server model into a reactor style.</p>
<p>We need to ensure that updates are not lost if the primary server crashes. The simplest technique is to send them to both servers. The backup server can then act as a client, and keep its state synchronized by receiving updates as all clients do. It'll also get new updates from clients. It can't yet store these in its hash table, but it can hold onto them for a while.</p>
<p>So, Model Six introduces the following changes over Model Five:</p>
<ul>
<li>We use a pub-sub flow instead of a push-pull flow for client updates sent to the servers. This takes care of fanning out the updates to both servers. Otherwise we'd have to use two DEALER sockets.</li>
</ul>
<ul>
<li>We add heartbeats to server updates (to clients), so that a client can detect when the primary server has died. It can then switch over to the backup server.</li>
</ul>
<ul>
<li>We connect the two servers using the Binary Star <tt>bstar</tt> reactor class. Binary Star relies on the clients to vote by making an explicit request to the server they consider active. We'll use snapshot requests as the voting mechanism.</li>
</ul>
<ul>
<li>We make all update messages uniquely identifiable by adding a UUID field. The client generates this, and the server propagates it back on republished updates.</li>
</ul>
<ul>
<li>The passive server keeps a "pending list" of updates that it has received from clients, but not yet from the active server; or updates it's received from the active server, but not yet from the clients. The list is ordered from oldest to newest, so that it is easy to remove updates off the head.</li>
</ul>
<p><strong>Figure 61 - Clone Client Finite State Machine</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig61.png" alt="fig61.png" class="image"></div>
<p>It's useful to design the client logic as a finite state machine. The client cycles through three states:</p>
<ul>
<li>The client opens and connects its sockets, and then requests a snapshot from the first server. To avoid request storms, it will ask any given server only twice. One request might get lost, which would be bad luck. Two getting lost would be carelessness.</li>
</ul>
<ul>
<li>The client waits for a reply (snapshot data) from the current server, and if it gets it, it stores it. If there is no reply within some timeout, it fails over to the next server.</li>
</ul>
<ul>
<li>When the client has gotten its snapshot, it waits for and processes updates. Again, if it doesn't hear anything from the server within some timeout, it fails over to the next server.</li>
</ul>
<p>The client loops forever. It's quite likely during startup or failover that some clients may be trying to talk to the primary server while others are trying to talk to the backup server. The Binary Star state machine handles this, hopefully accurately. It's hard to prove software correct; instead we hammer it until we can't prove it wrong.</p>
<p>Failover happens as follows:</p>
<ul>
<li>The client detects that primary server is no longer sending heartbeats, and concludes that it has died. The client connects to the backup server and requests a new state snapshot.</li>
</ul>
<ul>
<li>The backup server starts to receive snapshot requests from clients, and detects that primary server has gone, so it takes over as primary.</li>
</ul>
<ul>
<li>The backup server applies its pending list to its own hash table, and then starts to process state snapshot requests.</li>
</ul>
<p>When the primary server comes back online, it will:</p>
<ul>
<li>Start up as passive server, and connect to the backup server as a Clone client.</li>
</ul>
<ul>
<li>Start to receive updates from clients, via its SUB socket.</li>
</ul>
<p>We make a few assumptions:</p>
<ul>
<li>At least one server will keep running. If both servers crash, we lose all server state and there's no way to recover it.</li>
</ul>
<ul>
<li>Multiple clients do not update the same hash keys at the same time. Client updates will arrive at the two servers in a different order. Therefore, the backup server may apply updates from its pending list in a different order than the primary server would or did. Updates from one client will always arrive in the same order on both servers, so that is safe.</li>
</ul>
<p>Thus the architecture for our high-availability server pair using the Binary Star pattern has two servers and a set of clients that talk to both servers.</p>
<p><strong>Figure 62 - High-availability Clone Server Pair</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig62.png" alt="fig62.png" class="image"></div>
<p>Here is the sixth and last model of the Clone server:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">clonesrv6:&nbsp;Clone&nbsp;server,&nbsp;Model&nbsp;Six&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">clonesrv6:&nbsp;Clone&nbsp;server,&nbsp;Model&nbsp;Six&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Clone server Model Six</span></p>
<p><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Lets us build this source without creating a library<br>
#include "bstar.c"<br>
#include "kvmsg.c"</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We define a set of reactor handlers and our server object structure:</em></span></p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Bstar reactor handlers</em></span><br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">int</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_snapshots<tt><span style="white-space: pre-wrap;">   </span></tt>(zloop_t <span style="color:#666666">*</span>loop, zmq_pollitem_t <span style="color:#666666">*</span>poller, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>args);<br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">int</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_collector<tt><span style="white-space: pre-wrap;">   </span></tt>(zloop_t <span style="color:#666666">*</span>loop, zmq_pollitem_t <span style="color:#666666">*</span>poller, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>args);<br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">int</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_flush_ttl<tt><span style="white-space: pre-wrap;">   </span></tt>(zloop_t <span style="color:#666666">*</span>loop, <span style="color:#B00040">int</span> timer_id, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>args);<br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">int</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_send_hugz<tt><span style="white-space: pre-wrap;">   </span></tt>(zloop_t <span style="color:#666666">*</span>loop, <span style="color:#B00040">int</span> timer_id, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>args);<br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">int</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_new_active<tt><span style="white-space: pre-wrap;">  </span></tt>(zloop_t <span style="color:#666666">*</span>loop, zmq_pollitem_t <span style="color:#666666">*</span>poller, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>args);<br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">int</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_new_passive (zloop_t <span style="color:#666666">*</span>loop, zmq_pollitem_t <span style="color:#666666">*</span>poller, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>args);<br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">int</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>s_subscriber<tt><span style="white-space: pre-wrap;">  </span></tt>(zloop_t <span style="color:#666666">*</span>loop, zmq_pollitem_t <span style="color:#666666">*</span>poller, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>args);</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Our server is defined by these properties</em></span><br>
<span style="color:#008000"><strong>typedef</strong></span> <span style="color:#008000"><strong>struct</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx;<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Context wrapper</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zhash_t <span style="color:#666666">*</span>kvmap;<tt><span style="white-space: pre-wrap;">             </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Key-value store</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>bstar_t <span style="color:#666666">*</span>bstar;<tt><span style="white-space: pre-wrap;">             </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Bstar reactor core</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int64_t</span> sequence;<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>How many updates we're at</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> port;<tt><span style="white-space: pre-wrap;">                   </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Main port we're working on</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> peer;<tt><span style="white-space: pre-wrap;">                   </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Main port of our peer</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>publisher;<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Publish updates and hugz</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>collector;<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Collect updates from clients</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>subscriber;<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Get updates from peer</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zlist_t <span style="color:#666666">*</span>pending;<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Pending updates from clients</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>bool primary;<tt><span style="white-space: pre-wrap;">               </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>true if we're primary</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>bool active;<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>true if we're active</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>bool passive;<tt><span style="white-space: pre-wrap;">               </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>true if we're passive</em></span><br>
} clonesrv_t;</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The main task parses the command line to decide whether to start<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>as a primary or backup server. We're using the Binary Star pattern<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>for reliability. This interconnects the two servers so they can<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>agree on which one is primary and which one is backup. To allow the<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>two servers to run on the same box, we use different ports for<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>primary and backup. Ports 5003/5004 are used to interconnect the<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>servers. Ports 5556/5566 are used to receive voting events (snapshot<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>requests in the clone pattern). Ports 5557/5567 are used by the<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>publisher, and ports 5558/5568 are used by the collector:</span></span></p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">int</span> argc, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>argv <span style="white-space: pre-wrap;">[]</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>clonesrv_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> (clonesrv_t <span style="color:#666666">*</span>) zmalloc (<span style="color:#008000"><strong>sizeof</strong></span> (clonesrv_t));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (argc <span style="color:#666666">==</span> <span style="color:#666666">2</span> <span style="color:#666666">&amp;&amp;</span> streq (argv <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>, <span style="color:#BA2121">"-p"</span>)) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zclock_log (<span style="color:#BA2121">"I: primary active, waiting for backup (passive)"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>self<span style="color:#666666">-&gt;</span>bstar <span style="color:#666666">=</span> bstar_new (BSTAR_PRIMARY, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5003"</span>,<br>
<tt><span style="white-space: pre-wrap;">                                 </span></tt><span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5004"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>bstar_voter (self<span style="color:#666666">-&gt;</span>bstar, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5556"</span>,<br>
<tt><span style="white-space: pre-wrap;">                     </span></tt>ZMQ_ROUTER, s_snapshots, self);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>self<span style="color:#666666">-&gt;</span>port <span style="color:#666666">=</span> <span style="color:#666666">5556</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>self<span style="color:#666666">-&gt;</span>peer <span style="color:#666666">=</span> <span style="color:#666666">5566</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>self<span style="color:#666666">-&gt;</span>primary <span style="color:#666666">=</span> <span style="color:#008000">true</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (argc <span style="color:#666666">==</span> <span style="color:#666666">2</span> <span style="color:#666666">&amp;&amp;</span> streq (argv <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>, <span style="color:#BA2121">"-b"</span>)) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zclock_log (<span style="color:#BA2121">"I: backup passive, waiting for primary (active)"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>self<span style="color:#666666">-&gt;</span>bstar <span style="color:#666666">=</span> bstar_new (BSTAR_BACKUP, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5004"</span>,<br>
<tt><span style="white-space: pre-wrap;">                                 </span></tt><span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:5003"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>bstar_voter (self<span style="color:#666666">-&gt;</span>bstar, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5566"</span>,<br>
<tt><span style="white-space: pre-wrap;">                     </span></tt>ZMQ_ROUTER, s_snapshots, self);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>self<span style="color:#666666">-&gt;</span>port <span style="color:#666666">=</span> <span style="color:#666666">5566</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>self<span style="color:#666666">-&gt;</span>peer <span style="color:#666666">=</span> <span style="color:#666666">5556</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>self<span style="color:#666666">-&gt;</span>primary <span style="color:#666666">=</span> <span style="color:#008000">false</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>printf (<span style="color:#BA2121">"Usage: clonesrv6 { -p | -b }</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (self);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>exit (<span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Primary server will become first active</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>primary)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>self<span style="color:#666666">-&gt;</span>kvmap <span style="color:#666666">=</span> zhash_new ();</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>pending <span style="color:#666666">=</span> zlist_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>bstar_set_verbose (self<span style="color:#666666">-&gt;</span>bstar, <span style="color:#008000">true</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Set up our clone server sockets</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>publisher <span style="color:#666666">=</span> zsocket_new (self<span style="color:#666666">-&gt;</span>ctx, ZMQ_PUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>collector <span style="color:#666666">=</span> zsocket_new (self<span style="color:#666666">-&gt;</span>ctx, ZMQ_SUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_set_subscribe (self<span style="color:#666666">-&gt;</span>collector, <span style="color:#BA2121">""</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (self<span style="color:#666666">-&gt;</span>publisher, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:%d"</span>, self<span style="color:#666666">-&gt;</span>port <span style="color:#666666">+</span> <span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (self<span style="color:#666666">-&gt;</span>collector, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:%d"</span>, self<span style="color:#666666">-&gt;</span>port <span style="color:#666666">+</span> <span style="color:#666666">2</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Set up our own clone client interface to peer</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>subscriber <span style="color:#666666">=</span> zsocket_new (self<span style="color:#666666">-&gt;</span>ctx, ZMQ_SUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_set_subscribe (self<span style="color:#666666">-&gt;</span>subscriber, <span style="color:#BA2121">""</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect (self<span style="color:#666666">-&gt;</span>subscriber,<br>
<tt><span style="white-space: pre-wrap;">                     </span></tt><span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:%d"</span>, self<span style="color:#666666">-&gt;</span>peer <span style="color:#666666">+</span> <span style="color:#666666">1</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>After we've setup our sockets, we register our binary star</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>event handlers, and then start the bstar reactor. This finishes</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>when the user presses Ctrl-C or when the process receives a SIGINT</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>interrupt:</em></span></p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Register state change handlers</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>bstar_new_active (self<span style="color:#666666">-&gt;</span>bstar, s_new_active, self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>bstar_new_passive (self<span style="color:#666666">-&gt;</span>bstar, s_new_passive, self);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Register our other handlers with the bstar reactor</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_pollitem_t poller <span style="color:#666666">=</span> { self<span style="color:#666666">-&gt;</span>collector, <span style="color:#666666">0</span>, ZMQ_POLLIN };<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zloop_poller (bstar_zloop (self<span style="color:#666666">-&gt;</span>bstar), <span style="color:#666666">&amp;</span>poller, s_collector, self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zloop_timer<tt><span style="white-space: pre-wrap;">  </span></tt>(bstar_zloop (self<span style="color:#666666">-&gt;</span>bstar), <span style="color:#666666">1000</span>, <span style="color:#666666">0</span>, s_flush_ttl, self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zloop_timer<tt><span style="white-space: pre-wrap;">  </span></tt>(bstar_zloop (self<span style="color:#666666">-&gt;</span>bstar), <span style="color:#666666">1000</span>, <span style="color:#666666">0</span>, s_send_hugz, self);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Start the bstar reactor</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>bstar_start (self<span style="color:#666666">-&gt;</span>bstar);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted, so shut down</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (zlist_size (self<span style="color:#666666">-&gt;</span>pending)) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_t <span style="color:#666666">*</span>kvmsg <span style="color:#666666">=</span> (kvmsg_t <span style="color:#666666">*</span>) zlist_pop (self<span style="color:#666666">-&gt;</span>pending);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_destroy (<span style="color:#666666">&amp;</span>kvmsg);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zlist_destroy (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>pending);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>bstar_destroy (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>bstar);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zhash_destroy (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>kvmap);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>free (self);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We handle ICANHAZ? requests exactly as in the clonesrv5 example.</em></span></p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Routing information for a key-value snapshot</em></span><br>
<span style="color:#008000"><strong>typedef</strong></span> <span style="color:#008000"><strong>struct</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>socket;<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>ROUTER socket to send to</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zframe_t <span style="color:#666666">*</span>identity;<tt><span style="white-space: pre-wrap;">     </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Identity of peer who requested state</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>subtree;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Client subtree specification</em></span><br>
} kvroute_t;</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send one state snapshot key-value pair to a socket<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Hash item data is our kvmsg object, ready to send</span></span><br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">int</span><br>
<span style="color:#0000FF">s_send_single</span> (<span style="color:#008000"><strong>const</strong></span> <span style="color:#B00040">char</span> <span style="color:#666666">*</span>key, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>data, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>args)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvroute_t <span style="color:#666666">*</span>kvroute <span style="color:#666666">=</span> (kvroute_t <span style="color:#666666">*</span>) args;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_t <span style="color:#666666">*</span>kvmsg <span style="color:#666666">=</span> (kvmsg_t <span style="color:#666666">*</span>) data;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (strlen (kvroute<span style="color:#666666">-&gt;</span>subtree) <span style="color:#666666">&lt;=</span> strlen (kvmsg_key (kvmsg))<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#666666">&amp;&amp;</span><tt><span style="white-space: pre-wrap;">  </span></tt>memcmp (kvroute<span style="color:#666666">-&gt;</span>subtree,<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>kvmsg_key (kvmsg), strlen (kvroute<span style="color:#666666">-&gt;</span>subtree)) <span style="color:#666666">==</span> <span style="color:#666666">0</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_send (<span style="color:#666666">&amp;</span>kvroute<span style="color:#666666">-&gt;</span>identity,<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Choose recipient</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvroute<span style="color:#666666">-&gt;</span>socket, ZFRAME_MORE <span style="color:#666666">+</span> ZFRAME_REUSE);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_send (kvmsg, kvroute<span style="color:#666666">-&gt;</span>socket);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">int</span><br>
<span style="color:#0000FF">s_snapshots</span> (zloop_t <span style="color:#666666">*</span>loop, zmq_pollitem_t <span style="color:#666666">*</span>poller, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>args)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>clonesrv_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> (clonesrv_t <span style="color:#666666">*</span>) args;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zframe_t <span style="color:#666666">*</span>identity <span style="color:#666666">=</span> zframe_recv (poller<span style="color:#666666">-&gt;</span>socket);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (identity) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Request is in second frame of message</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>request <span style="color:#666666">=</span> zstr_recv (poller<span style="color:#666666">-&gt;</span>socket);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>subtree <span style="color:#666666">=</span> <span style="color:#008000">NULL</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (streq (request, <span style="color:#BA2121">"ICANHAZ?"</span>)) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>free (request);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>subtree <span style="color:#666666">=</span> zstr_recv (poller<span style="color:#666666">-&gt;</span>socket);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>printf (<span style="color:#BA2121">"E: bad request, aborting</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (subtree) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send state socket to client</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvroute_t routing <span style="color:#666666">=</span> { poller<span style="color:#666666">-&gt;</span>socket, identity, subtree };<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zhash_foreach (self<span style="color:#666666">-&gt;</span>kvmap, s_send_single, <span style="color:#666666">&amp;</span>routing);</p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Now send END message with sequence number</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zclock_log (<span style="color:#BA2121">"I: sending shapshot=%d"</span>, (<span style="color:#B00040">int</span>) self<span style="color:#666666">-&gt;</span>sequence);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_send (<span style="color:#666666">&amp;</span>identity, poller<span style="color:#666666">-&gt;</span>socket, ZFRAME_MORE);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_t <span style="color:#666666">*</span>kvmsg <span style="color:#666666">=</span> kvmsg_new (self<span style="color:#666666">-&gt;</span>sequence);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_set_key<tt><span style="white-space: pre-wrap;">  </span></tt>(kvmsg, <span style="color:#BA2121">"KTHXBAI"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_set_body (kvmsg, (byte <span style="color:#666666">*</span>) subtree, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_send<tt><span style="white-space: pre-wrap;">     </span></tt>(kvmsg, poller<span style="color:#666666">-&gt;</span>socket);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_destroy (<span style="color:#666666">&amp;</span>kvmsg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>free (subtree);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_destroy(<span style="color:#666666">&amp;</span>identity);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The collector is more complex than in the clonesrv5 example because the<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>way it processes updates depends on whether we're active or passive.<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The active applies them immediately to its kvmap, whereas the passive<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>queues them as pending:</span></span></p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If message was already on pending list, remove it and return true,<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>else return false.</span></span><br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">int</span><br>
<span style="color:#0000FF">s_was_pending</span> (clonesrv_t <span style="color:#666666">*</span>self, kvmsg_t <span style="color:#666666">*</span>kvmsg)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_t <span style="color:#666666">*</span>held <span style="color:#666666">=</span> (kvmsg_t <span style="color:#666666">*</span>) zlist_first (self<span style="color:#666666">-&gt;</span>pending);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (held) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (memcmp (kvmsg_uuid (kvmsg),<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>kvmsg_uuid (held), <span style="color:#008000"><strong>sizeof</strong></span> (uuid_t)) <span style="color:#666666">==</span> <span style="color:#666666">0</span>) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zlist_remove (self<span style="color:#666666">-&gt;</span>pending, held);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#008000">true</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>held <span style="color:#666666">=</span> (kvmsg_t <span style="color:#666666">*</span>) zlist_next (self<span style="color:#666666">-&gt;</span>pending);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#008000">false</span>;<br>
}</p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">int</span><br>
<span style="color:#0000FF">s_collector</span> (zloop_t <span style="color:#666666">*</span>loop, zmq_pollitem_t <span style="color:#666666">*</span>poller, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>args)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>clonesrv_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> (clonesrv_t <span style="color:#666666">*</span>) args;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_t <span style="color:#666666">*</span>kvmsg <span style="color:#666666">=</span> kvmsg_recv (poller<span style="color:#666666">-&gt;</span>socket);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (kvmsg) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>active) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_set_sequence (kvmsg, <span style="color:#666666">++</span>self<span style="color:#666666">-&gt;</span>sequence);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_send (kvmsg, self<span style="color:#666666">-&gt;</span>publisher);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">int</span> ttl <span style="color:#666666">=</span> atoi (kvmsg_get_prop (kvmsg, <span style="color:#BA2121">"ttl"</span>));<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (ttl)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>kvmsg_set_prop (kvmsg, <span style="color:#BA2121">"ttl"</span>,<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt><span style="color:#BA2121">"%"</span> PRId64, zclock_time () <span style="color:#666666">+</span> ttl <span style="color:#666666">*</span> <span style="color:#666666">1000</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_store (<span style="color:#666666">&amp;</span>kvmsg, self<span style="color:#666666">-&gt;</span>kvmap);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zclock_log (<span style="color:#BA2121">"I: publishing update=%d"</span>, (<span style="color:#B00040">int</span>) self<span style="color:#666666">-&gt;</span>sequence);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If we already got message from active, drop it, else</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>hold on pending list</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (s_was_pending (self, kvmsg))<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>kvmsg_destroy (<span style="color:#666666">&amp;</span>kvmsg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt>zlist_append (self<span style="color:#666666">-&gt;</span>pending, kvmsg);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We purge ephemeral values using exactly the same code as in<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>the previous clonesrv5 example.<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If key-value pair has expired, delete it and publish the<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>fact to listening clients.</span></span><br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">int</span><br>
<span style="color:#0000FF">s_flush_single</span> (<span style="color:#008000"><strong>const</strong></span> <span style="color:#B00040">char</span> <span style="color:#666666">*</span>key, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>data, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>args)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>clonesrv_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> (clonesrv_t <span style="color:#666666">*</span>) args;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_t <span style="color:#666666">*</span>kvmsg <span style="color:#666666">=</span> (kvmsg_t <span style="color:#666666">*</span>) data;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int64_t</span> ttl;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>sscanf (kvmsg_get_prop (kvmsg, <span style="color:#BA2121">"ttl"</span>), <span style="color:#BA2121">"%"</span> PRId64, <span style="color:#666666">&amp;</span>ttl);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (ttl <span style="color:#666666">&amp;&amp;</span> zclock_time () <span style="color:#666666">&gt;=</span> ttl) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_set_sequence (kvmsg, <span style="color:#666666">++</span>self<span style="color:#666666">-&gt;</span>sequence);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_set_body (kvmsg, (byte <span style="color:#666666">*</span>) <span style="color:#BA2121">""</span>, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_send (kvmsg, self<span style="color:#666666">-&gt;</span>publisher);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_store (<span style="color:#666666">&amp;</span>kvmsg, self<span style="color:#666666">-&gt;</span>kvmap);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zclock_log (<span style="color:#BA2121">"I: publishing delete=%d"</span>, (<span style="color:#B00040">int</span>) self<span style="color:#666666">-&gt;</span>sequence);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">int</span><br>
<span style="color:#0000FF">s_flush_ttl</span> (zloop_t <span style="color:#666666">*</span>loop, <span style="color:#B00040">int</span> timer_id, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>args)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>clonesrv_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> (clonesrv_t <span style="color:#666666">*</span>) args;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>kvmap)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zhash_foreach (self<span style="color:#666666">-&gt;</span>kvmap, s_flush_single, args);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We send a HUGZ message once a second to all subscribers so that they<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>can detect if our server dies. They'll then switch over to the backup<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>server, which will become active:</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">int</span><br>
<span style="color:#0000FF">s_send_hugz</span> (zloop_t <span style="color:#666666">*</span>loop, <span style="color:#B00040">int</span> timer_id, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>args)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>clonesrv_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> (clonesrv_t <span style="color:#666666">*</span>) args;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_t <span style="color:#666666">*</span>kvmsg <span style="color:#666666">=</span> kvmsg_new (self<span style="color:#666666">-&gt;</span>sequence);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_set_key<tt><span style="white-space: pre-wrap;">  </span></tt>(kvmsg, <span style="color:#BA2121">"HUGZ"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_set_body (kvmsg, (byte <span style="color:#666666">*</span>) <span style="color:#BA2121">""</span>, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_send<tt><span style="white-space: pre-wrap;">     </span></tt>(kvmsg, self<span style="color:#666666">-&gt;</span>publisher);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_destroy (<span style="color:#666666">&amp;</span>kvmsg);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>When we switch from passive to active, we apply our pending list so that<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>our kvmap is up-to-date. When we switch to passive, we wipe our kvmap<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>and grab a new snapshot from the active server:</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">int</span><br>
<span style="color:#0000FF">s_new_active</span> (zloop_t <span style="color:#666666">*</span>loop, zmq_pollitem_t <span style="color:#666666">*</span>unused, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>args)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>clonesrv_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> (clonesrv_t <span style="color:#666666">*</span>) args;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>active <span style="color:#666666">=</span> <span style="color:#008000">true</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>passive <span style="color:#666666">=</span> <span style="color:#008000">false</span>;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Stop subscribing to updates</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_pollitem_t poller <span style="color:#666666">=</span> { self<span style="color:#666666">-&gt;</span>subscriber, <span style="color:#666666">0</span>, ZMQ_POLLIN };<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zloop_poller_end (bstar_zloop (self<span style="color:#666666">-&gt;</span>bstar), <span style="color:#666666">&amp;</span>poller);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Apply pending list to own hash table</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (zlist_size (self<span style="color:#666666">-&gt;</span>pending)) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_t <span style="color:#666666">*</span>kvmsg <span style="color:#666666">=</span> (kvmsg_t <span style="color:#666666">*</span>) zlist_pop (self<span style="color:#666666">-&gt;</span>pending);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_set_sequence (kvmsg, <span style="color:#666666">++</span>self<span style="color:#666666">-&gt;</span>sequence);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_send (kvmsg, self<span style="color:#666666">-&gt;</span>publisher);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_store (<span style="color:#666666">&amp;</span>kvmsg, self<span style="color:#666666">-&gt;</span>kvmap);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zclock_log (<span style="color:#BA2121">"I: publishing pending=%d"</span>, (<span style="color:#B00040">int</span>) self<span style="color:#666666">-&gt;</span>sequence);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">int</span><br>
<span style="color:#0000FF">s_new_passive</span> (zloop_t <span style="color:#666666">*</span>loop, zmq_pollitem_t <span style="color:#666666">*</span>unused, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>args)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>clonesrv_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> (clonesrv_t <span style="color:#666666">*</span>) args;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zhash_destroy (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>kvmap);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>active <span style="color:#666666">=</span> <span style="color:#008000">false</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>passive <span style="color:#666666">=</span> <span style="color:#008000">true</span>;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Start subscribing to updates</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmq_pollitem_t poller <span style="color:#666666">=</span> { self<span style="color:#666666">-&gt;</span>subscriber, <span style="color:#666666">0</span>, ZMQ_POLLIN };<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zloop_poller (bstar_zloop (self<span style="color:#666666">-&gt;</span>bstar), <span style="color:#666666">&amp;</span>poller, s_subscriber, self);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>When we get an update, we create a new kvmap if necessary, and then<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>add our update to our kvmap. We're always passive in this case:</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">int</span><br>
<span style="color:#0000FF">s_subscriber</span> (zloop_t <span style="color:#666666">*</span>loop, zmq_pollitem_t <span style="color:#666666">*</span>poller, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>args)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>clonesrv_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> (clonesrv_t <span style="color:#666666">*</span>) args;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Get state snapshot if necessary</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>kvmap <span style="color:#666666">==</span> <span style="color:#008000">NULL</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>self<span style="color:#666666">-&gt;</span>kvmap <span style="color:#666666">=</span> zhash_new ();<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>snapshot <span style="color:#666666">=</span> zsocket_new (self<span style="color:#666666">-&gt;</span>ctx, ZMQ_DEALER);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zsocket_connect (snapshot, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost:%d"</span>, self<span style="color:#666666">-&gt;</span>peer);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zclock_log (<span style="color:#BA2121">"I: asking for snapshot from: tcp:<span style="white-space: pre-wrap;">//</span>localhost:%d"</span>,<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>self<span style="color:#666666">-&gt;</span>peer);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zstr_sendm (snapshot, <span style="color:#BA2121">"ICANHAZ?"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zstr_send (snapshot, <span style="color:#BA2121">""</span>); <span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span> blank subtree to get all</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_t <span style="color:#666666">*</span>kvmsg <span style="color:#666666">=</span> kvmsg_recv (snapshot);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>kvmsg)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (streq (kvmsg_key (kvmsg), <span style="color:#BA2121">"KTHXBAI"</span>)) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>self<span style="color:#666666">-&gt;</span>sequence <span style="color:#666666">=</span> kvmsg_sequence (kvmsg);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>kvmsg_destroy (<span style="color:#666666">&amp;</span>kvmsg);<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Done</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_store (<span style="color:#666666">&amp;</span>kvmsg, self<span style="color:#666666">-&gt;</span>kvmap);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zclock_log (<span style="color:#BA2121">"I: received snapshot=%d"</span>, (<span style="color:#B00040">int</span>) self<span style="color:#666666">-&gt;</span>sequence);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zsocket_destroy (self<span style="color:#666666">-&gt;</span>ctx, snapshot);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Find and remove update off pending list</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>kvmsg_t <span style="color:#666666">*</span>kvmsg <span style="color:#666666">=</span> kvmsg_recv (poller<span style="color:#666666">-&gt;</span>socket);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>kvmsg)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (strneq (kvmsg_key (kvmsg), <span style="color:#BA2121">"HUGZ"</span>)) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>s_was_pending (self, kvmsg)) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If active update came before client update, flip it</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>around, store active update (with sequence) on pending</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>list and use to clear client update when it comes later</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zlist_append (self<span style="color:#666666">-&gt;</span>pending, kvmsg_dup (kvmsg));<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If update is more recent than our kvmap, apply it</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (kvmsg_sequence (kvmsg) <span style="color:#666666">&gt;</span> self<span style="color:#666666">-&gt;</span>sequence) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>self<span style="color:#666666">-&gt;</span>sequence <span style="color:#666666">=</span> kvmsg_sequence (kvmsg);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_store (<span style="color:#666666">&amp;</span>kvmsg, self<span style="color:#666666">-&gt;</span>kvmap);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zclock_log (<span style="color:#BA2121">"I: received update=%d"</span>, (<span style="color:#B00040">int</span>) self<span style="color:#666666">-&gt;</span>sequence);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_destroy (<span style="color:#666666">&amp;</span>kvmsg);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_destroy (<span style="color:#666666">&amp;</span>kvmsg);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/java:clonesrv6" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/py:clonesrv6" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | C# | Clojure | CL | Delphi | Erlang | F# | Felix | Go | Haskell | Haxe | Lua | Node.js | Objective-C | ooc | Perl | PHP | Q | Racket | Ruby | Scala | Tcl</a></span>
<p>This model is only a few hundred lines of code, but it took quite a while to get working. To be accurate, building Model Six took about a full week of "Sweet god, this is just too complex for an example" hacking. We've assembled pretty much everything and the kitchen sink into this small application. We have failover, ephemeral values, subtrees, and so on. What surprised me was that the up-front design was pretty accurate. Still the details of writing and debugging so many socket flows is quite challenging.</p>
<p>The reactor-based design removes a lot of the grunt work from the code, and what remains is simpler and easier to understand. We reuse the bstar reactor from <a href="http://zguide.zeromq.org/page:all#reliable-request-reply">Chapter 4 - Reliable Request-Reply Patterns</a>. The whole server runs as one thread, so there's no inter-thread weirdness going on—just a structure pointer (<tt>self</tt>) passed around to all handlers, which can do their thing happily. One nice side effect of using reactors is that the code, being less tightly integrated into a poll loop, is much easier to reuse. Large chunks of Model Six are taken from Model Five.</p>
<p>I built it piece by piece, and got each piece working <em>properly</em> before going onto the next one. Because there are four or five main socket flows, that meant quite a lot of debugging and testing. I debugged just by dumping messages to the console. Don't use classic debuggers to step through ZeroMQ applications; you need to see the message flows to make any sense of what is going on.</p>
<p>For testing, I always try to use Valgrind, which catches memory leaks and invalid memory accesses. In C, this is a major concern, as you can't delegate to a garbage collector. Using proper and consistent abstractions like kvmsg and CZMQ helps enormously.</p>
<p><a name="The-Clustered-Hashmap-Protocol"></a><a name="header-129"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc128"><span><a href="http://zguide.zeromq.org/page:all#The-Clustered-Hashmap-Protocol">The Clustered Hashmap Protocol</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-128">prev</a> <a href="http://zguide.zeromq.org/page:all#header-130">next</a></td>
</tr>
</tbody></table>
<p>While the server is pretty much a mashup of the previous model plus the Binary Star pattern, the client is quite a lot more complex. But before we get to that, let's look at the final protocol. I've written this up as a specification on the ZeroMQ RFC website as the <a href="http://rfc.zeromq.org/spec:12">Clustered Hashmap Protocol</a>.</p>
<p>Roughly, there are two ways to design a complex protocol such as this one. One way is to separate each flow into its own set of sockets. This is the approach we used here. The advantage is that each flow is simple and clean. The disadvantage is that managing multiple socket flows at once can be quite complex. Using a reactor makes it simpler, but still, it makes a lot of moving pieces that have to fit together correctly.</p>
<p>The second way to make such a protocol is to use a single socket pair for everything. In this case, I'd have used ROUTER for the server and DEALER for the clients, and then done everything over that connection. It makes for a more complex protocol but at least the complexity is all in one place. In <a href="http://zguide.zeromq.org/page:all#advanced-architecture">Chapter 7 - Advanced Architecture using ZeroMQ</a> we'll look at an example of a protocol done over a ROUTER-DEALER combination.</p>
<p>Let's take a look at the CHP specification. Note that "SHOULD", "MUST" and "MAY" are key words we use in protocol specifications to indicate requirement levels.</p>
<p><strong>Goals</strong></p>
<p>CHP is meant to provide a basis for reliable pub-sub across a cluster of clients connected over a ZeroMQ network. It defines a "hashmap" abstraction consisting of key-value pairs. Any client can modify any key-value pair at any time, and changes are propagated to all clients. A client can join the network at any time.</p>
<p><strong>Architecture</strong></p>
<p>CHP connects a set of client applications and a set of servers. Clients connect to the server. Clients do not see each other. Clients can come and go arbitrarily.</p>
<p><strong>Ports and Connections</strong></p>
<p>The server MUST open three ports as follows:</p>
<ul>
<li>A SNAPSHOT port (ZeroMQ ROUTER socket) at port number P.</li>
<li>A PUBLISHER port (ZeroMQ PUB socket) at port number P + 1.</li>
<li>A COLLECTOR port (ZeroMQ SUB socket) at port number P + 2.</li>
</ul>
<p>The client SHOULD open at least two connections:</p>
<ul>
<li>A SNAPSHOT connection (ZeroMQ DEALER socket) to port number P.</li>
<li>A SUBSCRIBER connection (ZeroMQ SUB socket) to port number P + 1.</li>
</ul>
<p>The client MAY open a third connection, if it wants to update the hashmap:</p>
<ul>
<li>A PUBLISHER connection (ZeroMQ PUB socket) to port number P + 2.</li>
</ul>
<p>This extra frame is not shown in the commands explained below.</p>
<p><strong>State Synchronization</strong></p>
<p>The client MUST start by sending a ICANHAZ command to its snapshot connection. This command consists of two frames as follows:</p>
<div class="code">
<pre><code>ICANHAZ command
-----------------------------------
Frame 0: "ICANHAZ?"
Frame 1: subtree specification</code>
</pre></div>
<p>Both frames are ZeroMQ strings. The subtree specification MAY be empty. If not empty, it consists of a slash followed by one or more path segments, ending in a slash.</p>
<p>The server MUST respond to a ICANHAZ command by sending zero or more KVSYNC commands to its snapshot port, followed with a KTHXBAI command. The server MUST prefix each command with the identity of the client, as provided by ZeroMQ with the ICANHAZ command. The KVSYNC command specifies a single key-value pair as follows:</p>
<div class="code">
<pre><code>KVSYNC command
-----------------------------------
Frame 0: key, as ZeroMQ string
Frame 1: sequence number, 8 bytes in network order
Frame 2: &lt;empty&gt;
Frame 3: &lt;empty&gt;
Frame 4: value, as blob</code>
</pre></div>
<p>The sequence number has no significance and may be zero.</p>
<p>The KTHXBAI command takes this form:</p>
<div class="code">
<pre><code>KTHXBAI command
-----------------------------------
Frame 0: "KTHXBAI"
Frame 1: sequence number, 8 bytes in network order
Frame 2: &lt;empty&gt;
Frame 3: &lt;empty&gt;
Frame 4: subtree specification</code>
</pre></div>
<p>The sequence number MUST be the highest sequence number of the KVSYNC commands previously sent.</p>
<p>When the client has received a KTHXBAI command, it SHOULD start to receive messages from its subscriber connection and apply them.</p>
<p><strong>Server-to-Client Updates</strong></p>
<p>When the server has an update for its hashmap it MUST broadcast this on its publisher socket as a KVPUB command. The KVPUB command has this form:</p>
<div class="code">
<pre><code>KVPUB command
-----------------------------------
Frame 0: key, as ZeroMQ string
Frame 1: sequence number, 8 bytes in network order
Frame 2: UUID, 16 bytes
Frame 3: properties, as ZeroMQ string
Frame 4: value, as blob</code>
</pre></div>
<p>The sequence number MUST be strictly incremental. The client MUST discard any KVPUB commands whose sequence numbers are not strictly greater than the last KTHXBAI or KVPUB command received.</p>
<p>The UUID is optional and frame 2 MAY be empty (size zero). The properties field is formatted as zero or more instances of "name=value" followed by a newline character. If the key-value pair has no properties, the properties field is empty.</p>
<p>If the value is empty, the client SHOULD delete its key-value entry with the specified key.</p>
<p>In the absence of other updates the server SHOULD send a HUGZ command at regular intervals, e.g., once per second. The HUGZ command has this format:</p>
<div class="code">
<pre><code>HUGZ command
-----------------------------------
Frame 0: "HUGZ"
Frame 1: 00000000
Frame 2: &lt;empty&gt;
Frame 3: &lt;empty&gt;
Frame 4: &lt;empty&gt;</code>
</pre></div>
<p>The client MAY treat the absence of HUGZ as an indicator that the server has crashed (see Reliability below).</p>
<p><strong>Client-to-Server Updates</strong></p>
<p>When the client has an update for its hashmap, it MAY send this to the server via its publisher connection as a KVSET command. The KVSET command has this form:</p>
<div class="code">
<pre><code>KVSET command
-----------------------------------
Frame 0: key, as ZeroMQ string
Frame 1: sequence number, 8 bytes in network order
Frame 2: UUID, 16 bytes
Frame 3: properties, as ZeroMQ string
Frame 4: value, as blob</code>
</pre></div>
<p>The sequence number has no significance and may be zero. The UUID SHOULD be a universally unique identifier, if a reliable server architecture is used.</p>
<p>If the value is empty, the server MUST delete its key-value entry with the specified key.</p>
<p>The server SHOULD accept the following properties:</p>
<ul>
<li><tt>ttl</tt>: specifies a time-to-live in seconds. If the KVSET command has a <tt>ttl</tt> property, the server SHOULD delete the key-value pair and broadcast a KVPUB with an empty value in order to delete this from all clients when the TTL has expired.</li>
</ul>
<p><strong>Reliability</strong></p>
<p>CHP may be used in a dual-server configuration where a backup server takes over if the primary server fails. CHP does not specify the mechanisms used for this failover but the Binary Star pattern may be helpful.</p>
<p>To assist server reliability, the client MAY:</p>
<ul>
<li>Set a UUID in every KVSET command.</li>
<li>Detect the lack of HUGZ over a time period and use this as an indicator that the current server has failed.</li>
<li>Connect to a backup server and re-request a state synchronization.</li>
</ul>
<p><strong>Scalability and Performance</strong></p>
<p>CHP is designed to be scalable to large numbers (thousands) of clients, limited only by system resources on the broker. Because all updates pass through a single server, the overall throughput will be limited to some millions of updates per second at peak, and probably less.</p>
<p><strong>Security</strong></p>
<p>CHP does not implement any authentication, access control, or encryption mechanisms and should not be used in any deployment where these are required.</p>
<p><a name="Building-a-Multithreaded-Stack-and-API"></a><a name="header-130"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc129"><span><a href="http://zguide.zeromq.org/page:all#Building-a-Multithreaded-Stack-and-API">Building a Multithreaded Stack and API</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-129">prev</a> <a href="http://zguide.zeromq.org/page:all#header-131">next</a></td>
</tr>
</tbody></table>
<p>The client stack we've used so far isn't smart enough to handle this protocol properly. As soon as we start doing heartbeats, we need a client stack that can run in a background thread. In the Freelance pattern at the end of <a href="http://zguide.zeromq.org/page:all#reliable-request-reply">Chapter 4 - Reliable Request-Reply Patterns</a> we used a multithreaded API but didn't explain it in detail. It turns out that multithreaded APIs are quite useful when you start to make more complex ZeroMQ protocols like CHP.</p>
<p><strong>Figure 63 - Multithreaded API</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig63.png" alt="fig63.png" class="image"></div>
<p>If you make a nontrivial protocol and you expect applications to implement it properly, most developers will get it wrong most of the time. You're going to be left with a lot of unhappy people complaining that your protocol is too complex, too fragile, and too hard to use. Whereas if you give them a simple API to call, you have some chance of them buying in.</p>
<p>Our multithreaded API consists of a frontend object and a background agent, connected by two PAIR sockets. Connecting two PAIR sockets like this is so useful that your high-level binding should probably do what CZMQ does, which is package a "create new thread with a pipe that I can use to send messages to it" method.</p>
<p>The multithreaded APIs that we see in this book all take the same form:</p>
<ul>
<li>The constructor for the object (<tt>clone_new</tt>) creates a context and starts a background thread connected with a pipe. It holds onto one end of the pipe so it can send commands to the background thread.</li>
</ul>
<ul>
<li>The background thread starts an <em>agent</em> that is essentially a <tt>zmq_poll</tt> loop reading from the pipe socket and any other sockets (here, the DEALER and SUB sockets).</li>
</ul>
<ul>
<li>The main application thread and the background thread now communicate only via ZeroMQ messages. By convention, the frontend sends string commands so that each method on the class turns into a message sent to the backend agent, like this:</li>
</ul>
<div class="code">
<p><span style="color:#B00040">void</span><br>
<span style="color:#0000FF">clone_connect</span> (clone_t <span style="color:#666666">*</span>self, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>address, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>service)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_addstr (msg, <span style="color:#BA2121">"CONNECT"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_addstr (msg, address);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_addstr (msg, service);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>msg, self<span style="color:#666666">-&gt;</span>pipe);<br>
}</p>
</div>
<ul>
<li>If the method needs a return code, it can wait for a reply message from the agent.</li>
</ul>
<ul>
<li>If the agent needs to send asynchronous events back to the frontend, we add a <tt>recv</tt> method to the class, which waits for messages on the frontend pipe.</li>
</ul>
<ul>
<li>We may want to expose the frontend pipe socket handle to allow the class to be integrated into further poll loops. Otherwise any <tt>recv</tt> method would block the application.</li>
</ul>
<p>The clone class has the same structure as the <tt>flcliapi</tt> class from <a href="http://zguide.zeromq.org/page:all#reliable-request-reply">Chapter 4 - Reliable Request-Reply Patterns</a> and adds the logic from the last model of the Clone client. Without ZeroMQ, this kind of multithreaded API design would be weeks of really hard work. With ZeroMQ, it was a day or two of work.</p>
<p>The actual API methods for the clone class are quite simple:</p>
<div class="code">
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Create a new clone class instance</em></span><br>
clone_t <span style="color:#666666">*</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>clone_new (<span style="color:#B00040">void</span>);</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Destroy a clone class instance</em></span><br>
<span style="color:#B00040">void</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>clone_destroy (clone_t <span style="color:#666666"><span style="white-space: pre-wrap;">**</span></span>self_p);</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Define the subtree, if any, for this clone class</em></span><br>
<span style="color:#B00040">void</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>clone_subtree (clone_t <span style="color:#666666">*</span>self, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>subtree);</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Connect the clone class to one server</em></span><br>
<span style="color:#B00040">void</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>clone_connect (clone_t <span style="color:#666666">*</span>self, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>address, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>service);</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Set a value in the shared hashmap</em></span><br>
<span style="color:#B00040">void</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>clone_set (clone_t <span style="color:#666666">*</span>self, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>key, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>value, <span style="color:#B00040">int</span> ttl);</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Get a value from the shared hashmap</em></span><br>
<span style="color:#B00040">char</span> <span style="color:#666666">*</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>clone_get (clone_t <span style="color:#666666">*</span>self, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>key);</p>
</div>
<p>So here is Model Six of the clone client, which has now become just a thin shell using the clone class:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">clonecli6:&nbsp;Clone&nbsp;client,&nbsp;Model&nbsp;Six&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">clonecli6:&nbsp;Clone&nbsp;client,&nbsp;Model&nbsp;Six&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Clone client Model Six</span></p>
<p><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Lets us build this source without creating a library<br>
#include "clone.c"<br>
#define SUBTREE "/client/"</p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Create distributed hash instance</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>clone_t <span style="color:#666666">*</span>clone <span style="color:#666666">=</span> clone_new ();</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Specify configuration</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>clone_subtree (clone, SUBTREE);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>clone_connect (clone, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost"</span>, <span style="color:#BA2121">"5556"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>clone_connect (clone, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>localhost"</span>, <span style="color:#BA2121">"5566"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Set random tuples into the distributed hash</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#666666">!</span>zctx_interrupted) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Set random value, check it was stored</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> key <span style="white-space: pre-wrap;">[</span><span style="color:#666666">255</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> value <span style="white-space: pre-wrap;">[</span><span style="color:#666666">10</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>sprintf (key, <span style="color:#BA2121">"%s%d"</span>, SUBTREE, randof (<span style="color:#666666">10000</span>));<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>sprintf (value, <span style="color:#BA2121">"%d"</span>, randof (<span style="color:#666666">1000000</span>));<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>clone_set (clone, key, value, randof (<span style="color:#666666">30</span>));<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>sleep (<span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>clone_destroy (<span style="color:#666666">&amp;</span>clone);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/java:clonecli6" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/py:clonecli6" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | C# | Clojure | CL | Delphi | Erlang | F# | Felix | Go | Haskell | Haxe | Lua | Node.js | Objective-C | ooc | Perl | PHP | Q | Racket | Ruby | Scala | Tcl</a></span>
<p>Note the connect method, which specifies one server endpoint. Under the hood, we're in fact talking to three ports. However, as the CHP protocol says, the three ports are on consecutive port numbers:</p>
<ul>
<li>The server state router (ROUTER) is at port P.</li>
<li>The server updates publisher (PUB) is at port P + 1.</li>
<li>The server updates subscriber (SUB) is at port P + 2.</li>
</ul>
<p>So we can fold the three connections into one logical operation (which we implement as three separate ZeroMQ connect calls).</p>
<p>Let's end with the source code for the clone stack. This is a complex piece of code, but easier to understand when you break it into the frontend object class and the backend agent. The frontend sends string commands ("SUBTREE", "CONNECT", "SET", "GET") to the agent, which handles these commands as well as talking to the server(s). Here is the agent's logic:</p>
<ol>
<li>Start up by getting a snapshot from the first server</li>
<li>When we get a snapshot switch to reading from the subscriber socket.</li>
<li>If we don't get a snapshot then fail over to the second server.</li>
<li>Poll on the pipe and the subscriber socket.</li>
<li>If we got input on the pipe, handle the control message from the frontend object.</li>
<li>If we got input on the subscriber, store or apply the update.</li>
<li>If we didn't get anything from the server within a certain time, fail over.</li>
<li>Repeat until the process is interrupted by Ctrl-C.</li>
</ol>
<p>And here is the actual clone class implementation:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">clone:&nbsp;Clone&nbsp;class&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">clone:&nbsp;Clone&nbsp;class&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>clone class - Clone client API stack (multithreaded)</span></p>
<p>#include "clone.h"<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If no server replies within this time, abandon request<br>
#define GLOBAL_TIMEOUT<tt><span style="white-space: pre-wrap;">  </span></tt>4000<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>msecs</em></span></p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>=====================================================================<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Synchronous part, works in our application thread</span></span></p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Structure of our class</em></span></p>
<p><span style="color:#008000"><strong>struct</strong></span> _clone_t {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx;<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Our context wrapper</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>pipe;<tt><span style="white-space: pre-wrap;">                 </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Pipe through to clone agent</em></span><br>
};</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>This is the thread that handles our real clone class</em></span><br>
<span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span> clone_agent (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>args, zctx_t <span style="color:#666666">*</span>ctx, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>pipe);</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Here are the constructor and destructor for the clone class. Note that<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>we create a context specifically for the pipe that connects our<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>frontend to the backend agent:</span></span></p>
<p>clone_t <span style="color:#666666">*</span><br>
<span style="color:#0000FF">clone_new</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>clone_t<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#666666">*</span>self;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>self <span style="color:#666666">=</span> (clone_t <span style="color:#666666">*</span>) zmalloc (<span style="color:#008000"><strong>sizeof</strong></span> (clone_t));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>pipe <span style="color:#666666">=</span> zthread_fork (self<span style="color:#666666">-&gt;</span>ctx, clone_agent, <span style="color:#008000">NULL</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> self;<br>
}</p>
<p><span style="color:#B00040">void</span><br>
<span style="color:#0000FF">clone_destroy</span> (clone_t <span style="color:#666666"><span style="white-space: pre-wrap;">**</span></span>self_p)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self_p);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">*</span>self_p) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>clone_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> <span style="color:#666666">*</span>self_p;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (self);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#666666">*</span>self_p <span style="color:#666666">=</span> <span style="color:#008000">NULL</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Specify subtree for snapshot and updates, which we must do before<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>connecting to a server as the subtree specification is sent as the<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>first command to the server. Sends a <span style="white-space: pre-wrap;">[</span>SUBTREE<span style="white-space: pre-wrap;">][</span>subtree<span style="white-space: pre-wrap;">]</span> command to<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>the agent:</span></span></p>
<p><span style="color:#B00040">void</span> <span style="color:#0000FF">clone_subtree</span> (clone_t <span style="color:#666666">*</span>self, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>subtree)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_addstr (msg, <span style="color:#BA2121">"SUBTREE"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_addstr (msg, subtree);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>msg, self<span style="color:#666666">-&gt;</span>pipe);<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Connect to a new server endpoint. We can connect to at most two<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>servers. Sends <span style="white-space: pre-wrap;">[</span>CONNECT<span style="white-space: pre-wrap;">][</span>endpoint<span style="white-space: pre-wrap;">][</span>service<span style="white-space: pre-wrap;">]</span> to the agent:</span></span></p>
<p><span style="color:#B00040">void</span><br>
<span style="color:#0000FF">clone_connect</span> (clone_t <span style="color:#666666">*</span>self, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>address, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>service)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_addstr (msg, <span style="color:#BA2121">"CONNECT"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_addstr (msg, address);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_addstr (msg, service);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>msg, self<span style="color:#666666">-&gt;</span>pipe);<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Set a new value in the shared hashmap. Sends a <span style="white-space: pre-wrap;">[</span>SET<span style="white-space: pre-wrap;">][</span>key<span style="white-space: pre-wrap;">][</span>value<span style="white-space: pre-wrap;">][</span>ttl<span style="white-space: pre-wrap;">]</span><br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>command through to the agent which does the actual work:</span></span></p>
<p><span style="color:#B00040">void</span><br>
<span style="color:#0000FF">clone_set</span> (clone_t <span style="color:#666666">*</span>self, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>key, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>value, <span style="color:#B00040">int</span> ttl)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> ttlstr <span style="white-space: pre-wrap;">[</span><span style="color:#666666">10</span><span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>sprintf (ttlstr, <span style="color:#BA2121">"%d"</span>, ttl);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_addstr (msg, <span style="color:#BA2121">"SET"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_addstr (msg, key);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_addstr (msg, value);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_addstr (msg, ttlstr);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>msg, self<span style="color:#666666">-&gt;</span>pipe);<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Look up value in distributed hash table. Sends <span style="white-space: pre-wrap;">[</span>GET<span style="white-space: pre-wrap;">][</span>key<span style="white-space: pre-wrap;">]</span> to the agent and<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>waits for a value response. If there is no value available, will eventually<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>return NULL:</span></span></p>
<p><span style="color:#B00040">char</span> <span style="color:#666666">*</span><br>
<span style="color:#0000FF">clone_get</span> (clone_t <span style="color:#666666">*</span>self, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>key)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (key);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_addstr (msg, <span style="color:#BA2121">"GET"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_addstr (msg, key);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>msg, self<span style="color:#666666">-&gt;</span>pipe);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>reply <span style="color:#666666">=</span> zmsg_recv (self<span style="color:#666666">-&gt;</span>pipe);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (reply) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>value <span style="color:#666666">=</span> zmsg_popstr (reply);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>reply);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>return</strong></span> value;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#008000">NULL</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The backend agent manages a set of servers, which we implement using<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>our simple class model:</span></span></p>
<p><span style="color:#008000"><strong>typedef</strong></span> <span style="color:#008000"><strong>struct</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>address;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Server address</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int</span> port;<tt><span style="white-space: pre-wrap;">                   </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Server port</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>snapshot;<tt><span style="white-space: pre-wrap;">             </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Snapshot socket</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>subscriber;<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Incoming updates</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">uint64_t</span> expiry;<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>When server expires</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>uint requests;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>How many snapshot requests made?</em></span><br>
} server_t;</p>
<p><span style="color:#008000"><strong>static</strong></span> server_t <span style="color:#666666">*</span><br>
<span style="color:#0000FF">server_new</span> (zctx_t <span style="color:#666666">*</span>ctx, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>address, <span style="color:#B00040">int</span> port, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>subtree)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>server_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> (server_t <span style="color:#666666">*</span>) zmalloc (<span style="color:#008000"><strong>sizeof</strong></span> (server_t));</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>zclock_log (<span style="color:#BA2121">"I: adding server %s:%d…"</span>, address, port);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>address <span style="color:#666666">=</span> strdup (address);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>port <span style="color:#666666">=</span> port;</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>snapshot <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_DEALER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect (self<span style="color:#666666">-&gt;</span>snapshot, <span style="color:#BA2121">"%s:%d"</span>, address, port);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>subscriber <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_SUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect (self<span style="color:#666666">-&gt;</span>subscriber, <span style="color:#BA2121">"%s:%d"</span>, address, port <span style="color:#666666">+</span> <span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_set_subscribe (self<span style="color:#666666">-&gt;</span>subscriber, subtree);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_set_subscribe (self<span style="color:#666666">-&gt;</span>subscriber, <span style="color:#BA2121">"HUGZ"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> self;<br>
}</p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<span style="color:#0000FF">server_destroy</span> (server_t <span style="color:#666666"><span style="white-space: pre-wrap;">**</span></span>self_p)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self_p);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">*</span>self_p) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>server_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> <span style="color:#666666">*</span>self_p;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (self<span style="color:#666666">-&gt;</span>address);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (self);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#666666">*</span>self_p <span style="color:#666666">=</span> <span style="color:#008000">NULL</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
}<br>
<span style="color:#BC7A00"><br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Here is the implementation of the backend agent itself:</span></p>
<p><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Number of servers to which we will talk to<br>
#define SERVER_MAX<tt><span style="white-space: pre-wrap;">      </span></tt>2</p>
<p><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Server considered dead if silent for this long<br>
#define SERVER_TTL<tt><span style="white-space: pre-wrap;">      </span></tt>5000<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>msecs</em></span><br>
<span style="color:#BC7A00"><br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>States we can be in<br>
#define STATE_INITIAL<tt><span style="white-space: pre-wrap;">       </span></tt>0<tt><span style="white-space: pre-wrap;">   </span></tt></span><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Before asking server for state</em></span><br>
<span style="color:#BC7A00">#define STATE_SYNCING<tt><span style="white-space: pre-wrap;">       </span></tt>1<tt><span style="white-space: pre-wrap;">   </span></tt></span><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Getting state from server</em></span><br>
<span style="color:#BC7A00">#define STATE_ACTIVE<tt><span style="white-space: pre-wrap;">        </span></tt>2<tt><span style="white-space: pre-wrap;">   </span></tt></span><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Getting new updates from server</em></span></p>
<p><span style="color:#008000"><strong>typedef</strong></span> <span style="color:#008000"><strong>struct</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx;<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Context wrapper</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>pipe;<tt><span style="white-space: pre-wrap;">                 </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Pipe back to application</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zhash_t <span style="color:#666666">*</span>kvmap;<tt><span style="white-space: pre-wrap;">             </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Actual key/value table</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>subtree;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Subtree specification, if any</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>server_t <span style="color:#666666">*</span>server <span style="white-space: pre-wrap;">[</span>SERVER_MAX<span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>uint nbr_servers;<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>0 to SERVER_MAX</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>uint state;<tt><span style="white-space: pre-wrap;">                 </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Current state</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>uint cur_server;<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>If active, server 0 or 1</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">int64_t</span> sequence;<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Last kvmsg processed</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>publisher;<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Outgoing updates</em></span><br>
} agent_t;</p>
<p><span style="color:#008000"><strong>static</strong></span> agent_t <span style="color:#666666">*</span><br>
<span style="color:#0000FF">agent_new</span> (zctx_t <span style="color:#666666">*</span>ctx, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>pipe)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>agent_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> (agent_t <span style="color:#666666">*</span>) zmalloc (<span style="color:#008000"><strong>sizeof</strong></span> (agent_t));<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>ctx <span style="color:#666666">=</span> ctx;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>pipe <span style="color:#666666">=</span> pipe;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>kvmap <span style="color:#666666">=</span> zhash_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>subtree <span style="color:#666666">=</span> strdup (<span style="color:#BA2121">""</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>state <span style="color:#666666">=</span> STATE_INITIAL;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>publisher <span style="color:#666666">=</span> zsocket_new (self<span style="color:#666666">-&gt;</span>ctx, ZMQ_PUB);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> self;<br>
}</p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<span style="color:#0000FF">agent_destroy</span> (agent_t <span style="color:#666666"><span style="white-space: pre-wrap;">**</span></span>self_p)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (self_p);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">*</span>self_p) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>agent_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> <span style="color:#666666">*</span>self_p;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> server_nbr;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>for</strong></span> (server_nbr <span style="color:#666666">=</span> <span style="color:#666666">0</span>; server_nbr <span style="color:#666666">&lt;</span> self<span style="color:#666666">-&gt;</span>nbr_servers; server_nbr<span style="color:#666666">++</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>server_destroy (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>server <span style="white-space: pre-wrap;">[</span>server_nbr<span style="white-space: pre-wrap;">]</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zhash_destroy (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>kvmap);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (self<span style="color:#666666">-&gt;</span>subtree);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (self);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#666666">*</span>self_p <span style="color:#666666">=</span> <span style="color:#008000">NULL</span>;<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Here we handle the different control messages from the frontend;<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>SUBTREE, CONNECT, SET, and GET:</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">int</span><br>
<span style="color:#0000FF">agent_control_message</span> (agent_t <span style="color:#666666">*</span>self)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_t <span style="color:#666666">*</span>msg <span style="color:#666666">=</span> zmsg_recv (self<span style="color:#666666">-&gt;</span>pipe);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>command <span style="color:#666666">=</span> zmsg_popstr (msg);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (command <span style="color:#666666">==</span> <span style="color:#008000">NULL</span>)<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">-</span><span style="color:#666666">1</span>;<tt><span style="white-space: pre-wrap;">      </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span></p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (streq (command, <span style="color:#BA2121">"SUBTREE"</span>)) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (self<span style="color:#666666">-&gt;</span>subtree);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>self<span style="color:#666666">-&gt;</span>subtree <span style="color:#666666">=</span> zmsg_popstr (msg);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (streq (command, <span style="color:#BA2121">"CONNECT"</span>)) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>address <span style="color:#666666">=</span> zmsg_popstr (msg);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>service <span style="color:#666666">=</span> zmsg_popstr (msg);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>nbr_servers <span style="color:#666666">&lt;</span> SERVER_MAX) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>self<span style="color:#666666">-&gt;</span>server <span style="white-space: pre-wrap;">[</span>self<span style="color:#666666">-&gt;</span>nbr_servers<span style="color:#666666">++</span><span style="white-space: pre-wrap;">]</span> <span style="color:#666666">=</span> server_new (<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>self<span style="color:#666666">-&gt;</span>ctx, address, atoi (service), self<span style="color:#666666">-&gt;</span>subtree);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We broadcast updates to all known servers</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zsocket_connect (self<span style="color:#666666">-&gt;</span>publisher, <span style="color:#BA2121">"%s:%d"</span>,<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>address, atoi (service) <span style="color:#666666">+</span> <span style="color:#666666">2</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zclock_log (<span style="color:#BA2121">"E: too many servers (max. %d)"</span>, SERVER_MAX);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (address);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (service);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>When we set a property, we push the new key-value pair onto</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>all our connected servers:</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (streq (command, <span style="color:#BA2121">"SET"</span>)) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>key <span style="color:#666666">=</span> zmsg_popstr (msg);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>value <span style="color:#666666">=</span> zmsg_popstr (msg);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>ttl <span style="color:#666666">=</span> zmsg_popstr (msg);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send key-value pair on to server</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_t <span style="color:#666666">*</span>kvmsg <span style="color:#666666">=</span> kvmsg_new (<span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_set_key<tt><span style="white-space: pre-wrap;">  </span></tt>(kvmsg, key);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_set_uuid (kvmsg);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_fmt_body (kvmsg, <span style="color:#BA2121">"%s"</span>, value);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_set_prop (kvmsg, <span style="color:#BA2121">"ttl"</span>, ttl);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_send<tt><span style="white-space: pre-wrap;">     </span></tt>(kvmsg, self<span style="color:#666666">-&gt;</span>publisher);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_store<tt><span style="white-space: pre-wrap;">    </span></tt>(<span style="color:#666666">&amp;</span>kvmsg, self<span style="color:#666666">-&gt;</span>kvmap);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (key);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (value);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (ttl);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>if</strong></span> (streq (command, <span style="color:#BA2121">"GET"</span>)) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>key <span style="color:#666666">=</span> zmsg_popstr (msg);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>kvmsg_t <span style="color:#666666">*</span>kvmsg <span style="color:#666666">=</span> (kvmsg_t <span style="color:#666666">*</span>) zhash_lookup (self<span style="color:#666666">-&gt;</span>kvmap, key);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>byte <span style="color:#666666">*</span>value <span style="color:#666666">=</span> kvmsg<span style="color:#666666">?</span> kvmsg_body (kvmsg)<span style="color:#666666">:</span> <span style="color:#008000">NULL</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (value)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmq_send (self<span style="color:#666666">-&gt;</span>pipe, value, kvmsg_size (kvmsg), <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zstr_send (self<span style="color:#666666">-&gt;</span>pipe, <span style="color:#BA2121">""</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (key);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>free (command);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zmsg_destroy (<span style="color:#666666">&amp;</span>msg);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The asynchronous agent manages a server pool and handles the<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>request-reply dialog when the application asks for it:</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<span style="color:#0000FF">clone_agent</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>args, zctx_t <span style="color:#666666">*</span>ctx, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>pipe)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>agent_t <span style="color:#666666">*</span>self <span style="color:#666666">=</span> agent_new (ctx, pipe);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zmq_pollitem_t poll_set <span style="white-space: pre-wrap;">[]</span> <span style="color:#666666">=</span> {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>{ pipe, <span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> },<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>{ <span style="color:#666666">0</span>,<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#666666">0</span>, ZMQ_POLLIN, <span style="color:#666666">0</span> }<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> poll_timer <span style="color:#666666">=</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> poll_size <span style="color:#666666">=</span> <span style="color:#666666">2</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>server_t <span style="color:#666666">*</span>server <span style="color:#666666">=</span> self<span style="color:#666666">-&gt;</span>server <span style="white-space: pre-wrap;">[</span>self<span style="color:#666666">-&gt;</span>cur_server<span style="white-space: pre-wrap;">]</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>switch</strong></span> (self<span style="color:#666666">-&gt;</span>state) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>case</strong></span> STATE_INITIAL:<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>In this state we ask the server for a snapshot,</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>if we have a server to talk to…</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>nbr_servers <span style="color:#666666">&gt;</span> <span style="color:#666666">0</span>) {<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>zclock_log (<span style="color:#BA2121">"I: waiting for server at %s:%d…"</span>,<br>
<tt><span style="white-space: pre-wrap;">                        </span></tt>server<span style="color:#666666">-&gt;</span>address, server<span style="color:#666666">-&gt;</span>port);<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt><span style="color:#008000"><strong>if</strong></span> (server<span style="color:#666666">-&gt;</span>requests <span style="color:#666666">&lt;</span> <span style="color:#666666">2</span>) {<br>
<tt><span style="white-space: pre-wrap;">                        </span></tt>zstr_sendm (server<span style="color:#666666">-&gt;</span>snapshot, <span style="color:#BA2121">"ICANHAZ?"</span>);<br>
<tt><span style="white-space: pre-wrap;">                        </span></tt>zstr_send<tt><span style="white-space: pre-wrap;">  </span></tt>(server<span style="color:#666666">-&gt;</span>snapshot, self<span style="color:#666666">-&gt;</span>subtree);<br>
<tt><span style="white-space: pre-wrap;">                        </span></tt>server<span style="color:#666666">-&gt;</span>requests<span style="color:#666666">++</span>;<br>
<tt><span style="white-space: pre-wrap;">                    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>server<span style="color:#666666">-&gt;</span>expiry <span style="color:#666666">=</span> zclock_time () <span style="color:#666666">+</span> SERVER_TTL;<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>self<span style="color:#666666">-&gt;</span>state <span style="color:#666666">=</span> STATE_SYNCING;<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>poll_set <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>.socket <span style="color:#666666">=</span> server<span style="color:#666666">-&gt;</span>snapshot;<br>
<tt><span style="white-space: pre-wrap;">                </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>poll_size <span style="color:#666666">=</span> <span style="color:#666666">1</span>;<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>case</strong></span> STATE_SYNCING:<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>In this state we read from snapshot and we expect</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>the server to respond, else we fail over.</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt>poll_set <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>.socket <span style="color:#666666">=</span> server<span style="color:#666666">-&gt;</span>snapshot;<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>case</strong></span> STATE_ACTIVE:<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>In this state we read from subscriber and we expect</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>the server to give HUGZ, else we fail over.</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt>poll_set <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>.socket <span style="color:#666666">=</span> server<span style="color:#666666">-&gt;</span>subscriber;<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (server) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>poll_timer <span style="color:#666666">=</span> (server<span style="color:#666666">-&gt;</span>expiry <span style="color:#666666">-</span> zclock_time ())<br>
<tt><span style="white-space: pre-wrap;">                       </span></tt><span style="color:#666666">*</span> ZMQ_POLL_MSEC;<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (poll_timer <span style="color:#666666">&lt;</span> <span style="color:#666666">0</span>)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt>poll_timer <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We're ready to process incoming messages; if nothing at all</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>comes from our server within the timeout, that means the</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>server is dead:</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">int</span> rc <span style="color:#666666">=</span> zmq_poll (poll_set, poll_size, poll_timer);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (rc <span style="color:#666666">==</span> <span style="color:#666666">-</span><span style="color:#666666">1</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Context has been shut down</em></span></p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (poll_set <span style="white-space: pre-wrap;">[</span><span style="color:#666666">0</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (agent_control_message (self))<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (poll_set <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>.revents <span style="color:#666666">&amp;</span> ZMQ_POLLIN) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>kvmsg_t <span style="color:#666666">*</span>kvmsg <span style="color:#666666">=</span> kvmsg_recv (poll_set <span style="white-space: pre-wrap;">[</span><span style="color:#666666">1</span><span style="white-space: pre-wrap;">]</span>.socket);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>kvmsg)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Interrupted</em></span></p>
<p><tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Anything from server resets its expiry time</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>server<span style="color:#666666">-&gt;</span>expiry <span style="color:#666666">=</span> zclock_time () <span style="color:#666666">+</span> SERVER_TTL;<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>state <span style="color:#666666">==</span> STATE_SYNCING) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Store in snapshot until we're finished</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt>server<span style="color:#666666">-&gt;</span>requests <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>if</strong></span> (streq (kvmsg_key (kvmsg), <span style="color:#BA2121">"KTHXBAI"</span>)) {<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>self<span style="color:#666666">-&gt;</span>sequence <span style="color:#666666">=</span> kvmsg_sequence (kvmsg);<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>self<span style="color:#666666">-&gt;</span>state <span style="color:#666666">=</span> STATE_ACTIVE;<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>zclock_log (<span style="color:#BA2121">"I: received from %s:%d snapshot=%d"</span>,<br>
<tt><span style="white-space: pre-wrap;">                        </span></tt>server<span style="color:#666666">-&gt;</span>address, server<span style="color:#666666">-&gt;</span>port,<br>
<tt><span style="white-space: pre-wrap;">                        </span></tt>(<span style="color:#B00040">int</span>) self<span style="color:#666666">-&gt;</span>sequence);<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>kvmsg_destroy (<span style="color:#666666">&amp;</span>kvmsg);<br>
<tt><span style="white-space: pre-wrap;">                </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>kvmsg_store (<span style="color:#666666">&amp;</span>kvmsg, self<span style="color:#666666">-&gt;</span>kvmap);<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>state <span style="color:#666666">==</span> STATE_ACTIVE) {<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Discard out-of-sequence updates, incl. HUGZ</em></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>if</strong></span> (kvmsg_sequence (kvmsg) <span style="color:#666666">&gt;</span> self<span style="color:#666666">-&gt;</span>sequence) {<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>self<span style="color:#666666">-&gt;</span>sequence <span style="color:#666666">=</span> kvmsg_sequence (kvmsg);<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>kvmsg_store (<span style="color:#666666">&amp;</span>kvmsg, self<span style="color:#666666">-&gt;</span>kvmap);<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>zclock_log (<span style="color:#BA2121">"I: received from %s:%d update=%d"</span>,<br>
<tt><span style="white-space: pre-wrap;">                        </span></tt>server<span style="color:#666666">-&gt;</span>address, server<span style="color:#666666">-&gt;</span>port,<br>
<tt><span style="white-space: pre-wrap;">                        </span></tt>(<span style="color:#B00040">int</span>) self<span style="color:#666666">-&gt;</span>sequence);<br>
<tt><span style="white-space: pre-wrap;">                </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>kvmsg_destroy (<span style="color:#666666">&amp;</span>kvmsg);<br>
<tt><span style="white-space: pre-wrap;">            </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>else</strong></span> {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Server has died, failover to next</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zclock_log (<span style="color:#BA2121">"I: server at %s:%d didn't give HUGZ"</span>,<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>server<span style="color:#666666">-&gt;</span>address, server<span style="color:#666666">-&gt;</span>port);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>self<span style="color:#666666">-&gt;</span>cur_server <span style="color:#666666">=</span> (self<span style="color:#666666">-&gt;</span>cur_server <span style="color:#666666">+</span> <span style="color:#666666">1</span>) <span style="color:#666666">%</span> self<span style="color:#666666">-&gt;</span>nbr_servers;<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>self<span style="color:#666666">-&gt;</span>state <span style="color:#666666">=</span> STATE_INITIAL;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>agent_destroy (<span style="color:#666666">&amp;</span>self);<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/java:clone" target="_blank">Java</a> | <a href="http://zguide.zeromq.org/py:clone" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | C# | Clojure | CL | Delphi | Erlang | F# | Felix | Go | Haskell | Haxe | Lua | Node.js | Objective-C | ooc | Perl | PHP | Q | Racket | Ruby | Scala | Tcl</a></span>
<p><a name="the-community"></a><br>
<a name="Chapter-The-ZeroMQ-Community"></a><a name="header-131"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h2 id="toc130"><span><a href="http://zguide.zeromq.org/page:all#Chapter-The-ZeroMQ-Community">Chapter 6 - The ZeroMQ Community</a></span></h2>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-130">prev</a> <a href="http://zguide.zeromq.org/page:all#header-132">next</a></td>
</tr>
</tbody></table>
<p>People sometimes ask me what's so special about ZeroMQ. My standard answer is that ZeroMQ is arguably the best answer we have to the vexing question of "How do we make the distributed software that the 21st century demands?" But more than that, ZeroMQ is special because of its community. This is ultimately what separates the wolves from the sheep.</p>
<p>There are three main open source patterns. The first is the large firm dumping code to break the market for others. This is the Apache Foundation model. The second is tiny teams or small firms building their dream. This is the most common open source model, which can be very successful commercially. The last is aggressive and diverse communities that swarm over a problem landscape. This is the Linux model, and the one to which we aspire with ZeroMQ.</p>
<p>It's hard to overemphasize the power and persistence of a working open source community. There really does not seem to be a better way of making software for the long term. Not only does the community choose the best problems to solve, it solves them minimally, carefully, and it then looks after these answers for years, decades, until they're no longer relevant, and then it quietly puts them away.</p>
<p>To really benefit from ZeroMQ, you need to understand the community. At some point down the road you'll want to submit a patch, an issue, or an add-on. You might want to ask someone for help. You will probably want to bet a part of your business on ZeroMQ, and when I tell you that the community is much, much more important than the company that backs the product, even though I'm CEO of that company, this should be significant.</p>
<p>In this chapter I'm going to look at our community from several angles and conclude by explaining in detail our contract for collaboration, which <a href="http://rfc.zeromq.org/spec:22">we call "C4"</a>. You should find the discussion useful for your own work. We've also adapted the ZeroMQ C4 process for closed source projects with good success.</p>
<p>We'll cover:</p>
<ul>
<li>The rough structure of ZeroMQ as a set of projects</li>
<li>What "software architecture" is really about</li>
<li>Why we use the LGPL and not the BSD license</li>
<li>How we designed and grew the ZeroMQ community</li>
<li>The business that backs ZeroMQ</li>
<li>Who owns the ZeroMQ source code</li>
<li>How to make and submit a patch to ZeroMQ</li>
<li>Who controls what patches actually go into ZeroMQ</li>
<li>How we guarantee compatibility with old code</li>
<li>Why we don't use public git branches</li>
<li>Who decides on the ZeroMQ road map</li>
<li>A worked example of a change to <tt>libzmq</tt></li>
</ul>
<p><a name="Architecture-of-the-ZeroMQ-Community"></a><a name="header-132"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc131"><span><a href="http://zguide.zeromq.org/page:all#Architecture-of-the-ZeroMQ-Community">Architecture of the ZeroMQ Community</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-131">prev</a> <a href="http://zguide.zeromq.org/page:all#header-133">next</a></td>
</tr>
</tbody></table>
<p>You know that ZeroMQ is an LGPL-licensed project. In fact it's a collection of projects, built around the core library, <tt>libzmq</tt>. I'll visualize these projects as an expanding galaxy:</p>
<ul>
<li>At the core, <tt>libzmq</tt> is the ZeroMQ core library. It's written in C++, with a low-level C API. The code is nasty, mainly because it's highly optimized but also because it's written in C++, a language that lends itself to subtle and deep nastiness. Martin Sustrik wrote the bulk of this code. Today it has dozens of people who maintain different parts of it.</li>
</ul>
<ul>
<li>Around <tt>libzmq</tt>, there are about 50 <em>bindings</em>. These are individual projects that create higher-level APIs for ZeroMQ, or at least map the low-level API into other languages. The bindings vary in quality from experimental to utterly awesome. Probably the most impressive binding is <a href="https://github.com/zeromq/pyzmq">PyZMQ</a>, which was one of the first community projects on top of ZeroMQ. If you are a binding author, you should really study PyZMQ and aspire to making your code and community as great.</li>
</ul>
<ul>
<li>A lot of languages have multiple bindings (Erlang, Ruby, C#, at least) written by different people over time, or taking varying approaches. We don't regulate these in any way. There are no "official" bindings. You vote by using one or the other, contributing to it, or ignoring it.</li>
</ul>
<ul>
<li>There are a series of reimplementations of <tt>libzmq</tt>, starting with JeroMQ, a full Java translation of the library, which is now the basis for NetMQ, a C# stack. These native stacks offer similar or identical APIs, and speak the same protocol (ZMTP) as <tt>libzmq</tt>.</li>
</ul>
<ul>
<li>On top of the bindings are a lot of projects that use ZeroMQ or build on it. See the "Labs" page on the wiki for a long list of projects and proto-projects that use ZeroMQ in some way. There are frameworks, web servers like Mongrel2, brokers like Majordomo, and enterprise open source tools like Storm.</li>
</ul>
<p><tt>Libzmq</tt>, most of the bindings, and some of the outer projects sit in the <a href="https://github.com/organizations/zeromq">ZeroMQ community "organization"</a> on GitHub. This organization is "run" by a group consisting of the most senior binding authors. There's very little to run as it's almost all self-managing and there's zero conflict these days.</p>
<p>iMatix, my firm, plays a specific role in the community. We own the trademarks and enforce them discretely in order to make sure that if you download a package calling itself "ZeroMQ", you can trust what you are getting. People have on rare occasion tried to hijack the name, maybe believing that "free software" means there is no property at stake and no one willing to defend it. One thing you'll understand from this chapter is how seriously we take the process behind our software (and I mean "us" as a community, not a company). iMatix backs the community by enforcing that process on anything calling itself "ZeroMQ" or "ZeroMQ". We also put money and time into the software and packaging for reasons I'll explain later.</p>
<p>It is not a charity exercise. ZeroMQ is a for-profit project, and a very profitable one. The profits are widely distributed among all those who invest in it. It's really that simple: take the time to become an expert in ZeroMQ, or build something useful on top of ZeroMQ, and you'll find your value as an individual, or team, or company increasing. iMatix enjoys the same benefits as everyone else in the community. It's win-win to everyone except our competitors, who find themselves facing a threat they can't beat and can't really escape. ZeroMQ dominates the future world of massively distributed software.</p>
<p>My firm doesn't just have the community's back—we also built the community. This was deliberate work; in the original ZeroMQ white paper from 2007, there were two projects. One was technical, how to make a better messaging system. The second was how to build a community that could take the software to dominant success. Software dies, but community survives.</p>
<p><a name="How-to-Make-Really-Large-Architectures"></a><a name="header-133"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc132"><span><a href="http://zguide.zeromq.org/page:all#How-to-Make-Really-Large-Architectures">How to Make Really Large Architectures</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-132">prev</a> <a href="http://zguide.zeromq.org/page:all#header-134">next</a></td>
</tr>
</tbody></table>
<p>There are, it has been said (at least by people reading this sentence out loud), two ways to make really large-scale software. Option One is to throw massive amounts of money and problems at empires of smart people, and hope that what emerges is not yet another career killer. If you're very lucky and are building on lots of experience, have kept your teams solid, and are not aiming for technical brilliance, and are furthermore incredibly lucky, it works.</p>
<p>But gambling with hundreds of millions of others' money isn't for everyone. For the rest of us who want to build large-scale software, there's Option Two, which is open source, and more specifically, <em>free software</em>. If you're asking how the choice of software license is relevant to the scale of the software you build, that's the right question.</p>
<p>The brilliant and visionary Eben Moglen once said, roughly, that a free software license is the contract on which a community builds. When I heard this, about ten years ago, the idea came to me—<em>Can we deliberately grow free software communities</em>?</p>
<p>Ten years later, the answer is "yes", and there is almost a science to it. I say "almost" because we don't yet have enough evidence of people doing this deliberately with a documented, reproducible process. It is what I'm trying to do with <a href="http://cultureandempire.com/cande.html#/4/6">Social Architecture</a>. ZeroMQ came after Wikidot, after the <a href="http://www.digistan.org/">Digital Standards Organization</a> (Digistan) and after the <a href="http://www.ffii.org/">Foundation for a Free Information Infrastructure</a> (aka the FFII, an NGO that fights against software patents). This all came after a lot of less successful community projects like Xitami and Libero. My main takeaway from a long career of projects of every conceivable format is: if you want to build truly large-scale and long-lasting software, aim to build a free software community.</p>
<p><a name="Psychology-of-Software-Architecture"></a><a name="header-134"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc133"><span><a href="http://zguide.zeromq.org/page:all#Psychology-of-Software-Architecture">Psychology of Software Architecture</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-133">prev</a> <a href="http://zguide.zeromq.org/page:all#header-135">next</a></td>
</tr>
</tbody></table>
<p>Dirkjan Ochtman pointed me to <a href="http://en.wikipedia.org/wiki/Software_architecture">Wikipedia's definition of Software Architecture</a> as "the set of structures needed to reason about the system, which comprise software elements, relations among them, and properties of both". For me this vapid and circular jargon is a good example of how miserably little we understand what actually makes a successful large scale software architecture.</p>
<p>Architecture is the art and science of making large artificial structures for human use. If there is one thing I've learned and applied successfully in 30 years of making larger and larger software systems, it is this: <em>software is about people</em>. Large structures in themselves are meaningless. It's how they function for <em>human use</em> that matters. And in software, human use starts with the programmers who make the software itself.</p>
<p>The core problems in software architecture are driven by human psychology, not technology. There are many ways our psychology affects our work. I could point to the way teams seem to get stupider as they get larger or when they have to work across larger distances. Does that mean the smaller the team, the more effective? How then does a large global community like ZeroMQ manage to work successfully?</p>
<p>The ZeroMQ community wasn't accidental. It was a deliberate design, my contribution to the early days when the code came out of a cellar in Bratislava. The design was based on my pet science of "Social Architecture", which <a href="http://en.wikipedia.org/wiki/Social_architecture">Wikipedia defines</a> as "the conscious design of an environment that encourages a desired range of social behaviors leading towards some goal or set of goals." I define this as more specifically as "the process, and the product, of planning, designing, and growing an online community."</p>
<p>One of the tenets of Social Architecture is that <em>how we organize</em> is more significant than <em>who we are</em>. The same group, organized differently, can produce wholly different results. We are like peers in a ZeroMQ network, and our communication patterns have a dramatic impact on our performance. Ordinary people, well connected, can far outperform a team of experts using poor patterns. If you're the architect of a larger ZeroMQ application, you're going to have to help others find the right patterns for working together. Do this right, and your project can succeed. Do it wrong, and your project will fail.</p>
<p>The two most important psychological elements are that we're really bad at understanding complexity and that we are so good at working together to divide and conquer large problems. We're highly social apes, and kind of smart, but only in the right kind of crowd.</p>
<p>So here is my short list of the Psychological Elements of Software Architecture:</p>
<ul>
<li><strong>Stupidity</strong>: our mental bandwidth is limited, so we're all stupid at some point. The architecture has to be simple to understand. This is the number one rule: simplicity beats functionality, every single time. If you can't understand an architecture on a cold gray Monday morning before coffee, it is too complex.</li>
</ul>
<ul>
<li><strong>Selfishness</strong>: we act only out of self-interest, so the architecture must create space and opportunity for selfish acts that benefit the whole. Selfishness is often indirect and subtle. For example, I'll spend hours helping someone else understand something because that could be worth days to me later.</li>
</ul>
<ul>
<li><strong>Laziness</strong>: we make lots of assumptions, many of which are wrong. We are happiest when we can spend the least effort to get a result or to test an assumption quickly, so the architecture has to make this possible. Specifically, that means it must be simple.</li>
</ul>
<ul>
<li><strong>Jealousy</strong>: we're jealous of others, which means we'll overcome our stupidity and laziness to prove others wrong and beat them in competition. The architecture thus has to create space for public competition based on fair rules that anyone can understand.</li>
</ul>
<ul>
<li><strong>Fear</strong>: we're unwilling to take risks, especially if it makes us look stupid. Fear of failure is a major reason people conform and follow the group in mass stupidity. The architecture should make silent experimentation easy and cheap, giving people opportunity for success without punishing failure.</li>
</ul>
<ul>
<li><strong>Reciprocity</strong>: we'll pay extra in terms of hard work, even money, to punish cheats and enforce fair rules. The architecture should be heavily rule-based, telling people how to work together, but not what to work on.</li>
</ul>
<ul>
<li><strong>Conformity</strong>: we're happiest to conform, out of fear and laziness, which means if the patterns are good, clearly explained and documented, and fairly enforced, we'll naturally choose the right path every time.</li>
</ul>
<ul>
<li><strong>Pride</strong>: we're intensely aware of our social status, and we'll work hard to avoid looking stupid or incompetent in public. The architecture has to make sure every piece we make has our name on it, so we'll have sleepless nights stressing about what others will say about our work.</li>
</ul>
<ul>
<li><strong>Greed</strong>: we're ultimately economic animals (see selfishness), so the architecture has to give us economic incentive to invest in making it happen. Maybe it's polishing our reputation as experts, maybe it's literally making money from some skill or component. It doesn't matter what it is, but there must be economic incentive. Think of architecture as a market place, not an engineering design.</li>
</ul>
<p>These strategies work on a large scale but also on a small scale, within an organization or team.</p>
<p><a name="The-Importance-of-Contracts"></a><a name="header-135"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc134"><span><a href="http://zguide.zeromq.org/page:all#The-Importance-of-Contracts">The Importance of Contracts</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-134">prev</a> <a href="http://zguide.zeromq.org/page:all#header-136">next</a></td>
</tr>
</tbody></table>
<p>Let me discuss a contentious but important area, which is what license to choose. I'll say "BSD" to cover MIT, X11, BSD, Apache, and similar licenses, and "GPL" to cover GPLv3, LGPLv3, and AGPLv3. The significant difference is the obligation to share back any forked versions, which prevents any entity from capturing the software, and thus keeps it "free".</p>
<p>A software license isn't technically a contract since you don't sign anything. But broadly, calling it a contract is useful since it takes the obligations of each party, and makes them legally enforceable in court, under copyright law.</p>
<p>You might ask, why do we need contracts at all to make open source? Surely it's all about decency, goodwill, people working together for selfless motives. Surely the principle of "less is more" applies here of all places? Don't more rules mean less freedom? Do we really need lawyers to tell us how to work together? It seems cynical and even counter-productive to force a restrictive set of rules on the happy communes of free and open source software.</p>
<p>But the truth about human nature is not that pretty. We're not really angels, nor devils, just self-interested winners descended from a billion-year unbroken line of winners. In business, marriage, and collective works, sooner or later, we either stop caring, or we fight and we argue.</p>
<p>Put this another way: a collective work has two extreme outcomes. Either it's a failure, irrelevant, and worthless, in which case every sane person walks away, without a fight. Or, it's a success, relevant, and valuable, in which case we start jockeying for power, control, and often, money.</p>
<p>What a well-written contract does is to protect those valuable relationships from conflict. A marriage where the terms of divorce are clearly agreed up-front is much less likely to end in divorce. A business deal where both parties agree how to resolve various classic conflicts—such as one party stealing the others' clients or staff—is much less likely to end in conflict.</p>
<p>Similarly, a software project that has a well-written contract that defines the terms of breakup clearly is much less likely to end in breakup. The alternative seems to be to immerse the project into a larger organization that can assert pressure on teams to work together (or lose the backing and branding of the organization). This is for example how the Apache Foundation works. In my experience organization building has its own costs, and ends up favoring wealthier participants (who can afford those sometimes huge costs).</p>
<p>In an open source or free software project, breakup usually takes the form of a fork, where the community splits into two or more groups, each with different visions of the future. During the honeymoon period of a project, which can last years, there's no question of a breakup. It is as a project begins to be worth money, or as the main authors start to burn out, that the goodwill and generosity tends to dry up.</p>
<p>So when discussing software licenses, for the code you write or the code you use, a little cynicism helps. Ask yourself, not "which license will attract more contributors?" because the answer to that lies in the mission statement and contribution process. Ask yourself, "if this project had a big fight, and split three ways, which license would save us?" Or, "if the whole team was bought by a hostile firm that wanted to turn this code into a proprietary product, which license would save us?"</p>
<p>Long-term survival means enduring the bad times, as well as enjoying the good ones.</p>
<p>When BSD projects fork, they cannot easily merge again. Indeed, one-way forking of BSD projects is quite systematic: every time BSD code ends up in a commercial project, this is what's happened. When GPL projects fork, however, re-merging is trivial.</p>
<p>The GPL's story is relevant here. Though communities of programmers sharing their code openly were already significant by the 1980's, they tended to use minimal licenses that worked as long as no real money got involved. There was an important language stack called Emacs, originally built in Lisp by Richard Stallman. Another programmer, James Gosling (who later gave us Java), rewrote Emacs in C with the help of many contributors, on the assumption that it would be open. Stallman got that code and used it as the basis for his own C version. Gosling then sold the code to a firm which turned around and blocked anyone distributing a competing product. Stallman found this sale of the common work hugely unethical, and began developing a reusable license that would protect communities from this.</p>
<p>What eventually emerged was the GNU General Public License, which used traditional copyright to force remixability. It was a neat hack that spread to other domains, for instance the Creative Commons for photography and music. In 2007, we saw version 3 of the license, which was a response to belated attacks from Microsoft and others on the concept. It has become a long and complex document but corporate copyright lawyers have become familiar with it and in my experience, few companies mind using GPL software and libraries, so long as the boundaries are clearly defined.</p>
<p>Thus, a good contract—and I consider the modern GPL to be the best for software—lets programmers work together without upfront agreements, organizations, or assumptions of decency and goodwill. It makes it cheaper to collaborate, and turns conflict into healthy competition. GPL doesn't just define what happens with a fork, it actively encourages forks as a tool for experimentation and learning. Whereas a fork can kill a project with a "more liberal" license, GPL projects thrive on forks since successful experiments can, by contract, be remixed back into the mainstream.</p>
<p>Yes, there are many thriving BSD projects and many dead GPL ones. It's always wrong to generalize. A project will thrive or die for many reasons. However, in a competitive sport, one needs every advantage.</p>
<p>The other important part of the BSD vs. GPL story is what I call "leakage", which is the effect of pouring water into a pot with a small but real hole in the bottom.</p>
<p><a name="Eat-Me"></a><a name="header-136"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc135"><span><a href="http://zguide.zeromq.org/page:all#Eat-Me">Eat Me</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-135">prev</a> <a href="http://zguide.zeromq.org/page:all#header-137">next</a></td>
</tr>
</tbody></table>
<p>Here is a story. It happened to the eldest brother-in-law of the cousin of a friend of mine's colleague at work. His name was, and still is, Patrick.</p>
<p>Patrick was a computer scientist with a PhD in advanced network topologies. He spent two years and his savings building a new product, and choose the BSD license because he believed that would get him more adoption. He worked in his attic, at great personal cost, and proudly published his work. People applauded, for it was truly fantastic, and his mailing lists were soon abuzz with activity and patches and happy chatter. Many companies told him how they were saving millions using his work. Some of them even paid him for consultancy and training. He was invited to speak at conferences and started collecting badges with his name on them. He started a small business, hired a friend to work with him, and dreamed of making it big.</p>
<p>Then one day, someone pointed him to a new project, GPL licensed, which had forked his work and was improving on it. He was irritated and upset, and asked how people—fellow open sourcers, no less!—would so shamelessly steal his code. There were long arguments on the list about whether it was even legal to relicense their BSD code as GPL code. Turned out, it was. He tried to ignore the new project, but then he soon realized that new patches coming from that project <em>couldn't even be merged back</em> into his work!</p>
<p>Worse, the GPL project got popular and some of his core contributors made first small, and then larger patches to it. Again, he couldn't use those changes, and he felt abandoned. Patrick went into a depression, his girlfriend left him for an international currency dealer called, weirdly, Patrice, and he stopped all work on the project. He felt betrayed, and utterly miserable. He fired his friend, who took it rather badly and told everyone that Patrick was a closet banjo player. Finally, Patrick took a job as a project manager for a cloud company, and by the age of forty, he had stopped programming even for fun.</p>
<p>Poor Patrick. I almost felt sorry for him. Then I asked him, "Why didn't you choose the GPL?" "Because it's a restrictive viral license", he replied. I told him, "You may have a PhD, and you may be the eldest brother-in-law of the cousin of a friend of my colleague, but you are an idiot and Monique was smart to leave you. You published your work inviting people to please steal your code as long as they kept this 'please steal my code' statement in the resulting work", and when people did exactly that, you got upset. Worse, you were a hypocrite because when they did it in secret, you were happy, but when they did it openly, you felt betrayed."</p>
<p>Seeing your hard work captured by a smarter team and then used against you is enormously painful, so why even make that possible? Every proprietary project that uses BSD code is capturing it. A public GPL fork is perhaps more humiliating, but it's fully self-inflicted.</p>
<p>BSD is like food. It literally (and I mean that metaphorically) whispers "eat me" in the little voice one imagines a cube of cheese might use when it's sitting next to an empty bottle of the best beer in the world, which is of course Orval, brewed by an ancient and almost extinct order of silent Belgian monks called <em>Les Gars Labas Qui Fabrique l'Orval</em>. The BSD license, like its near clone MIT/X11, was designed specifically by a university (Berkeley) with no profit motive to leak work and effort. It is a way to push subsidized technology at below its cost price, a dumping of under-priced code in the hope that it will break the market for others. BSD is an <em>excellent</em> strategic tool, but only if you're a large well-funded institution that can afford to use Option One. The Apache license is BSD in a suit.</p>
<p>For us small businesses who aim our investments like precious bullets, leaking work and effort is unacceptable. Breaking the market is great, but we cannot afford to subsidize our competitors. The BSD networking stack ended up putting Windows on the Internet. We cannot afford battles with those we should naturally be allies with. We cannot afford to make fundamental business errors because in the end, that means we have to fire people.</p>
<p>It comes down to behavioral economics and game theory. <em>The license we choose modifies the economics of those who use our work</em>. In the software industry, there are friends, foes, and food. BSD makes most people see us as lunch. Closed source makes most people see us as enemies (do you <em>like</em> paying people for software?) GPL, however, makes most people, with the exception of the Patricks of the world, our allies. Any fork of ZeroMQ is license compatible with ZeroMQ, to the point where we <em>encourage</em> forks as a valuable tool for experimentation. Yes, it can be weird to see someone try to run off with the ball but here's the secret, <em>I can get it back any time I want.</em></p>
<p><a name="The-Process"></a><a name="header-137"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc136"><span><a href="http://zguide.zeromq.org/page:all#The-Process">The Process</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-136">prev</a> <a href="http://zguide.zeromq.org/page:all#header-138">next</a></td>
</tr>
</tbody></table>
<p>If you've accepted my thesis up to now, great! Now, I'll explain the rough process by which we actually build an open source community. This was how we built or grew or gently steered the ZeroMQ community into existence.</p>
<p>Your goal as leader of a community is to motivate people to get out there and explore; to ensure they can do so safely and without disturbing others; to reward them when they make successful discoveries; and to ensure they share their knowledge with everyone else (and not because we ask them, not because they feel generous, but because it's The Law).</p>
<p>It is an iterative process. You make a small product, at your own cost, but in public view. You then build a small community around that product. If you have a small but real hit, the community then helps design and build the next version, and grows larger. And then that community builds the next version, and so on. It's evident that you remain part of the community, maybe even a majority contributor, but the more control you try to assert over the material results, the less people will want to participate. Plan your own retirement well before someone decides you are their next problem.</p>
<p><a name="Crazy-Beautiful-and-Easy"></a><a name="header-138"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc137"><span><a href="http://zguide.zeromq.org/page:all#Crazy-Beautiful-and-Easy">Crazy, Beautiful, and Easy</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-137">prev</a> <a href="http://zguide.zeromq.org/page:all#header-139">next</a></td>
</tr>
</tbody></table>
<p>You need a goal that's crazy and simple enough to get people out of bed in the morning. Your community has to attract the very best people and that demands something special. With ZeroMQ, we said we were going to make "the Fastest. Messaging. Ever.", which qualifies as a good motivator. If we'd said, we're going to make "a smart transport layer that'll connect your moving pieces cheaply and flexibly across your enterprise", we'd have failed.</p>
<p>Then your work must be beautiful, immediately useful, and attractive. Your contributors are users who want to explore just a little beyond where they are now. Make it simple, elegant, and brutally clean. The experience when people run or use your work should be an emotional one. They should <em>feel</em> something, and if you accurately solved even just one big problem that until then they didn't quite realize they faced, you'll have a small part of their soul.</p>
<p>It must be easy to understand, use, and join. Too many projects have barriers to access: put yourself in the other person's mind and see all the reasons they come to your site, thinking "Um, interesting project, but…" and then leave. You want them to stay and try it, just once. Use GitHub and put the issue tracker right there.</p>
<p>If you do these things well, your community will be smart but more importantly, it will be intellectually and geographically diverse. This is really important. A group of like-minded experts cannot explore the problem landscape well. They tend to make big mistakes. Diversity beats education any time.</p>
<p><a name="Stranger-Meet-Stranger"></a><a name="header-139"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc138"><span><a href="http://zguide.zeromq.org/page:all#Stranger-Meet-Stranger">Stranger, Meet Stranger</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-138">prev</a> <a href="http://zguide.zeromq.org/page:all#header-140">next</a></td>
</tr>
</tbody></table>
<p>How much up-front agreement do two people need to work together on something? In most organizations, a lot. But you can bring this cost down to near-zero, and then people can collaborate without having ever met, done a phone conference, meeting, or business trip to discuss Roles and Responsibilities over way too many bottles of cheap Korean rice wine.</p>
<p>You need well-written rules that are designed by cynical people like me to force strangers into mutually beneficial collaboration instead of conflict. The GPL is a good start. GitHub and its fork/merge strategy is a good follow-up. And then you want something like our <a href="http://rfc.zeromq.org/spec:22">C4 rulebook</a> to control how work actually happens.</p>
<p>C4 (which I now use for every new open source project) has detailed and tested answers to a lot of common mistakes people make, such as the sin of working offline in a corner with others "because it's faster". Transparency is essential to get trust, which is essential to get scale. By forcing every single change through a single transparent process, you build real trust in the results.</p>
<p>Another cardinal sin that many open source developers make is to place themselves above others. "I founded this project thus my intellect is superior to that of others". It's not just immodest and rude, and usually inaccurate, it's also poor business. The rules must apply equally to everyone, without distinction. You are part of the community. Your job, as founder of a project, is not to impose your vision of the product over others, but to make sure the rules are good, honest, and <em>enforced</em>.</p>
<p><a name="Infinite-Property"></a><a name="header-140"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc139"><span><a href="http://zguide.zeromq.org/page:all#Infinite-Property">Infinite Property</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-139">prev</a> <a href="http://zguide.zeromq.org/page:all#header-141">next</a></td>
</tr>
</tbody></table>
<p>One of the saddest myths of the knowledge business is that ideas are a sensible form of property. It's medieval nonsense that should have been junked along with slavery, but sadly it's still making too many powerful people too much money.</p>
<p>Ideas are cheap. What does work sensibly as property is the hard work we do in building a market. "You eat what you kill" is the right model for encouraging people to work hard. Whether it's moral authority over a project, money from consulting, or the sale of a trademark to some large, rich firm: if you make it, you own it. But what you really own is "footfall", participants in your project, which ultimately defines your power.</p>
<p>To do this requires infinite free space. Thankfully, GitHub solved this problem for us, for which I will die a grateful person (there are many reasons to be grateful in life, which I won't list here because we only have a hundred or so pages left, but this is one of them).</p>
<p>You cannot scale a single project with many owners like you can scale a collection of many small projects, each with fewer owners. When we embrace forks, a person can become an "owner" with a single click. Now they just have to convince others to join by demonstrating their unique value.</p>
<p>So in ZeroMQ, we aimed to make it easy to write bindings on top of the core library, and we stopped trying to make those bindings ourselves. This created space for others to make those, become their owners, and get that credit.</p>
<p><a name="Care-and-Feeding"></a><a name="header-141"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc140"><span><a href="http://zguide.zeromq.org/page:all#Care-and-Feeding">Care and Feeding</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-140">prev</a> <a href="http://zguide.zeromq.org/page:all#header-142">next</a></td>
</tr>
</tbody></table>
<p>I wish a community could be 100% self-steering, and perhaps one day this will work, but today it's not the case. We're very close with ZeroMQ, but from my experience a community needs four types of care and feeding:</p>
<ul>
<li>First, simply because most people are too nice, we need some kind of symbolic leadership or owners who provide ultimate authority in case of conflict. Usually it's the founders of the community. I've seen it work with self-elected groups of "elders", but old men like to talk a lot. I've seen communities split over the question "who is in charge?", and setting up legal entities with boards and such seems to make arguments over control worse, not better. Maybe because there seems to be more to fight over. One of the real benefits of free software is that it's always remixable, so instead of fighting over a pie, one simply forks the pie.</li>
</ul>
<ul>
<li>Second, communities need living rules, and thus they need a lawyer able to formulate and write these down. Rules are critical; when done right, they remove friction. When done wrong, or neglected, we see real friction and argument that can drive away the nice majority, leaving the argumentative core in charge of the burning house. One thing I've tried to do with the ZeroMQ and previous communities is create reusable rules, which perhaps means we don't need lawyers as much.</li>
</ul>
<ul>
<li>Thirdly, communities need some kind of financial backing. This is the jagged rock that breaks most ships. If you starve a community, it becomes more creative but the core contributors burn out. If you pour too much money into it, you attract the professionals, who never say "no", and the community loses its diversity and creativity. If you create a fund for people to share, they will fight (bitterly) over it. With ZeroMQ, we (iMatix) spend our time and money on marketing and packaging (like this book), and the basic care, like bug fixes, releases, and websites.</li>
</ul>
<ul>
<li>Lastly, sales and commercial mediation are important. There is a natural market between expert contributors and customers, but both are somewhat incompetent at talking to each other. Customers assume that support is free or very cheap because the software is free. Contributors are shy at asking a fair rate for their work. It makes for a difficult market. A growing part of my work and my firm's profits is simply connecting ZeroMQ users who want help with experts from the community able to provide it, and ensuring both sides are happy with the results.</li>
</ul>
<p>I've seen communities of brilliant people with noble goals dying because the founders got some or all of these four things wrong. The core problem is that you can't expect consistently great leadership from any one company, person, or group. What works today often won't work tomorrow, yet structures become more solid, not more flexible, over time.</p>
<p>The best answer I can find is a mix of two things. One, the GPL and its guarantee of remixability. No matter how bad the authority, no matter how much they try to privatize and capture the community's work, if it's GPL licensed, that work can walk away and find a better authority. Before you say, "all open source offers this," think it through. I can kill a BSD-licensed project by hiring the core contributors and not releasing any new patches. But even with a billion of dollars, I <em>cannot</em> kill a GPL-licensed project. Two, the philosophical anarchist model of authority, which is that we choose it, it does not own us.</p>
<p><a name="The-ZeroMQ-Process-C"></a><a name="header-142"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc141"><span><a href="http://zguide.zeromq.org/page:all#The-ZeroMQ-Process-C">The ZeroMQ Process: C4</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-141">prev</a> <a href="http://zguide.zeromq.org/page:all#header-143">next</a></td>
</tr>
</tbody></table>
<p>When we say ZeroMQ we sometimes mean <tt>libzmq</tt>, the core library. In early 2012, we synthesized the <tt>libzmq</tt> process into a formal protocol for collaboration that we called the <a href="http://rfc.zeromq.org/spec:22">Collective Code Construction Contract</a>, or C4. You can see this as a layer above the GPL. These are our rules, and I'll explain the reasoning behind each one.</p>
<p>C4 is an evolution of the GitHub <a href="http://help.github.com/send-pull-requests/">Fork + Pull Model</a>. You may get the feeling I'm a fan of git and GitHub. This would be accurate: these two tools have made such a positive impact on our work over the last years, especially when it comes to building community.</p>
<p><a name="Language"></a><a name="header-143"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc142"><span><a href="http://zguide.zeromq.org/page:all#Language">Language</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-142">prev</a> <a href="http://zguide.zeromq.org/page:all#header-144">next</a></td>
</tr>
</tbody></table>
<blockquote>
<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.</p>
</blockquote>
<p>By starting with the RFC 2119 language, the C4 text makes very clear its intention to act as a protocol rather than a randomly written set of recommendations. A protocol is a contract between parties that defines the rights and obligations of each party. These can be peers in a network or they can be strangers working in the same project.</p>
<p>I think C4 is the first time anyone has attempted to codify a community's rulebook as a formal and reusable protocol spec. Previously, our rules were spread out over several wiki pages, and were quite specific to <tt>libzmq</tt> in many ways. But experience teaches us that the more formal, accurate, and reusable the rules, the easier it is for strangers to collaborate up-front. And less friction means a more scalable community. At the time of C4, we also had some disagreement in the <tt>libzmq</tt> project over precisely what process we were using. Not everyone felt bound by the same rules. Let's just say some people felt they had a special status, which created friction with the rest of the community. So codification made things clear.</p>
<p>It's easy to use C4: just host your project on GitHub, get one other person to join, and open the floor to pull requests. In your README, put a link to C4 and that's it. We've done this in quite a few projects and it does seem to work. I've been pleasantly surprised a few times just applying these rules to my own work, like CZMQ. None of us are so amazing that we can work without others.</p>
<p><a name="Goals"></a><a name="header-144"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc143"><span><a href="http://zguide.zeromq.org/page:all#Goals">Goals</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-143">prev</a> <a href="http://zguide.zeromq.org/page:all#header-145">next</a></td>
</tr>
</tbody></table>
<blockquote>
<p>C4 is meant to provide a reusable optimal collaboration model for open source software projects.</p>
</blockquote>
<p>The short term reason for writing C4 was to end arguments over the <tt>libzmq</tt> contribution process. The dissenters went off elsewhere. <a href="https://github.com/zeromq/libzmq/graphs/contributors">The ZeroMQ community blossomed</a> smoothly and easily, as I'd predicted. Most people were surprised, but gratified. There's been no real criticisms of C4 except its branching policy, which I'll come to later as it deserves its own discussion.</p>
<p>There's a reason I'm reviewing history here: as founder of a community, you are asking people to invest in your property, trademark, and branding. In return, and this is what we do with ZeroMQ, you can use that branding to set a bar for quality. When you download a product labeled "ZeroMQ", you know that it's been produced to certain standards. It's a basic rule of quality: write down your process; otherwise you cannot improve it. Our processes aren't perfect, nor can they ever be. But any flaw in them can be fixed, and tested.</p>
<p>Making C4 reusable is therefore really important. To learn more about the best possible process, we need to get results from the widest range of projects.</p>
<blockquote>
<p>It has these specific goals:<br>
To maximize the scale of the community around a project, by reducing the friction for new Contributors and creating a scaled participation model with strong positive feedbacks;</p>
</blockquote>
<p>The number one goal is size and health of the community—not technical quality, not profits, not performance, not market share. The goal is simply the number of people who contribute to the project. The science here is simple: the larger the community, the more accurate the results.</p>
<blockquote>
<p>To relieve dependencies on key individuals by separating different skill sets so that there is a larger pool of competence in any required domain;</p>
</blockquote>
<p>Perhaps the worst problem we faced in <tt>libzmq</tt> was dependence on people who could understand the code, manage GitHub branches, and make clean releases—all at the same time. It's like looking for athletes who can run marathons and sprint, swim, and also lift weights. We humans are really good at specialization. Asking us to be really good at two contradictory things reduces the number of candidates sharply, which is a Bad Thing for any project. We had this problem severely in <tt>libzmq</tt> in 2009 or so, and fixed it by splitting the role of maintainer into two: one person makes patches and another makes releases.</p>
<blockquote>
<p>To allow the project to develop faster and more accurately, by increasing the diversity of the decision making process;</p>
</blockquote>
<p>This is theory—not fully proven, but not falsified. The diversity of the community and the number of people who can weigh in on discussions, without fear of being criticized or dismissed, the faster and more accurately the software develops. Speed is quite subjective here. Going very fast in the wrong direction is not just useless, it's actively damaging (and we suffered a lot of that in <tt>libzmq</tt> before we switched to C4).</p>
<blockquote>
<p>To support the natural life cycle of project versions from experimental through to stable, by allowing safe experimentation, rapid failure, and isolation of stable code;</p>
</blockquote>
<p>To be honest, this goal seems to be fading into irrelevance. It's quite an interesting effect of the process: <em>the git master is almost always perfectly stable</em>. This has to do with the size of changes and their <em>latency</em>, i.e., the time between someone writing the code and someone actually using it fully. However, people still expect "stable" releases, so we'll keep this goal there for a while.</p>
<blockquote>
<p>To reduce the internal complexity of project repositories, thus making it easier for Contributors to participate and reducing the scope for error;</p>
</blockquote>
<p>Curious observation: people who thrive in complex situations like to create complexity because it keeps their value high. It's the Cobra Effect (Google it). Git made branches easy and left us with the all too common syndrome of "git is easy once you understand that a git branch is just a folded five-dimensional lepton space that has a detached history with no intervening cache". Developers should not be made to feel stupid by their tools. I've seen too many top-class developers confused by repository structures to accept conventional wisdom on git branches. We'll come back to dispose of git branches shortly, dear reader.</p>
<blockquote>
<p>To enforce collective ownership of the project, which increases economic incentive to Contributors and reduces the risk of hijack by hostile entities.</p>
</blockquote>
<p>Ultimately, we're economic creatures, and the sense that "we own this, and our work can never be used against us" makes it much easier for people to invest in an open source project like ZeroMQ. And it can't be just a feeling, it has to be real. There are a number of aspects to making collective ownership work, we'll see these one-by-one as we go through C4.</p>
<p><a name="Preliminaries"></a><a name="header-145"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc144"><span><a href="http://zguide.zeromq.org/page:all#Preliminaries">Preliminaries</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-144">prev</a> <a href="http://zguide.zeromq.org/page:all#header-146">next</a></td>
</tr>
</tbody></table>
<blockquote>
<p>The project SHALL use the git distributed revision control system.</p>
</blockquote>
<p>Git has its faults. Its command-line API is horribly inconsistent, and it has a complex, messy internal model that it shoves in your face at the slightest provocation. But despite doing its best to make its users feel stupid, git does its job really, really well. More pragmatically, I've found that if you stay away from certain areas (branches!), people learn git rapidly and don't make many mistakes. That works for me.</p>
<blockquote>
<p>The project SHALL be hosted on github.com or equivalent, herein called the "Platform".</p>
</blockquote>
<p>I'm sure one day some large firm will buy GitHub and break it, and another platform will rise in its place. Until then, Github serves up a near-perfect set of minimal, fast, simple tools. I've thrown hundreds of people at it, and they all stick like flies stuck in a dish of honey.</p>
<blockquote>
<p>The project SHALL use the Platform issue tracker.</p>
</blockquote>
<p>We made the mistake in <tt>libzmq</tt> of switching to Jira because we hadn't learned yet how to properly use the GitHub issue tracker. Jira is a great example of how to turn something useful into a complex mess because the business depends on selling more "features". But even without criticizing Jira, keeping the issue tracker on the same platform means one less UI to learn, one less login, and smooth integration between issues and patches.</p>
<blockquote>
<p>The project SHOULD have clearly documented guidelines for code style.</p>
</blockquote>
<p>This is a protocol plug-in: insert code style guidelines here. If you don't document the code style you use, you have no basis except prejudice to reject patches.</p>
<blockquote>
<p>A "Contributor" is a person who wishes to provide a patch, being a set of commits that solve some clearly identified problem.<br>
A "Maintainer" is a person who merge patches to the project. Maintainers are not developers; their job is to enforce process.</p>
</blockquote>
<p>Now we move on to definitions of the parties, and the splitting of roles that saved us from the sin of structural dependency on rare individuals. This worked well in <tt>libzmq</tt>, but as you will see it depends on the rest of the process. C4 isn't a buffet; you will need the whole process (or something very like it), or it won't hold together.</p>
<blockquote>
<p>Contributors SHALL NOT have commit access to the repository unless they are also Maintainers.<br>
Maintainers SHALL have commit access to the repository.</p>
</blockquote>
<p>What we wanted to avoid was people pushing their changes directly to master. This was the biggest source of trouble in <tt>libzmq</tt> historically: large masses of raw code that took months or years to fully stabilize. We eventually followed other ZeroMQ projects like PyZMQ in using pull requests. We went further, and stipulated that <em>all</em> changes had to follow the same path. No exceptions for "special people".</p>
<blockquote>
<p>Everyone, without distinction or discrimination, SHALL have an equal right to become a Contributor under the terms of this contract.</p>
</blockquote>
<p>We had to state this explicitly. It used to be that the <tt>libzmq</tt> maintainers would reject patches simply because they didn't like them. Now, that may sound reasonable to the author of a library (though <tt>libzmq</tt> was not written by any one person), but let's remember our goal of creating a work that is owned by as many people as possible. Saying "I don't like your patch so I'm going to reject it" is equivalent to saying, "I claim to own this and I think I'm better than you, and I don't trust you". Those are toxic messages to give to others who are thinking of becoming your co-investors.</p>
<p>I think this fight between individual expertise and collective intelligence plays out in other areas. It defined Wikipedia, and still does, a decade after that work surpassed anything built by small groups of experts. For me, we make software by slowly synthesizing the most accurate knowledge, much as we make Wikipedia articles.</p>
<p><a name="Licensing-and-Ownership"></a><a name="header-146"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc145"><span><a href="http://zguide.zeromq.org/page:all#Licensing-and-Ownership">Licensing and Ownership</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-145">prev</a> <a href="http://zguide.zeromq.org/page:all#header-147">next</a></td>
</tr>
</tbody></table>
<blockquote>
<p>The project SHALL use the GPLv3 or a variant thereof (LGPL, AGPL).</p>
</blockquote>
<p>I've already explained how full remixability creates better scale and why the GPL and its variants seems the optimal contract for remixable software. If you're a large business aiming to dump code on the market, you won't want C4, but then you won't really care about community either.</p>
<blockquote>
<p>All contributions to the project source code ("patches") SHALL use the same license as the project.</p>
</blockquote>
<p>This removes the need for any specific license or contribution agreement for patches. You fork the GPL code, you publish your remixed version on GitHub, and you or anyone else can then submit that as a patch to the original code. BSD doesn't allow this. Any work that contains BSD code may also contain unlicensed proprietary code so you need explicit action from the author of the code before you can remix it.</p>
<blockquote>
<p>All patches are owned by their authors. There SHALL NOT be any copyright assignment process.</p>
</blockquote>
<p>Here we come to the key reason people trust their investments in ZeroMQ: it's logistically impossible to buy the copyrights to create a closed source competitor to ZeroMQ. iMatix can't do this either. And the more people that send patches, the harder it becomes. ZeroMQ isn't just free and open today—this specific rule means it will remain so forever. Note that it's not the case in all GPL projects, many of which still ask for copyright transfer back to the maintainers.</p>
<blockquote>
<p>The project SHALL be owned collectively by all its Contributors.</p>
</blockquote>
<p>This is perhaps redundant, but worth saying: if everyone owns their patches, then the resulting whole is also owned by every contributor. There's no legal concept of owning lines of code: the "work" is at least a source file.</p>
<blockquote>
<p>Each Contributor SHALL be responsible for identifying themselves in the project Contributor list.</p>
</blockquote>
<p>In other words, the maintainers are not karma accountants. Anyone who wants credit has to claim it themselves.</p>
<p><a name="Patch-Requirements"></a><a name="header-147"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc146"><span><a href="http://zguide.zeromq.org/page:all#Patch-Requirements">Patch Requirements</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-146">prev</a> <a href="http://zguide.zeromq.org/page:all#header-148">next</a></td>
</tr>
</tbody></table>
<p>In this section, we define the obligations of the contributor: specifically, what constitutes a "valid" patch, so that maintainers have rules they can use to accept or reject patches.</p>
<blockquote>
<p>Maintainers and Contributors MUST have a Platform account and SHOULD use their real names or a well-known alias.</p>
</blockquote>
<p>In the worst case scenario, where someone has submitted toxic code (patented, or owned by someone else), we need to be able to trace who and when, so we can remove the code. Asking for real names or a well-known alias is a theoretical strategy for reducing the risk of bogus patches. We don't know if this actually works because we haven't had the problem yet.</p>
<blockquote>
<p>A patch SHOULD be a minimal and accurate answer to exactly one identified and agreed problem.</p>
</blockquote>
<p>This implements the Simplicity Oriented Design process that I'll come to later in this chapter. One clear problem, one minimal solution, apply, test, repeat.</p>
<blockquote>
<p>A patch MUST adhere to the code style guidelines of the project if these are defined.</p>
</blockquote>
<p>This is just sanity. I've spent time cleaning up other peoples' patches because they insisted on putting the <tt>else</tt> beside the <tt>if</tt> instead of just below as Nature intended. Consistent code is healthier.</p>
<blockquote>
<p>A patch MUST adhere to the "Evolution of Public Contracts" guidelines defined below.</p>
</blockquote>
<p>Ah, the pain, the pain. I'm not speaking of the time at age eight when I stepped on a plank with a 4-inch nail protruding from it. That was relatively OK. I'm speaking of 2010-2011 when we had multiple parallel releases of ZeroMQ, each with different <em>incompatible</em> APIs or wire protocols. It was an exercise in bad rules, pointlessly enforced, that still hurts us today. The rule was, "If you change the API or protocol, you SHALL create a new major version". Give me the nail through the foot; that hurt less.</p>
<p>One of the big changes we made with C4 was simply to ban, outright, this kind of sanctioned sabotage. Amazingly, it's not even hard. We just don't allow the breaking of existing public contracts, period, unless everyone agrees, in which case no period. As Linus Torvalds famously put it on 23 December 2012, "WE DO NOT BREAK USERSPACE!"</p>
<blockquote>
<p>A patch SHALL NOT include nontrivial code from other projects unless the Contributor is the original author of that code.</p>
</blockquote>
<p>This rule has two effects. The first is that it forces people to make minimal solutions because they cannot simply import swathes of existing code. In the cases where I've seen this happen to projects, it's always bad unless the imported code is very cleanly separated. The second is that it avoids license arguments. You write the patch, you are allowed to publish it as LGPL, and we can merge it back in. But you find a 200-line code fragment on the web, and try to paste that, we'll refuse.</p>
<blockquote>
<p>A patch MUST compile cleanly and pass project self-tests on at least the principle target platform.</p>
</blockquote>
<p>For cross-platform projects, it is fair to ask that the patch works on the development box used by the contributor.</p>
<blockquote>
<p>A patch commit message SHOULD consist of a single short (less than 50 character) line summarizing the change, optionally followed by a blank line and then a more thorough description.</p>
</blockquote>
<p>This is a good format for commit messages that fits into email (the first line becomes the subject, and the rest becomes the email body).</p>
<blockquote>
<p>A "Correct Patch" is one that satisfies the above requirements.</p>
</blockquote>
<p>Just in case it wasn't clear, we're back to legalese and definitions.</p>
<p><a name="Development-Process"></a><a name="header-148"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc147"><span><a href="http://zguide.zeromq.org/page:all#Development-Process">Development Process</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-147">prev</a> <a href="http://zguide.zeromq.org/page:all#header-149">next</a></td>
</tr>
</tbody></table>
<p>In this section, we aim to describe the actual development process, step-by-step.</p>
<blockquote>
<p>Change on the project SHALL be governed by the pattern of accurately identifying problems and applying minimal, accurate solutions to these problems.</p>
</blockquote>
<p>This is a unapologetic ramming through of thirty years' software design experience. It's a profoundly simple approach to design: make minimal, accurate solutions to real problems, nothing more or less. In ZeroMQ, we don't have feature requests. Treating new features the same as bugs confuses some newcomers. But this process works, and not just in open source. Enunciating the problem we're trying to solve, with every single change, is key to deciding whether the change is worth making or not.</p>
<blockquote>
<p>To initiate changes, a user SHALL log an issue on the project Platform issue tracker.</p>
</blockquote>
<p>This is meant to stop us from going offline and working in a ghetto, either by ourselves or with others. Although we tend to accept pull requests that have clear argumentation, this rule lets us say "stop" to confused or too-large patches.</p>
<blockquote>
<p>The user SHOULD write the issue by describing the problem they face or observe.</p>
</blockquote>
<p>"Problem: we need feature X. Solution: make it" is not a good issue. "Problem: user cannot do common tasks A or B except by using a complex workaround. Solution: make feature X" is a decent explanation. Because everyone I've ever worked with has needed to learn this, it seems worth restating: document the real problem first, solution second.</p>
<blockquote>
<p>The user SHOULD seek consensus on the accuracy of their observation, and the value of solving the problem.</p>
</blockquote>
<p>And because many apparent problems are illusionary, by stating the problem explicitly we give others a chance to correct our logic. "You're only using A and B a lot because function C is unreliable. Solution: make function C work properly."</p>
<blockquote>
<p>Users SHALL NOT log feature requests, ideas, suggestions, or any solutions to problems that are not explicitly documented and provable.</p>
</blockquote>
<p>There are several reasons for not logging ideas, suggestions, or feature requests. In our experience, these just accumulate in the issue tracker until someone deletes them. But more profoundly, when we treat all change as problem solutions, we can prioritize trivially. Either the problem is real and someone wants to solve it now, or it's not on the table. Thus, wish lists are off the table.</p>
<blockquote>
<p>Thus, the release history of the project SHALL be a list of meaningful issues logged and solved.</p>
</blockquote>
<p>I'd love the GitHub issue tracker to simply list all the issues we solved in each release. Today we still have to write that by hand. If one puts the issue number in each commit, and if one uses the GitHub issue tracker, which we sadly don't yet do for ZeroMQ, this release history is easier to produce mechanically.</p>
<blockquote>
<p>To work on an issue, a Contributor SHALL fork the project repository and then work on their forked repository.</p>
</blockquote>
<p>Here we explain the GitHub fork + pull request model so that newcomers only have to learn one process (C4) in order to contribute.</p>
<blockquote>
<p>To submit a patch, a Contributor SHALL create a Platform pull request back to the project.</p>
</blockquote>
<p>GitHub has made this so simple that we don't need to learn git commands to do it, for which I'm deeply grateful. Sometimes, I'll tell people who I don't particularly like that command-line git is awesome and all they need to do is learn git's internal model in detail before trying to use it on real work. When I see them several months later they look… changed.</p>
<blockquote>
<p>A Contributor SHALL NOT commit changes directly to the project.</p>
</blockquote>
<p>Anyone who submits a patch is a contributor, and all contributors follow the same rules. No special privileges to the original authors, because otherwise we're not building a community, only boosting our egos.</p>
<blockquote>
<p>To discuss a patch, people MAY comment on the Platform pull request, on the commit, or elsewhere.</p>
</blockquote>
<p>Randomly distributed discussions may be confusing if you're walking up for the first time, but GitHub solves this for all current participants by sending emails to those who need to follow what's going on. We had the same experience and the same solution in Wikidot, and it works. There's no evidence that discussing in different places has any negative effect.</p>
<blockquote>
<p>To accept or reject a patch, a Maintainer SHALL use the Platform interface.</p>
</blockquote>
<p>Working via the GitHub web user interface means pull requests are logged as issues, with workflow and discussion. I'm sure there are more complex ways to work. Complexity is easy; it's simplicity that's incredibly hard.</p>
<blockquote>
<p>Maintainers SHALL NOT accept their own patches.</p>
</blockquote>
<p>There was a rule we defined in the FFII years ago to stop people burning out: no less than two people on any project. One-person projects tend to end in tears, or at least bitter silence. We have quite a lot of data on burnout, why it happens, and how to prevent it (even cure it). I'll explore this later in the chapter, because if you work with or on open source you need to be aware of the risks. The "no merging your own patch" rule has two goals. First, if you want your project to be C4-certified, you have to get at least one other person to help. If no one wants to help you, perhaps you need to rethink your project. Second, having a control for every patch makes it much more satisfying, keeps us more focused, and stops us breaking the rules because we're in a hurry, or just feeling lazy.</p>
<blockquote>
<p>Maintainers SHALL NOT make value judgments on correct patches.</p>
</blockquote>
<p>We already said this but it's worth repeating: the role of Maintainer is not to judge a patch's substance, only its technical quality. The substantive worth of a patch only emerges over time: people use it, and like it, or they do not. And if no one is using a patch, eventually it'll annoy someone else who will remove it, and no one will complain.</p>
<blockquote>
<p>Maintainers SHALL merge correct patches rapidly.</p>
</blockquote>
<p>There is a criteria I call <em>change latency</em>, which is the round-trip time from identifying a problem to testing a solution. The faster the better. If maintainers cannot respond to pull requests as rapidly as people expect, they're not doing their job (or they need more hands).</p>
<blockquote>
<p>The Contributor MAY tag an issue as "Ready" after making a pull request for the issue.</p>
</blockquote>
<p>By default, GitHub offers the usual variety of issues, but with C4 we don't use them. Instead, we need just two labels, "Urgent" and "Ready". A contributor who wants another user to test an issue can then label it as "Ready".</p>
<blockquote>
<p>The user who created an issue SHOULD close the issue after checking the patch is successful.</p>
</blockquote>
<p>When one person opens an issue, and another works on it, it's best to allow the original person to close the issue. That acts as a double-check that the issue was properly resolved.</p>
<blockquote>
<p>Maintainers SHOULD ask for improvements to incorrect patches and SHOULD reject incorrect patches if the Contributor does not respond constructively.</p>
</blockquote>
<p>Initially, I felt it was worth merging all patches, no matter how poor. There's an element of trolling involved. Accepting even obviously bogus patches could, I felt, pull in more contributors. But people were uncomfortable with this so we defined the "correct patch" rules, and the Maintainer's role in checking for quality. On the negative side, I think we didn't take some interesting risks, which could have paid off with more participants. On the positive side, this has led to <tt>libzmq</tt> master (and in all projects that use C4) being practically production quality, practically all the time.</p>
<blockquote>
<p>Any Contributor who has value judgments on a correct patch SHOULD express these via their own patches.</p>
</blockquote>
<p>In essence, the goal here is to allow users to try patches rather than to spend time arguing pros and cons. As easy as it is to make a patch, it's as easy to revert it with another patch. You might think this would lead to "patch wars", but that hasn't happened. We've had a handful of cases in <tt>libzmq</tt> where patches by one contributor were killed by another person who felt the experimentation wasn't going in the right direction. It is easier than seeking up-front consensus.</p>
<blockquote>
<p>Maintainers MAY commit changes to non-source documentation directly to the project.</p>
</blockquote>
<p>This exit allows maintainers who are making release notes to push those without having to create an issue which would then affect the release notes, leading to stress on the space time fabric and possibly involuntary rerouting backwards in the fourth dimension to before the invention of cold beer. Shudder. It is simpler to agree that release notes aren't technically software.</p>
<p><a name="Creating-Stable-Releases"></a><a name="header-149"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc148"><span><a href="http://zguide.zeromq.org/page:all#Creating-Stable-Releases">Creating Stable Releases</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-148">prev</a> <a href="http://zguide.zeromq.org/page:all#header-150">next</a></td>
</tr>
</tbody></table>
<p>We want some guarantee of stability for a production system. In the past, this meant taking unstable code and then over months hammering out the bugs and faults until it was safe to trust. iMatix's job, for years, has been to do this to <tt>libzmq</tt>, turning raw code into packages by allowing only bug fixes and no new code into a "stabilization branch". It's surprisingly not as thankless as it sounds.</p>
<p>Now, since we went full speed with C4, we've found that git master of <tt>libzmq</tt> is mostly perfect, most of the time. This frees our time to do more interesting things, such as building new open source layers on top of <tt>libzmq</tt>. However, people still want that guarantee: many users will simply not install except from an "official" release. So a stable release today means two things. First, a snapshot of the master taken at a time when there were no new changes for a while, and no dramatic open bugs. Second, a way to fine tune that snapshot to fix the critical issues remaining in it.</p>
<p>This is the process we explain in this section.</p>
<blockquote>
<p>The project SHALL have one branch ("master") that always holds the latest in-progress version and SHOULD always build.</p>
</blockquote>
<p>This is redundant because every patch always builds but it's worth restating. If the master doesn't build (and pass its tests), someone needs waking up.</p>
<blockquote>
<p>The project SHALL NOT use topic branches for any reason. Personal forks MAY use topic branches.</p>
</blockquote>
<p>I'll come to branches soon. In short (or "tl;dr", as they say on the webs), branches make the repository too complex and fragile, and require up-front agreement, all of which are expensive and avoidable.</p>
<blockquote>
<p>To make a stable release someone SHALL fork the repository by copying it and thus become maintainer of this repository.<br>
Forking a project for stabilization MAY be done unilaterally and without agreement of project maintainers.</p>
</blockquote>
<p>It's free software. No one has a monopoly on it. If you think the maintainers aren't producing stable releases right, fork the repository and do it yourself. Forking isn't a failure, it's an essential tool for competition. You can't do this with branches, which means a branch-based release policy gives the project maintainers a monopoly. And that's bad because they'll become lazier and more arrogant than if real competition is chasing their heels.</p>
<blockquote>
<p>A stabilization project SHOULD be maintained by the same process as the main project.</p>
</blockquote>
<p>Stabilization projects have maintainers and contributors like any project. In practice we usually cherry pick patches from the main project to the stabilization project, but that's just a convenience.</p>
<blockquote>
<p>A patch to a repository declared "stable" SHALL be accompanied by a reproducible test case.</p>
</blockquote>
<p>Beware of a one-size-fits-all process. New code does not need the same paranoia as code that people are trusting for production use. In the normal development process, we did not mention test cases. There's a reason for this. While I love testable patches, many changes aren't easily or at all testable. However, to stabilize a code base you want to fix only serious bugs, and you want to be 100% sure every change is accurate. This means before and after tests for every change.</p>
<p><a name="Evolution-of-Public-Contracts"></a><a name="header-150"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc149"><span><a href="http://zguide.zeromq.org/page:all#Evolution-of-Public-Contracts">Evolution of Public Contracts</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-149">prev</a> <a href="http://zguide.zeromq.org/page:all#header-151">next</a></td>
</tr>
</tbody></table>
<p>By "public contracts", I mean APIs and protocols. Up until the end of 2011, <tt>libzmq</tt>'s naturally happy state was marred by broken promises and broken contracts. We stopped making promises (aka "road maps") for <tt>libzmq</tt> completely, and our dominant theory of change is now that it emerges carefully and accurately over time. At a 2012 Chicago meetup, Garrett Smith and Chuck Remes called this the "drunken stumble to greatness", which is how I think of it now.</p>
<p>We stopped breaking public contracts simply by banning the practice. Before then it had been "OK" (as in we did it and everyone complained bitterly, and we ignored them) to break the API or protocol so long as we changed the major version number. Sounds fine, until you get ZeroMQ v2.0, v3.0, and v4.0 all in development at the same time, and not speaking to each other.</p>
<blockquote>
<p>All Public Contracts (APIs or protocols) SHOULD be documented.</p>
</blockquote>
<p>You'd think this was a given for professional software engineers but no, it's not. So, it's a rule. You want C4 certification for your project, you make sure your public contracts are documented. No "It's specified in the code" excuses. Code is not a contract. (Yes, I intend at some point to create a C4 certification process to act as a quality indicator for open source projects.)</p>
<blockquote>
<p>All Public Contracts SHALL use Semantic Versioning.</p>
</blockquote>
<p>This rule is mainly here because people asked for it. I've no real love for it, as Semantic Versioning is what led to the so-called "Why does ZeroMQ not speak to itself?!" debacle. I've never seen the problem that this solved. Something about runtime validation of library versions, or some-such.</p>
<blockquote>
<p>All Public Contracts SHOULD have space for extensibility and experimentation.</p>
</blockquote>
<p>Now, the real thing is that public contracts <em>do change</em>. It's not about not changing them. It's about changing them safely. This means educating (especially protocol) designers to create that space up-front.</p>
<blockquote>
<p>A patch that modifies a stable Public Contract SHOULD not break existing applications unless there is overriding consensus on the value of doing this.</p>
</blockquote>
<p>Sometimes the patch is fixing a bad API that no one is using. It's a freedom we need, but it should be based on consensus, not one person's dogma. However, making random changes "just because" is not good. In ZeroMQ v3.x, did we benefit from renaming <tt>ZMQ_NOBLOCK</tt> to <tt>ZMQ_DONTWAIT</tt>? Sure, it's closer to the POSIX socket <tt>recv()</tt> call, but is that worth breaking thousands of applications? No one ever reported it as an issue. To misquote Stallman: "your freedom to create an ideal world stops one inch from my application."</p>
<blockquote>
<p>A patch that introduces new features to a Public Contract SHOULD do so using new names.</p>
</blockquote>
<p>We had the experience in ZeroMQ once or twice of new features using old names (or worse, using names that were <em>still in use</em> elsewhere). ZeroMQ v3.0 had a newly introduced "ROUTER" socket that was totally different from the existing ROUTER socket in 2.x. Dear lord, you should be face-palming, why? The reason: apparently, even smart people sometimes need regulation to stop them doing silly things.</p>
<blockquote>
<p>Old names SHOULD be deprecated in a systematic fashion by marking new names as "experimental" until they are stable, then marking the old names as "deprecated".</p>
</blockquote>
<p>This life cycle notation has the great benefit of actually telling users what is going on with a consistent direction. "Experimental" means "we have introduced this and intend to make it stable if it works". It does not mean, "we have introduced this and will remove it at any time if we feel like it". One assumes that code that survives more than one patch cycle is meant to be there. "Deprecated" means "we have replaced this and intend to remove it".</p>
<blockquote>
<p>When sufficient time has passed, old deprecated names SHOULD be marked "legacy" and eventually removed.</p>
</blockquote>
<p>In theory this gives applications time to move onto stable new contracts without risk. You can upgrade first, make sure things work, and then, over time, fix things up to remove dependencies on deprecated and legacy APIs and protocols.</p>
<blockquote>
<p>Old names SHALL NOT be reused by new features.</p>
</blockquote>
<p>Ah, yes, the joy when ZeroMQ v3.x renamed the top-used API functions (<tt><a href="http://api.zeromq.org/3-2:zmq_send">zmq_send()</a></tt> and <tt><a href="http://api.zeromq.org/3-2:zmq_recv">zmq_recv()</a></tt>) and then recycled the old names for new methods that were utterly incompatible (and which I suspect few people actually use). You should be slapping yourself in confusion again, but really, this is what happened and I was as guilty as anyone. After all, we did change the version number! The only benefit of that experience was to get this rule.</p>
<blockquote>
<p>When old names are removed, their implementations MUST provoke an exception (assertion) if used by applications.</p>
</blockquote>
<p>I've not tested this rule to be certain it makes sense. Perhaps what it means is "if you can't provoke a compile error because the API is dynamic, provoke an assertion".</p>
<p><a name="Project-Administration"></a><a name="header-151"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc150"><span><a href="http://zguide.zeromq.org/page:all#Project-Administration">Project Administration</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-150">prev</a> <a href="http://zguide.zeromq.org/page:all#header-152">next</a></td>
</tr>
</tbody></table>
<blockquote>
<p>The project founders SHALL act as Administrators to manage the set of project Maintainers.</p>
</blockquote>
<p>Someone needs to administer the project, and it makes sense that the original founders start this ball rolling.</p>
<blockquote>
<p>The Administrators SHALL ensure their own succession over time by promoting the most effective Maintainers.</p>
</blockquote>
<p>At the same time, as founder of a project you really want to get out of the way before you become over-attached to it. Promoting the most active and consistent maintainers is good for everyone.</p>
<blockquote>
<p>A new Contributor who makes a correct patch SHALL be invited to become a Maintainer.</p>
</blockquote>
<p>I met Felix Geisendörfer in Lyons in 2012 at the <a href="http://www.mix-it.fr/">Mix-IT conference</a> where I presented Social Architecture and one thing that came out of this was Felix's now famous <a href="http://felixge.de/2013/03/11/the-pull-request-hack.html">Pull Request Hack</a>. It fits elegantly into C4 and solves the problem of maintainers dropping out over time.</p>
<blockquote>
<p>Administrators MAY remove Maintainers who are inactive for an extended period of time, or who repeatedly fail to apply this process accurately.</p>
</blockquote>
<p>This was Ian Barber's suggestion: we need a way to crop inactive maintainers. Originally maintainers were self-elected but that makes it hard to drop troublemakers (who are rare, but not unknown).</p>
<p>C4 is not perfect. Few things are. The process for changing it (Digistan's COSS) is a little outdated now: it relies on a single-editor workflow with the ability to fork, but not merge. This seems to work but it could be better to use C4 for protocols like C4.</p>
<p><a name="A-Real-Life-Example"></a><a name="header-152"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc151"><span><a href="http://zguide.zeromq.org/page:all#A-Real-Life-Example">A Real-Life Example</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-151">prev</a> <a href="http://zguide.zeromq.org/page:all#header-153">next</a></td>
</tr>
</tbody></table>
<p>In <a href="http://lists.zeromq.org/pipermail/zeromq-dev/2012-October/018838.html">this email thread</a>, Dan Goes asks how to make a publisher that knows when a new client subscribes, and sends out previous matching messages. It's a standard pub-sub technique called "last value caching". Now over a 1-way transport like pgm (where subscribers literally send no packets back to publishers), this can't be done. But over TCP, it can, if we use an XPUB socket and if that socket didn't cleverly filter out duplicate subscriptions to reduce upstream traffic.</p>
<p>Though I'm not an expert contributor to <tt>libzmq</tt>, this seems like a fun problem to solve. How hard could it be? I start by forking the <tt>libzmq</tt> repository to my own GitHub account and then clone it to my laptop, where I build it:</p>
<div class="code">
<pre><code>git clone git@github.com:hintjens/libzmq.git
cd libzmq
./autogen.sh
./configure
make</code>
</pre></div>
<p>Because the <tt>libzmq</tt> code is neat and well-organized, it was quite easy to find the main files to change (<tt>xpub.cpp</tt> and <tt>xpub.hpp</tt>). Each socket type has its own source file and class. They inherit from <tt>socket_base.cpp</tt>, which has this hook for socket-specific options:</p>
<div class="code">
<pre><code>//  First, check whether specific socket type overloads the option.
int rc = xsetsockopt (option_, optval_, optvallen_);
if (rc == 0 || errno != EINVAL)
    return rc;

//  If the socket type doesn't support the option, pass it to
//  the generic option parser.
return options.setsockopt (option_, optval_, optvallen_);</code>
</pre></div>
<p>Then I check where the XPUB socket filters out duplicate subscriptions, in its <tt>xread_activated</tt> method:</p>
<div class="code">
<pre><code>bool unique;
if (*data == 0)
    unique = subscriptions.rm (data + 1, size - 1, pipe_);
else
    unique = subscriptions.add (data + 1, size - 1, pipe_);

//  If the subscription is not a duplicate store it so that it can be
//  passed to used on next recv call.
if (unique &amp;&amp; options.type != ZMQ_PUB)
    pending.push_back (blob_t (data, size));</code>
</pre></div>
<p>At this stage, I'm not too concerned with the details of how <tt>subscriptions.rm</tt> and <tt>subscriptions.add</tt> work. The code seems obvious except that "subscription" also includes unsubscription, which confused me for a few seconds. If there's anything else weird in the rm and add methods, that's a separate issue to fix later. Time to make an issue for this change. I head over to the <tt>zeromq.jira.com</tt> site, log in, and create a new entry.</p>
<p>Jira kindly offers me the traditional choice between "bug" and "new feature" and I spend thirty seconds wondering where this counterproductive historical distinction came from. Presumably, the "we'll fix bugs for free, but you pay for new features" commercial proposal, which stems from the "you tell us what you want and we'll make it for $X" model of software development, and which generally leads to "we spent three times $X and we got what?!" email Fists of Fury.</p>
<p>Putting such thoughts aside, I create <a href="https://zeromq.jira.com/browse/LIBZMQ-443">an issue #443</a> and described the problem and plausible solution:</p>
<blockquote>
<p>Problem: XPUB socket filters out duplicate subscriptions (deliberate design). However this makes it impossible to do subscription-based intelligence. See <a href="http://lists.zeromq.org/pipermail/zeromq-dev/2012-October/018838.html">http://lists.zeromq.org/pipermail/zeromq-dev/2012-October/018838.html</a> for a use case.<br>
Solution: make this behavior configurable with a socket option.</p>
</blockquote>
<p>It's naming time. The API sits in <tt>include/zmq.h</tt>, so this is where I added the option name. When you invent a concept in an API or anywhere, <em>please</em> take a moment to choose a name that is explicit and short and obvious. Don't fall back on generic names that need additional context to understand. You have one chance to tell the reader what your concept is and does. A name like <tt>ZMQ_SUBSCRIPTION_FORWARDING_FLAG</tt> is terrible. It technically kind of aims in the right direction, but is miserably long and obscure. I chose <tt>ZMQ_XPUB_VERBOSE</tt>: short and explicit and clearly an on/off switch with "off" being the default setting.</p>
<p>So, it's time to add a private property to the <tt>xpub</tt> class definition in <tt>xpub.hpp</tt>:</p>
<div class="code">
<pre><code>// If true, send all subscription messages upstream, not just
// unique ones
bool verbose;</code>
</pre></div>
<p>And then lift some code from <tt>router.cpp</tt> to implement the <tt>xsetsockopt</tt> method. Finally, change the <tt>xread_activated</tt> method to use this new option, and while at it, make that test on socket type more explicit too:</p>
<div class="code">
<pre><code>//  If the subscription is not a duplicate store it so that it can be
//  passed to used on next recv call.
if (options.type == ZMQ_XPUB &amp;&amp; (unique || verbose))
    pending.push_back (blob_t (data, size));</code>
</pre></div>
<p>The thing builds nicely the first time. This makes me a little suspicious, but being lazy and jet-lagged I don't immediately make a test case to actually try out the change. The process doesn't demand that, even if usually I'd do it just to catch that inevitable 10% of mistakes we all make. I do however document this new option on the <tt>doc/zmq_setsockopt.txt</tt> man page. In the worst case, I added a patch that wasn't really useful. But I certainly didn't break anything.</p>
<p>I don't implement a matching <tt>zmq_getsockopt</tt> because "minimal" means what it says. There's no obvious use case for getting the value of an option that you presumably just set, in code. Symmetry isn't a valid reason to double the size of a patch. I did have to document the new option because the process says, "All Public Contracts SHOULD be documented."</p>
<p>Committing the code, I push the patch to my forked repository (the "origin"):</p>
<div class="code">
<pre><code>git commit -a -m "Fixed issue #443"
git push origin master</code>
</pre></div>
<p>Switching to the GitHub web interface, I go to my <tt>libzmq</tt> fork, and press the big "Pull Request" button at the top. GitHub asks me for a title, so I enter "Added ZMQ_XPUB_VERBOSE option". I'm not sure why it asks this as I made a neat commit message but hey, let's go with the flow here.</p>
<p>This makes a nice little pull request with two commits; the one I'd made a month ago on the release notes to prepare for the v3.2.1 release (a month passes so quickly when you spend most of it in airports), and my fix for issue #443 (37 new lines of code). GitHub lets you continue to make commits after you've kicked off a pull request. They get queued up and merged in one go. That is easy, but the maintainer may refuse the whole bundle based on one patch that doesn't look valid.</p>
<p>Because Dan is waiting (at least in my highly optimistic imagination) for this fix, I go back to the zeromq-dev list and tell him I've made the patch, with a link to the commit. The faster I get feedback, the better. It's 1 a.m. in South Korea as I make this patch, so early evening in Europe, and morning in the States. You learn to count timezones when you work with people across the world. Ian is in a conference, Mikko is getting on a plane, and Chuck is probably in the office, but three hours later, Ian merges the pull request.</p>
<p>After Ian merges the pull request, I resynchronize my fork with the upstream <tt>libzmq</tt> repository. First, I add a <em>remote</em> that tells git where this repository sits (I do this just once in the directory where I'm working):</p>
<div class="code">
<pre><code>git remote add upstream git://github.com/zeromq/libzmq.git</code>
</pre></div>
<p>And then I pull changes back from the upstream master and check the git log to double-check:</p>
<div class="code">
<pre><code>git pull --rebase upstream master
git log</code>
</pre></div>
<p>And that is pretty much it, in terms of how much git one needs to learn and use to contribute patches to <tt>libzmq</tt>. Six git commands and some clicking on web pages. Most importantly to me as a naturally lazy, stupid, and easily confused developer, I don't have to learn git's internal models, and never have to do anything involving those infernal engines of structural complexity we call "git branches". Next up, the attempted assassination of git branches. Let's live dangerously!</p>
<p><a name="Git-Branches-Considered-Harmful"></a><a name="header-153"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc152"><span><a href="http://zguide.zeromq.org/page:all#Git-Branches-Considered-Harmful">Git Branches Considered Harmful</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-152">prev</a> <a href="http://zguide.zeromq.org/page:all#header-154">next</a></td>
</tr>
</tbody></table>
<p>One of git's most popular features is its branches. Almost all projects that use git use branches, and the selection of the "best" branching strategy is like a rite of passage for an open source project. Vincent Driessen's <a href="http://nvie.com/posts/a-successful-git-branching-model/">git-flow</a> may be the best known. It has <em>base</em> branches (master, develop), <em>feature</em> branches, <em>release</em> branches, <em>hotfix</em> branches, and <em>support</em> branches. Many teams have adopted git-flow, which even has git extensions to support it. I'm a great believer in popular wisdom, but sometimes you have to recognize mass delusion for what it is.</p>
<p>Here is a section of C4 that might have shocked you when you first read it:</p>
<blockquote>
<p>The project SHALL NOT use topic branches for any reason. Personal forks MAY use topic branches.</p>
</blockquote>
<p>To be clear, it's <em>public branches in shared repositories</em> that I'm talking about. Using branches for private work, e.g., to work on different issues, appears to work well enough, though it's more complexity than I personally enjoy. To channel Stallman again: "your freedom to create complexity ends one inch from our shared workspace."</p>
<p>Like the rest of C4, the rules on branches are not accidental. They came from our experience making ZeroMQ, starting when Martin Sustrik and I rethought how to make stable releases. We both love and appreciate simplicity (some people seem to have a remarkable tolerance for complexity). We chatted for a while… I asked him, "I'm going to start making a stable release. Would it be OK for me to make a branch in the git you're working in?" Martin didn't like the idea. "OK, if I fork the repository, I can move patches from your repo to that one". That felt much better to both of us.</p>
<p>The response from many in the ZeroMQ community was shock and horror. People felt we were being lazy and making contributors work harder to find the "right" repository. Still, this seemed simple, and indeed it worked smoothly. The best part was that we each worked as we wanted to. Whereas before, the ZeroMQ repository had felt horribly complex (and it wasn't even anything like git-flow), this felt simple. And it worked. The only downside was that we lost a single unified history. Now, perhaps historians will feel robbed, but I honestly can't see that the historical minutiae of who changed what, when, including every branch and experiment, are worth any significant pain or friction.</p>
<p>People have gotten used to the "multiple repositories" approach in ZeroMQ and we've started using that in other projects quite successfully. My own opinion is that history will judge git branches and patterns like git-flow as a complex solution to imaginary problems inherited from the days of Subversion and monolithic repositories.</p>
<p>More profoundly, and perhaps this is why the majority seems to be "wrong": I think the branches versus forks argument is really a deeper design versus evolve argument about how to make software optimally. I'll address that deeper argument in the next section. For now, I'll try to be scientific about my irrational hatred of branches, by looking at a number of criteria, and comparing branches and forks in each one.</p>
<p><a name="Simplicity-Versus-Complexity"></a><a name="header-154"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc153"><span><a href="http://zguide.zeromq.org/page:all#Simplicity-Versus-Complexity">Simplicity Versus Complexity</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-153">prev</a> <a href="http://zguide.zeromq.org/page:all#header-155">next</a></td>
</tr>
</tbody></table>
<p><em>The simpler, the better.</em></p>
<p>There is no inherent reason why branches are more complex than forks. However, git-flow uses <em>five types</em> of branch, whereas C4 uses two types of fork (development, and stable) and one branch (master). Circumstantial evidence is thus that branches lead to more complexity than forks. For new users, it is definitely, and we've measured this in practice, easier to learn to work with many repositories and no branches except master.</p>
<p><a name="Change-Latency"></a><a name="header-155"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc154"><span><a href="http://zguide.zeromq.org/page:all#Change-Latency">Change Latency</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-154">prev</a> <a href="http://zguide.zeromq.org/page:all#header-156">next</a></td>
</tr>
</tbody></table>
<p><em>The smaller and more rapid the delivery, the better.</em></p>
<p>Development branches seem to correlate strongly with large, slow, risky deliveries. "Sorry, I have to merge this branch before we can test the new version" signals a breakdown in process. It's certainly not how C4 works, which is by focusing tightly on individual problems and their minimal solutions. Allowing branches in development raises change latency. Forks have a different outcome: it's up to the forker to ensure that his changes merge cleanly, and to keep them simple so they won't be rejected.</p>
<p><a name="Learning-Curve"></a><a name="header-156"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc155"><span><a href="http://zguide.zeromq.org/page:all#Learning-Curve">Learning Curve</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-155">prev</a> <a href="http://zguide.zeromq.org/page:all#header-157">next</a></td>
</tr>
</tbody></table>
<p><em>The smoother the learning curve, the better.</em></p>
<p>Evidence definitely shows that learning to use git branches is complex. For some people, this is OK. For most developers, every cycle spent learning git is a cycle lost on more productive things. I've been told several times, by different people that I do not like branches because I "never properly learned git". That is fair, but it is a criticism of the tool, not the human.</p>
<p><a name="Cost-of-Failure"></a><a name="header-157"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc156"><span><a href="http://zguide.zeromq.org/page:all#Cost-of-Failure">Cost of Failure</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-156">prev</a> <a href="http://zguide.zeromq.org/page:all#header-158">next</a></td>
</tr>
</tbody></table>
<p><em>The lower the cost of failure, the better.</em></p>
<p>Branches demand more perfection from developers because mistakes potentially affect others. This raises the cost of failure. Forks make failure extremely cheap because literally nothing that happens in a fork can affect others not using that fork.</p>
<p><a name="Up-front-Coordination"></a><a name="header-158"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc157"><span><a href="http://zguide.zeromq.org/page:all#Up-front-Coordination">Up-front Coordination</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-157">prev</a> <a href="http://zguide.zeromq.org/page:all#header-159">next</a></td>
</tr>
</tbody></table>
<p><em>The less need for up-front coordination, the better.</em></p>
<p>You can do a hostile fork. You cannot do a hostile branch. Branches depend on up-front coordination, which is expensive and fragile. One person can veto the desires of a whole group. For example in the ZeroMQ community we were unable to agree on a git branching model for a year. We solved that by using forking instead. The problem went away.</p>
<p><a name="Scalability"></a><a name="header-159"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc158"><span><a href="http://zguide.zeromq.org/page:all#Scalability">Scalability</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-158">prev</a> <a href="http://zguide.zeromq.org/page:all#header-160">next</a></td>
</tr>
</tbody></table>
<p><em>The more you can scale a project, the better.</em></p>
<p>The strong assumption in all branch strategies is that the repository <em>is</em> the project. But there is a limit to how many people you can get to agree to work together in one repository. As I explained, the cost of up-front coordination can become fatal. A more realistic project scales by allowing anyone to start their own repositories, and ensuring these can work together. A project like ZeroMQ has dozens of repositories. Forking looks more scalable than branching.</p>
<p><a name="Surprise-and-Expectations"></a><a name="header-160"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc159"><span><a href="http://zguide.zeromq.org/page:all#Surprise-and-Expectations">Surprise and Expectations</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-159">prev</a> <a href="http://zguide.zeromq.org/page:all#header-161">next</a></td>
</tr>
</tbody></table>
<p><em>The less surprising, the better.</em></p>
<p>People expect branches and find forks to be uncommon and thus confusing. This is the one aspect where branches win. If you use branches, a single patch will have the same commit hash tag, whereas across forks the patch will have different hash tags. That makes it harder to track patches as they cross forks, true. But seriously, <em>having to track hexadecimal hash tags is not a feature</em>. It's a bug. Sometimes better ways of working are surprising at first.</p>
<p><a name="Economics-of-Participation"></a><a name="header-161"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc160"><span><a href="http://zguide.zeromq.org/page:all#Economics-of-Participation">Economics of Participation</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-160">prev</a> <a href="http://zguide.zeromq.org/page:all#header-162">next</a></td>
</tr>
</tbody></table>
<p><em>The more tangible the rewards, the better.</em></p>
<p>People like to own their work and get credit for it. This is much easier with forks than with branches. Forks create more competition in a healthy way, while branches suppress competition and force people to collaborate and share credit. This sounds positive but in my experience it demotivates people. A branch isn't a product you can "own", whereas a fork can be.</p>
<p><a name="Robustness-in-Conflict"></a><a name="header-162"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc161"><span><a href="http://zguide.zeromq.org/page:all#Robustness-in-Conflict">Robustness in Conflict</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-161">prev</a> <a href="http://zguide.zeromq.org/page:all#header-163">next</a></td>
</tr>
</tbody></table>
<p><em>The more a model can survive conflict, the better.</em></p>
<p>Like it or not, people fight over ego, status, beliefs, and theories of the world. Challenge is a necessary part of science. If your organizational model depends on agreement, you won't survive the first real fight. Branches do not survive real arguments and fights, whereas forks can be hostile, and still benefit all parties. And this is indeed how free software works.</p>
<p><a name="Guarantees-of-Isolation"></a><a name="header-163"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc162"><span><a href="http://zguide.zeromq.org/page:all#Guarantees-of-Isolation">Guarantees of Isolation</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-162">prev</a> <a href="http://zguide.zeromq.org/page:all#header-164">next</a></td>
</tr>
</tbody></table>
<p><em>The stronger the isolation between production code and experiment, the better.</em></p>
<p>People make mistakes. I've seen experimental code pushed to mainline production by error. I've seen people make bad panic changes under stress. But the real fault is in allowing two entirely separate generations of product to exist in the same protected space. If you can push to random-branch-x, you can push to master. Branches do not guarantee isolation of production critical code. Forks do.</p>
<p><a name="Visibility"></a><a name="header-164"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc163"><span><a href="http://zguide.zeromq.org/page:all#Visibility">Visibility</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-163">prev</a> <a href="http://zguide.zeromq.org/page:all#header-165">next</a></td>
</tr>
</tbody></table>
<p><em>The more visible our work, the better.</em></p>
<p>Forks have watchers, issues, a README, and a wiki. Branches have none of these. People try forks, build them, break them, patch them. Branches sit there until someone remembers to work on them. Forks have downloads and tarballs. Branches do not. When we look for self-organization, the more visible and declarative the problems, the faster and more accurately we can work.</p>
<p><a name="Conclusions"></a><a name="header-165"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc164"><span><a href="http://zguide.zeromq.org/page:all#Conclusions">Conclusions</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-164">prev</a> <a href="http://zguide.zeromq.org/page:all#header-166">next</a></td>
</tr>
</tbody></table>
<p>In this section, I've listed a series of arguments, most of which came from fellow team members. Here's how it seems to break down: git veterans insist that branches are the way to work, whereas newcomers tend to feel intimidated when asked to navigate git branches. Git is not an easy tool to master. What we've discovered, accidentally, is that when you stop using branches <em>at all</em>, git becomes trivial to use. It literally comes down to six commands (<tt>clone</tt>, <tt>remote</tt>, <tt>commit</tt>, <tt>log</tt>, <tt>push</tt>, and <tt>pull</tt>). Furthermore, a branch-free process actually works, we've used it for a couple of years now, and no visible downside except surprise to the veterans and growth of "single" projects over multiple repositories.</p>
<p>If you can't use forks, perhaps because your firm doesn't trust GitHub's private repositories, then you can perhaps use topic branches, one per issue. You'll still suffer the costs of getting up-front consensus, low competitiveness, and risk of human error.</p>
<p><a name="Designing-for-Innovation"></a><a name="header-166"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc165"><span><a href="http://zguide.zeromq.org/page:all#Designing-for-Innovation">Designing for Innovation</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-165">prev</a> <a href="http://zguide.zeromq.org/page:all#header-167">next</a></td>
</tr>
</tbody></table>
<p>Let's look at innovation, which Wikipedia defines as, "the development of new values through solutions that meet new requirements, inarticulate needs, or old customer and market needs in value adding new ways." This really just means solving problems more cheaply. It sounds straight-forward, but the history of collapsed tech giants proves that it's not. I'll try to explain how teams so often get it wrong, and suggest a way for doing innovation right.</p>
<p><a name="The-Tale-of-Two-Bridges"></a><a name="header-167"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc166"><span><a href="http://zguide.zeromq.org/page:all#The-Tale-of-Two-Bridges">The Tale of Two Bridges</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-166">prev</a> <a href="http://zguide.zeromq.org/page:all#header-168">next</a></td>
</tr>
</tbody></table>
<p>Two old engineers were talking of their lives and boasting of their greatest projects. One of the engineers explained how he had designed one of the greatest bridges ever made.</p>
<p>"We built it across a river gorge," he told his friend. "It was wide and deep. We spent two years studying the land, and choosing designs and materials. We hired the best engineers and designed the bridge, which took another five years. We contracted the largest engineering firms to build the structures, the towers, the tollbooths, and the roads that would connect the bridge to the main highways. Dozens died during the construction. Under the road level we had trains, and a special path for cyclists. That bridge represented years of my life."</p>
<p>The second man reflected for a while, then spoke. "One evening me and a friend got drunk on vodka, and we threw a rope across a gorge," he said. "Just a rope, tied to two trees. There were two villages, one at each side. At first, people pulled packages across that rope with a pulley and string. Then someone threw a second rope, and built a foot walk. It was dangerous, but the kids loved it. A group of men then rebuilt that, made it solid, and women started to cross, everyday, with their produce. A market grew up on one side of the bridge, and slowly that became a large town, because there was a lot of space for houses. The rope bridge got replaced with a wooden bridge, to allow horses and carts to cross. Then the town built a real stone bridge, with metal beams. Later, they replaced the stone part with steel, and today there's a suspension bridge standing in that same spot."</p>
<p>The first engineer was silent. "Funny thing," he said, "my bridge was demolished about ten years after we built it. Turns out it was built in the wrong place and no one wanted to use it. Some guys had thrown a rope across the gorge, a few miles further downstream, and that's where everyone went."</p>
<p><a name="How-ZeroMQ-Lost-Its-Road-Map"></a><a name="header-168"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc167"><span><a href="http://zguide.zeromq.org/page:all#How-ZeroMQ-Lost-Its-Road-Map">How ZeroMQ Lost Its Road Map</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-167">prev</a> <a href="http://zguide.zeromq.org/page:all#header-169">next</a></td>
</tr>
</tbody></table>
<p>Presenting ZeroMQ at the Mix-IT conference in Lyon in early 2012, I was asked several times for the "road map". My answer was: there is no road map any longer. We had road maps, and we deleted them. Instead of a few experts trying to lay out the next steps, we were allowing this to happen organically. The audience didn't really like my answer. So un-French.</p>
<p>However, the history of ZeroMQ makes it quite clear why road maps were problematic. In the beginning, we had a small team making the library, with few contributors, and no documented road map. As ZeroMQ grew more popular and we switched to more contributors, users asked for road maps. So we collected our plans together and tried to organize them into releases. Here, we wrote, is what will come in the next release.</p>
<p>As we rolled out releases, we hit the problem that it's very easy to promise stuff, and rather harder to make it as planned. For one thing, much of the work was voluntary, and it's not clear how you force volunteers to commit to a road map. But also, priorities can shift dramatically over time. So we were making promises we could not keep, and the real deliveries didn't match the road maps.</p>
<p>The second problem was that by defining the road map, we in effect claimed territory, making it harder for others to participate. People do prefer to contribute to changes they believe were their idea. Writing down a list of things to do turns contribution into a chore rather than an opportunity.</p>
<p>Finally, we saw changes in ZeroMQ that were quite traumatic, and the road maps didn't help with this, despite a lot of discussion and effort to "do it right". Examples of this were incompatible changes in APIs and protocols. It was quite clear that we needed a different approach for defining the change process.</p>
<p>Software engineers don't like the notion that powerful, effective solutions can come into existence without an intelligent designer actively thinking things through. And yet no one in that room in Lyon would have questioned evolution. A strange irony, and one I wanted to explore further as it underpins the direction the ZeroMQ community has taken since the start of 2012.</p>
<p>In the dominant theory of innovation, brilliant individuals reflect on large problem sets and then carefully and precisely create a solution. Sometimes they will have "eureka" moments where they "get" brilliantly simple answers to whole large problem sets. The inventor, and the process of invention are rare, precious, and can command a monopoly. History is full of such heroic individuals. We owe them our modern world.</p>
<p>Looking more closely, however, and you will see that the facts don't match. History doesn't show lone inventors. It shows lucky people who steal or claim ownership of ideas that are being worked on by many. It shows brilliant people striking lucky once, and then spending decades on fruitless and pointless quests. The best known large-scale inventors like Thomas Edison were in fact just very good at systematic broad research done by large teams. It's like claiming that Steve Jobs invented every device made by Apple. It is a nice myth, good for marketing, but utterly useless as practical science.</p>
<p>Recent history, much better documented and less easy to manipulate, shows this well. The Internet is surely one of the most innovative and fast-moving areas of technology, and one of the best documented. It has no inventor. Instead, it has a massive economy of people who have carefully and progressively solved a long series of immediate problems, documented their answers, and made those available to all. The innovative nature of the Internet comes not from a small, select band of Einsteins. It comes from RFCs anyone can use and improve, made by hundreds and thousands of smart, but not uniquely smart, individuals. It comes from open source software anyone can use and improve. It comes from sharing, scale of community, and the continuous accretion of good solutions and disposal of bad ones.</p>
<p>Here thus is an alternative theory of innovation:</p>
<ol>
<li>There is an infinite problem/solution terrain.</li>
<li>This terrain changes over time according to external conditions.</li>
<li>We can only accurately perceive problems to which we are close.</li>
<li>We can rank the cost/benefit economics of problems using a market for solutions.</li>
<li>There is an optimal solution to any solvable problem.</li>
<li>We can approach this optimal solution heuristically, and mechanically.</li>
<li>Our intelligence can make this process faster, but does not replace it.</li>
</ol>
<p>There are a few corollaries to this:</p>
<ul>
<li><em>Individual creativity matters less than process.</em> Smarter people may work faster, but they may also work in the wrong direction. It's the collective vision of reality that keeps us honest and relevant.</li>
</ul>
<ul>
<li><em>We don't need road maps if we have a good process.</em> Functionality will emerge and evolve over time as solutions compete for market share.</li>
</ul>
<ul>
<li><em>We don't invent solutions so much as discover them.</em> All sympathies to the creative soul. It's just an information processing machine that likes to polish its own ego and collect karma.</li>
</ul>
<ul>
<li><em>Intelligence is a social effect, though it feels personal.</em> A person cut off from others eventually stops thinking. We can neither collect problems nor measure solutions without other people.</li>
</ul>
<ul>
<li><em>The size and diversity of the community is a key factor.</em> Larger, more diverse communities collect more relevant problems, and solve them more accurately, and do this faster, than a small expert group.</li>
</ul>
<p>So, when we trust the solitary experts, they make classic mistakes. They focus on ideas, not problems. They focus on the wrong problems. They make misjudgments about the value of solving problems. They don't use their own work.</p>
<p>Can we turn the above theory into a reusable process? In late 2011, I started documenting C4 and similar contracts, and using them both in ZeroMQ and in closed source projects. The underlying process is something I call "Simplicity Oriented Design", or SOD. This is a reproducible way of developing simple and elegant products. It organizes people into flexible supply chains that are able to navigate a problem landscape rapidly and cheaply. They do this by building, testing, and keeping or discarding minimal plausible solutions, called "patches". Living products consist of long series of patches, applied one atop the other.</p>
<p>SOD is relevant first because it's how we evolve ZeroMQ. It's also the basis for the design process we will use in <a href="http://zguide.zeromq.org/page:all#advanced-architecture">Chapter 7 - Advanced Architecture using ZeroMQ</a> to develop larger-scale ZeroMQ applications. Of course, you can use any software architecture methodology with ZeroMQ.</p>
<p>To best understand how we ended up with SOD, let's look at the alternatives.</p>
<p><a name="Trash-Oriented-Design"></a><a name="header-169"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc168"><span><a href="http://zguide.zeromq.org/page:all#Trash-Oriented-Design">Trash-Oriented Design</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-168">prev</a> <a href="http://zguide.zeromq.org/page:all#header-170">next</a></td>
</tr>
</tbody></table>
<p>The most popular design process in large businesses seems to be <em>Trash-Oriented Design</em>, or TOD. TOD feeds off the belief that all we need to make money are great ideas. It's tenacious nonsense, but a powerful crutch for people who lack imagination. The theory goes that ideas are rare, so the trick is to capture them. It's like non-musicians being awed by a guitar player, not realizing that great talent is so cheap it literally plays on the streets for coins.</p>
<p>The main output of TODs is expensive "ideation": concepts, design documents, and products that go straight into the trash can. It works as follows:</p>
<ul>
<li>The Creative People come up with long lists of "we could do X and Y". I've seen endlessly detailed lists of everything amazing a product could do. We've all been guilty of this. Once the creative work of idea generation has happened, it's just a matter of execution, of course.</li>
</ul>
<ul>
<li>So the managers and their consultants pass their brilliant ideas to designers who create acres of preciously refined design documents. The designers take the tens of ideas the managers came up with, and turn them into hundreds of world-changing designs.</li>
</ul>
<ul>
<li>These designs get given to engineers who scratch their heads and wonder who the heck came up with such nonsense. They start to argue back, but the designs come from up high, and really, it's not up to engineers to argue with creative people and expensive consultants.</li>
</ul>
<ul>
<li>So the engineers creep back to their cubicles, humiliated and threatened into building the gigantic but oh-so-elegant junk heap. It is bone-breaking work because the designs take no account of practical costs. Minor whims might take weeks of work to build. As the project gets delayed, the managers bully the engineers into giving up their evenings and weekends.</li>
</ul>
<ul>
<li>Eventually, something resembling a working product makes it out of the door. It's creaky and fragile, complex and ugly. The designers curse the engineers for their incompetence and pay more consultants to put lipstick onto the pig, and slowly the product starts to look a little nicer.</li>
</ul>
<ul>
<li>By this time, the managers have started to try to sell the product and they find, shockingly, that no one wants it. Undaunted, they courageously build million-dollar web sites and ad campaigns to explain to the public why they absolutely need this product. They do deals with other businesses to force the product on the lazy, stupid, and ungrateful market.</li>
</ul>
<ul>
<li>After twelve months of intense marketing, the product still isn't making profits. Worse, it suffers dramatic failures and gets branded in the press as a disaster. The company quietly shelves it, fires the consultants, buys a competing product from a small startup and rebrands that as its own Version 2. Hundreds of millions of dollars end up in the trash.</li>
</ul>
<ul>
<li>Meanwhile, another visionary manager somewhere in the organization drinks a little too much tequila with some marketing people and has a Brilliant Idea.</li>
</ul>
<p>Trash-Oriented Design would be a caricature if it wasn't so common. Something like 19 out of 20 market-ready products built by large firms are failures (yes, 87% of statistics are made up on the spot). The remaining 1 in 20 probably only succeeds because the competitors are so bad and the marketing is so aggressive.</p>
<p>The main lessons of TOD are quite straightforward but hard to swallow. They are:</p>
<ul>
<li>Ideas are cheap. No exceptions. There are no brilliant ideas. Anyone who tries to start a discussion with "oooh, we can do this too!" should be beaten down with all the passion one reserves for traveling evangelists. It is like sitting in a cafe at the foot of a mountain, drinking a hot chocolate and telling others, "Hey, I have a great idea, we can climb that mountain! And build a chalet on top! With two saunas! And a garden! Hey, and we can make it solar powered! Dude, that's awesome! What color should we paint it? Green! No, blue! OK, go and make it, I'll stay here and make spreadsheets and graphics!"</li>
</ul>
<ul>
<li>The starting point for a good design process is to collect real problems that confront real people. The second step is to evaluate these problems with the basic question, "How much is it worth to solve this problem?" Having done that, we can collect that set of problems that are worth solving.</li>
</ul>
<ul>
<li>Good solutions to real problems will succeed as products. Their success will depend on how good and cheap the solution is, and how important the problem is (and sadly, how big the marketing budgets are). But their success will also depend on how much they demand in effort to use—in other words, how simple they are.</li>
</ul>
<p>Now, after slaying the dragon of utter irrelevance, we attack the demon of complexity.</p>
<p><a name="Complexity-Oriented-Design"></a><a name="header-170"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc169"><span><a href="http://zguide.zeromq.org/page:all#Complexity-Oriented-Design">Complexity-Oriented Design</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-169">prev</a> <a href="http://zguide.zeromq.org/page:all#header-171">next</a></td>
</tr>
</tbody></table>
<p>Really good engineering teams and small firms can usually build decent products. But the vast majority of products still end up being too complex and less successful than they might be. This is because specialist teams, even the best, often stubbornly apply a process I call <em>Complexity-Oriented Design</em>, or COD, which works as follows:</p>
<ul>
<li>Management correctly identifies some interesting and difficult problem with economic value. In doing so, they already leapfrog over any TOD team.</li>
</ul>
<ul>
<li>The team with enthusiasm starts to build prototypes and core layers. These work as designed and thus encouraged, the team go off into intense design and architecture discussions, coming up with elegant schemas that look beautiful and solid.</li>
</ul>
<ul>
<li>Management comes back and challenges the team with yet more difficult problems. We tend to equate cost with value, so the harder and more expensive to solve, the more the solution should be worth, in their minds.</li>
</ul>
<ul>
<li>The team, being engineers and thus loving to build stuff, build stuff. They build and build and build and end up with massive, perfectly-designed complexity.</li>
</ul>
<ul>
<li>The products go to market, and the market scratches its head and asks, "Seriously, is this the best you can do?" People do use the products, especially if they aren't spending their own money in climbing the learning curve.</li>
</ul>
<ul>
<li>Management gets positive feedback from its larger customers, who share the same idea that high cost (in training and use) means high value, and so continues to push the process.</li>
</ul>
<ul>
<li>Meanwhile somewhere across the world, a small team is solving the same problem using a better process, and a year later smashes the market to little pieces.</li>
</ul>
<p>COD is characterized by a team obsessively solving the wrong problems in a form of collective delusion. COD products tend to be large, ambitious, complex, and unpopular. Much open source software is the output of COD processes. It is insanely hard for engineers to <em>stop</em> extending a design to cover more potential problems. They argue, "What if someone wants to do X?" but never ask themselves, "What is the real value of solving X?"</p>
<p>A good example of COD in practice is Bluetooth, a complex, over-designed set of protocols that users hate. It continues to exist only because in a massively-patented industry there are no real alternatives. Bluetooth is perfectly secure, which is close to pointless for a proximity protocol. At the same time, it lacks a standard API for developers, meaning it's really costly to use Bluetooth in applications.</p>
<p>On the #zeromq IRC channel, Wintre once wrote of how enraged he was many years ago when he "found that XMMS 2 had a working plugin system, but could not actually play music."</p>
<p>COD is a form of large-scale "rabbit-holing", in which designers and engineers cannot distance themselves from the technical details of their work. They add more and more features, utterly misreading the economics of their work.</p>
<p>The main lessons of COD are also simple, but hard for experts to swallow. They are:</p>
<ul>
<li>Making stuff that you don't immediately have a need for is pointless. Doesn't matter how talented or brilliant you are, if you just sit down and make stuff people are not actually asking for, you are most likely wasting your time.</li>
</ul>
<ul>
<li>Problems are not equal. Some are simple, and some are complex. Ironically, solving the simpler problems often has more value to more people than solving the really hard ones. So if you allow engineers to just work on random things, they'll mostly focus on the most interesting but least worthwhile things.</li>
</ul>
<ul>
<li>Engineers and designers love to make stuff and decoration, and this inevitably leads to complexity. It is crucial to have a "stop mechanism", a way to set short, hard deadlines that force people to make smaller, simpler answers to just the most crucial problems.</li>
</ul>
<p><a name="Simplicity-Oriented-Design"></a><a name="header-171"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc170"><span><a href="http://zguide.zeromq.org/page:all#Simplicity-Oriented-Design">Simplicity Oriented Design</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-170">prev</a> <a href="http://zguide.zeromq.org/page:all#header-172">next</a></td>
</tr>
</tbody></table>
<p>Finally, we come to the rare but precious <em>Simplicity Oriented Design</em>, or SOD. This process starts with a realization: we do not know what we have to make until after we start making it. Coming up with ideas or large-scale designs isn't just wasteful, it's a direct hindrance to designing the truly accurate solutions. The really juicy problems are hidden like far valleys, and any activity except active scouting creates a fog that hides those distant valleys. You need to keep mobile, pack light, and move fast.</p>
<p>SOD works as follows:</p>
<ul>
<li>We collect a set of interesting problems (by looking at how people use technology or other products) and we line these up from simple to complex, looking for and identifying patterns of use.</li>
</ul>
<ul>
<li>We take the simplest, most dramatic problem and we solve this with a minimal plausible solution, or "patch". Each patch solves exactly a genuine and agreed-upon problem in a brutally minimal fashion.</li>
</ul>
<ul>
<li>We apply one measure of quality to patches, namely "Can this be done any simpler while still solving the stated problem?" We can measure complexity in terms of concepts and models that the user has to learn or guess in order to use the patch. The fewer, the better. A perfect patch solves a problem with zero learning required by the user.</li>
</ul>
<ul>
<li>Our product development consists of a patch that solves the problem "we need a proof of concept" and then evolves in an unbroken line to a mature series of products, through hundreds or thousands of patches piled on top of each other.</li>
</ul>
<ul>
<li>We do not do <em>anything</em> that is not a patch. We enforce this rule with formal processes that demand that every activity or task is tied to a genuine and agreed-upon problem, explicitly enunciated and documented.</li>
</ul>
<ul>
<li>We build our projects into a supply chain where each project can provide problems to its "suppliers" and receive patches in return. The supply chain creates the "stop mechanism" because when people are impatiently waiting for an answer, we necessarily cut our work short.</li>
</ul>
<ul>
<li>Individuals are free to work on any projects, and provide patches at any place they feel it's worthwhile. No individuals "own" any project, except to enforce the formal processes. A single project can have many variations, each a collection of different, competing patches.</li>
</ul>
<ul>
<li>Projects export formal and documented interfaces so that upstream (client) projects are unaware of change happening in supplier projects. Thus multiple supplier projects can compete for client projects, in effect creating a free and competitive market.</li>
</ul>
<ul>
<li>We tie our supply chain to real users and external clients and we drive the whole process by rapid cycles so that a problem received from outside users can be analyzed, evaluated, and solved with a patch in a few hours.</li>
</ul>
<ul>
<li>At every moment from the very first patch, our product is shippable. This is essential, because a large proportion of patches will be wrong (10-30%) and only by giving the product to users can we know which patches have become problems that need solving.</li>
</ul>
<p>SOD is a <em>hill-climbing algorithm</em>, a reliable way of finding optimal solutions to the most significant problems in an unknown landscape. You don't need to be a genius to use SOD successfully, you just need to be able to see the difference between the fog of activity and the progress towards new real problems.</p>
<p>People have pointed out that hill-climbing algorithms have known limitations. One gets stuck on local peaks, mainly. But this is nonetheless how life itself works: collecting tiny incremental improvements over long periods of time. There is no intelligent designer. We reduce the risk of local peaks by spreading out widely across the landscape, but it is somewhat moot. The limitations aren't optional, they are physical laws. The theory says, <em>this is how innovation really works, so better embrace it and work with it than try to work on the basis of magical thinking</em>.</p>
<p>And in fact once you see all innovation as more or less successful hill-climbing, you realize why some teams and companies and products get stuck in a never-never land of diminishing prospects. They simply don't have the diversity and collective intelligence to find better hills to climb. When Nokia killed their open source projects, they cut their own throat.</p>
<p>A really good designer with a good team can use SOD to build world-class products, rapidly and accurately. To get the most out of SOD the designer has to use the product continuously, from day one, and develop his or her ability to smell out problems such as inconsistency, surprising behavior, and other forms of friction. We naturally overlook many annoyances, but a good designer picks these up and thinks about how to patch them. Design is about removing friction in the use of a product.</p>
<p>In an open source setting, we do this work in public. There's no "let's open the code" moment. Projects that do this are in my view missing the point of open source, which is to engage your users in your exploration, and to build community around the seed of the architecture.</p>
<p><a name="Burnout"></a><a name="header-172"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc171"><span><a href="http://zguide.zeromq.org/page:all#Burnout">Burnout</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-171">prev</a> <a href="http://zguide.zeromq.org/page:all#header-173">next</a></td>
</tr>
</tbody></table>
<p>The ZeroMQ community has been and still is heavily dependent on pro bono individual efforts. I'd like to think that everyone was compensated in some way for their contributions, and I believe that with ZeroMQ, contributing means gaining expertise in an extraordinarily valuable technology, which leads to improved professional options.</p>
<p>However, not all projects will be so lucky and if you work with or in open source, you should understand the risk of burnout that volunteers face. This applies to all pro bono communities. In this section, I'll explain what causes burnout, how to recognize it, how to prevent it, and (if it happens) how to try to treat it. Disclaimer: I'm not a psychiatrist and this article is based on my own experiences of working in pro bono contexts for the last 20 years, including free software projects, and NGOs such as the <a href="http://www.ffii.org/">FFII</a>.</p>
<p>In a pro bono context, we're expected to work without direct or obvious economic incentive. That is, we sacrifice family life, professional advancement, free time, and health in order to accomplish some goal we have decided to accomplish. In any project, we need some kind of reward to make it worth continuing each day. In most pro bono projects the rewards are very indirect, superficially not economical at all. Mostly, we do things because people say, "Hey, great!" Karma is a powerful motivator.</p>
<p>However, we are economic beings, and sooner or later, if a project costs us a great deal and does not bring economic rewards of some kind (money, fame, a new job), we start to suffer. At a certain stage, it seems our subconscious simply gets disgusted and says, "Enough is enough!" and refuses to go any further. If we try to force ourselves, we can literally get sick.</p>
<p>This is what I call "burnout", though the term is also used for other kinds of exhaustion. Too much investment on a project with too little economic reward, for too long. We are great at manipulating ourselves and others, and this is often part of the process that leads to burnout. We tell ourselves that it's for a good cause and that the other guy is doing OK, so we should be able to as well.</p>
<p>When I got burned out on open source projects like Xitami, I remember clearly how I felt. I simply stopped working on it, refused to answer any more emails, and told people to forget about it. You can tell when someone's burned out. They go offline, and everyone starts saying, "He's acting strange… depressed, or tired…"</p>
<p>Diagnosis is simple. Has someone worked a lot on a project that was not paying back in any way? Did she make exceptional sacrifices? Did he lose or abandon his job or studies to do the project? If you're answering "yes", it's burnout.</p>
<p>There are three simple techniques I've developed over the years to reduce the risk of burnout in the teams I work with:</p>
<ul>
<li><em>No one is irreplaceable.</em> Working solo on a critical or popular project—the concentration of responsibility on one person who cannot set their own limits—is probably the main factor. It's a management truism: if someone in your organization is irreplaceable, get rid of him or her.</li>
</ul>
<ul>
<li><em>We need day jobs to pay the bills.</em> This can be hard, but seems necessary. Getting money from somewhere else makes it much easier to sustain a sacrificial project.</li>
</ul>
<ul>
<li><em>Teach people about burnout.</em> This should be a basic course in colleges and universities, as pro bono work becomes a more common way for young people to experiment professionally.</li>
</ul>
<p>When someone is working alone on a critical project, you <em>know</em> they are going blow their fuses sooner or later. It's actually fairly predictable: something like 18-36 months depending on the individual and how much economic stress they face in their private lives. I've not seen anyone burn-out after half a year, nor last five years in a unrewarding project.</p>
<p>There is a simple cure for burnout that works in at least some cases: get paid decently for your work. However, this pretty much destroys the freedom of movement (across that infinite problem landscape) that the volunteer enjoys.</p>
<p><a name="Patterns-for-Success"></a><a name="header-173"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc172"><span><a href="http://zguide.zeromq.org/page:all#Patterns-for-Success">Patterns for Success</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-172">prev</a> <a href="http://zguide.zeromq.org/page:all#header-174">next</a></td>
</tr>
</tbody></table>
<p>I'll end this code-free chapter with a series of patterns for success in software engineering. They aim to capture the essence of what divides glorious success from tragic failure. They were described as "religious maniacal dogma" by a manager, and "anything else would be effing insane" by a colleague, in a single day. For me, they are science. But treat the Lazy Perfectionist and others as tools to use, sharpen, and throw away if something better comes along.</p>
<p><a name="The-Lazy-Perfectionist"></a><a name="header-174"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc173"><span><a href="http://zguide.zeromq.org/page:all#The-Lazy-Perfectionist">The Lazy Perfectionist</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-173">prev</a> <a href="http://zguide.zeromq.org/page:all#header-175">next</a></td>
</tr>
</tbody></table>
<p><em>Never design anything that's not a precise minimal answer to a problem we can identify and have to solve.</em></p>
<p>The Lazy Perfectionist spends his idle time observing others and identifying problems that are worth solving. He looks for agreement on those problems, always asking, "What is the <em>real</em> problem". Then he moves, precisely and minimally, to build, or get others to build, a usable answer to one problem. He uses, or gets others to use those solutions. And he repeats this until there are no problems left to solve, or time or money runs out.</p>
<p><a name="The-Benevolent-Tyrant"></a><a name="header-175"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc174"><span><a href="http://zguide.zeromq.org/page:all#The-Benevolent-Tyrant">The Benevolent Tyrant</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-174">prev</a> <a href="http://zguide.zeromq.org/page:all#header-176">next</a></td>
</tr>
</tbody></table>
<p><em>The control of a large force is the same principle as the control of a few men: it is merely a question of dividing up their numbers.</em> — Sun Tzu</p>
<p>The Benevolent Tyrant divides large problems into smaller ones and throws them at groups to focus on. She brokers contracts between these groups, in the form of APIs and the "unprotocols" we'll read about in the next chapter. The Benevolent Tyrant constructs a supply chain that starts with problems, and results in usable solutions. She is ruthless about how the supply chain works, but does not tell people what to work on, nor how to do their work.</p>
<p><a name="The-Earth-and-Sky"></a><a name="header-176"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc175"><span><a href="http://zguide.zeromq.org/page:all#The-Earth-and-Sky">The Earth and Sky</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-175">prev</a> <a href="http://zguide.zeromq.org/page:all#header-177">next</a></td>
</tr>
</tbody></table>
<p><em>The ideal team consists of two sides: one writing code, and one providing feedback.</em></p>
<p>The Earth and Sky work together as a whole, in close proximity, but they communicate formally through issue tracking. Sky seeks out problems from others and from their own use of the product and feeds these to Earth. Earth rapidly answers with testable solutions. Earth and Sky can work through dozens of issues in a day. Sky talks to other users, and Earth talks to other developers. Earth and Sky may be two people, or two small groups.</p>
<p><a name="The-Open-Door"></a><a name="header-177"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc176"><span><a href="http://zguide.zeromq.org/page:all#The-Open-Door">The Open Door</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-176">prev</a> <a href="http://zguide.zeromq.org/page:all#header-178">next</a></td>
</tr>
</tbody></table>
<p><em>The accuracy of knowledge comes from diversity.</em></p>
<p>The Open Door accepts contributions from almost anyone. She does not argue quality or direction, instead allowing others to argue that and get more engaged. She calculates that even a troll will bring more diverse opinion to the group. She lets the group form its opinion about what goes into stable code, and she enforces this opinion with help of a Benevolent Tyrant.</p>
<p><a name="The-Laughing-Clown"></a><a name="header-178"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc177"><span><a href="http://zguide.zeromq.org/page:all#The-Laughing-Clown">The Laughing Clown</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-177">prev</a> <a href="http://zguide.zeromq.org/page:all#header-179">next</a></td>
</tr>
</tbody></table>
<p><em>Perfection precludes participation.</em></p>
<p>The Laughing Clown, often acting as the Happy Failure, makes no claim to high competence. Instead his antics and bumbling attempts provoke others into rescuing him from his own tragedy. Somehow however, he always identifies the right problems to solve. People are so busy proving him wrong they don't realize they're doing valuable work.</p>
<p><a name="The-Mindful-General"></a><a name="header-179"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc178"><span><a href="http://zguide.zeromq.org/page:all#The-Mindful-General">The Mindful General</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-178">prev</a> <a href="http://zguide.zeromq.org/page:all#header-180">next</a></td>
</tr>
</tbody></table>
<p><em>Make no plans. Set goals, develop strategies and tactics.</em></p>
<p>The Mindful General operates in unknown territory, solving problems that are hidden until they are nearby. Thus she makes no plans, but seeks opportunities, then exploits them rapidly and accurately. She develops tactics and strategies in the field, and teaches these to her soldiers so they can move independently, and together.</p>
<p><a name="The-Social-Engineer"></a><a name="header-180"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc179"><span><a href="http://zguide.zeromq.org/page:all#The-Social-Engineer">The Social Engineer</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-179">prev</a> <a href="http://zguide.zeromq.org/page:all#header-181">next</a></td>
</tr>
</tbody></table>
<p><em>If you know the enemy and know yourself, you need not fear the result of a hundred battles.</em> — Sun Tzu</p>
<p>The Social Engineer reads the hearts and minds of those he works with and for. He asks, of everyone, "What makes this person angry, insecure, argumentative, calm, happy?" He studies their moods and dispositions. With this knowledge he can encourage those who are useful, and discourage those who are not. The Social Engineer never acts on his own emotions.</p>
<p><a name="The-Constant-Gardener"></a><a name="header-181"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc180"><span><a href="http://zguide.zeromq.org/page:all#The-Constant-Gardener">The Constant Gardener</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-180">prev</a> <a href="http://zguide.zeromq.org/page:all#header-182">next</a></td>
</tr>
</tbody></table>
<p><em>He will win whose army is animated by the same spirit throughout all its ranks.</em> — Sun Tzu</p>
<p>The Constant Gardener grows a process from a small seed, step-by-step as more people come into the project. She makes every change for a precise reason, with agreement from everyone. She never imposes a process from above but lets others come to consensus, and then he enforces that consensus. In this way, everyone owns the process together and by owning it, they are attached to it.</p>
<p><a name="The-Rolling-Stone"></a><a name="header-182"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc181"><span><a href="http://zguide.zeromq.org/page:all#The-Rolling-Stone">The Rolling Stone</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-181">prev</a> <a href="http://zguide.zeromq.org/page:all#header-183">next</a></td>
</tr>
</tbody></table>
<p><em>After crossing a river, you should get far away from it.</em> — Sun Tzu</p>
<p>The Rolling Stone accepts his own mortality and transience. He has no attachment to his past work. He accepts that all that we make is destined for the trash can, it is just a matter of time. With precise, minimal investments, he can move rapidly away from the past and stay focused on the present and near future. Above all, he has no ego and no pride to be hurt by the actions of others.</p>
<p><a name="The-Pirate-Gang"></a><a name="header-183"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc182"><span><a href="http://zguide.zeromq.org/page:all#The-Pirate-Gang">The Pirate Gang</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-182">prev</a> <a href="http://zguide.zeromq.org/page:all#header-184">next</a></td>
</tr>
</tbody></table>
<p><em>Code, like all knowledge, works best as collective—not private—property.</em></p>
<p>The Pirate Gang organizes freely around problems. It accepts authority insofar as authority provides goals and resources. The Pirate Gang owns and shares all it makes: every work is fully remixable by others in the Pirate Gang. The gang moves rapidly as new problems emerge, and is quick to abandon old solutions if those stop being relevant. No persons or groups can monopolize any part of the supply chain.</p>
<p><a name="The-Flash-Mob"></a><a name="header-184"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc183"><span><a href="http://zguide.zeromq.org/page:all#The-Flash-Mob">The Flash Mob</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-183">prev</a> <a href="http://zguide.zeromq.org/page:all#header-185">next</a></td>
</tr>
</tbody></table>
<p><em>Water shapes its course according to the nature of the ground over which it flows.</em> — Sun Tzu</p>
<p>The Flash Mob comes together in space and time as needed, then disperses as soon as they can. Physical closeness is essential for high-bandwidth communications. But over time it creates technical ghettos, where Earth gets separated from Sky. The Flash Mob tends to collect a lot of frequent flier miles.</p>
<p><a name="The-Canary-Watcher"></a><a name="header-185"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc184"><span><a href="http://zguide.zeromq.org/page:all#The-Canary-Watcher">The Canary Watcher</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-184">prev</a> <a href="http://zguide.zeromq.org/page:all#header-186">next</a></td>
</tr>
</tbody></table>
<p><em>Pain is not, generally, a Good Sign.</em></p>
<p>The Canary Watcher measures the quality of an organization by their own pain level, and the observed pain levels of those with whom he works. He brings new participants into existing organizations so they can express the raw pain of the innocent. He may use alcohol to get others to verbalize their pain points. He asks others, and himself, "Are you happy in this process, and if not, why not?" When an organization causes pain in himself or others, he treats that as a problem to be fixed. People should feel joy in their work.</p>
<p><a name="The-Hangman"></a><a name="header-186"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc185"><span><a href="http://zguide.zeromq.org/page:all#The-Hangman">The Hangman</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-185">prev</a> <a href="http://zguide.zeromq.org/page:all#header-187">next</a></td>
</tr>
</tbody></table>
<p><em>Never interrupt others when they are making mistakes.</em></p>
<p>The Hangman knows that we learn only by making mistakes, and she gives others copious rope with which to learn. She only pulls the rope gently, when it's time. A little tug to remind the other of their precarious position. Allowing others to learn by failure gives the good reason to stay, and the bad excuse to leave. The Hangman is endlessly patient, because there is no shortcut to the learning process.</p>
<p><a name="The-Historian"></a><a name="header-187"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc186"><span><a href="http://zguide.zeromq.org/page:all#The-Historian">The Historian</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-186">prev</a> <a href="http://zguide.zeromq.org/page:all#header-188">next</a></td>
</tr>
</tbody></table>
<p><em>Keeping the public record may be tedious, but it's the only way to prevent collusion.</em></p>
<p>The Historian forces discussion into the public view, to prevent collusion to own areas of work. The Pirate Gang depends on full and equal communications that do not depend on momentary presence. No one really reads the archives, but the simply possibility stops most abuses. The Historian encourages the right tool for the job: email for transient discussions, IRC for chatter, wikis for knowledge, issue tracking for recording opportunities.</p>
<p><a name="The-Provocateur"></a><a name="header-188"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc187"><span><a href="http://zguide.zeromq.org/page:all#The-Provocateur">The Provocateur</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-187">prev</a> <a href="http://zguide.zeromq.org/page:all#header-189">next</a></td>
</tr>
</tbody></table>
<p><em>When a man knows he is to be hanged in a fortnight, it concentrates his mind wonderfully.</em> — Samuel Johnson</p>
<p>The Provocateur creates deadlines, enemies, and the occasional impossibility. Teams work best when they don't have time for the crap. Deadlines bring people together and focus the collective mind. An external enemy can move a passive team into action. The Provocateur never takes the deadline too seriously. The product is <em>always</em> ready to ship. But she gently reminds the team of the stakes: fail, and we all look for other jobs.</p>
<p><a name="The-Mystic"></a><a name="header-189"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc188"><span><a href="http://zguide.zeromq.org/page:all#The-Mystic">The Mystic</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-188">prev</a> <a href="http://zguide.zeromq.org/page:all#header-190">next</a></td>
</tr>
</tbody></table>
<p><em>When people argue or complain, just write them a Sun Tzu quotation</em> — Mikko Koppanen</p>
<p>The Mystic never argues directly. He knows that to argue with an emotional person only creates more emotion. Instead he side-steps the discussion. It's hard to be angry at a Chinese general, especially when he has been dead for 2,400 years. The Mystic plays Hangman when people insist on the right to get it wrong.</p>
<p><a name="advanced-architecture"></a><br>
<a name="Chapter-Advanced-Architecture-using-ZeroMQ"></a><a name="header-190"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h2 id="toc189"><span><a href="http://zguide.zeromq.org/page:all#Chapter-Advanced-Architecture-using-ZeroMQ">Chapter 7 - Advanced Architecture using ZeroMQ</a></span></h2>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-189">prev</a> <a href="http://zguide.zeromq.org/page:all#header-191">next</a></td>
</tr>
</tbody></table>
<p>One of the effects of using ZeroMQ at large scale is that because we can build distributed architectures so much faster than before, the limitations of our software engineering processes become more visible. Mistakes in slow motion are often harder to see (or rather, easier to rationalize away).</p>
<p>My experience when teaching ZeroMQ to groups of engineers is that it's rarely sufficient to just explain how ZeroMQ works and then just expect them to start building successful products. Like any technology that removes friction, ZeroMQ opens the door to big blunders. If ZeroMQ is the ACME rocket-propelled shoe of distributed software development, a lot of us are like Wile E. Coyote, slamming full speed into the proverbial desert cliff.</p>
<p>We saw in <a href="http://zguide.zeromq.org/page:all#the-community">Chapter 6 - The ZeroMQ Community</a> that ZeroMQ itself uses a formal process for changes. One reason we built this process, over some years, was to stop the repeated cliff-slamming that happened in the library itself.</p>
<p>Partly, it's about slowing down and partially, it's about ensuring that when you move fast, you go—and this is essential Dear Reader—in the <em>right direction</em>. It's my standard interview riddle: what's the rarest property of any software system, the absolute hardest thing to get right, the lack of which causes the slow or fast death of the vast majority of projects? The answer is not code quality, funding, performance, or even (though it's a close answer), popularity. The answer is <em>accuracy</em>.</p>
<p>Accuracy is half the challenge, and applies to any engineering work. The other half is distributed computing itself, which sets up a whole range of problems that we need to solve if we are going to create architectures. We need to encode and decode data; we need to define protocols to connect clients and servers; we need to secure these protocols against attackers; and we need to make stacks that are robust. Asynchronous messaging is hard to get right.</p>
<p>This chapter will tackle these challenges, starting with a basic reappraisal of how to design and build software and ending with a fully formed example of a distributed application for large-scale file distribution.</p>
<p>We'll cover the following juicy topics:</p>
<ul>
<li>How to go from idea to working prototype safely (the MOPED pattern)</li>
<li>Different ways to serialize your data as ZeroMQ messages</li>
<li>How to code-generate binary serialization codecs</li>
<li>How to build custom code generators using the GSL tool</li>
<li>How to write and license a protocol specification</li>
<li>How to build fast restartable file transfer over ZeroMQ</li>
<li>How to use credit-based flow control for nonblocking transfers</li>
<li>How to build protocol servers and clients as state machines</li>
<li>How to make a secure protocol over ZeroMQ</li>
<li>A large-scale file publishing system (FileMQ)</li>
</ul>
<p><a name="Message-Oriented-Pattern-for-Elastic-Design"></a><a name="header-191"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc190"><span><a href="http://zguide.zeromq.org/page:all#Message-Oriented-Pattern-for-Elastic-Design">Message-Oriented Pattern for Elastic Design</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-190">prev</a> <a href="http://zguide.zeromq.org/page:all#header-192">next</a></td>
</tr>
</tbody></table>
<p>I'll introduce Message-Oriented Pattern for Elastic Design (MOPED), a software engineering pattern for ZeroMQ architectures. It was either "MOPED" or "BIKE", the Backronym-Induced Kinetic Effect. That's short for "BICICLE", the Backronym-Inflated See if I Care Less Effect. In life, one learns to go with the least embarrassing choice.</p>
<p>If you've read this book carefully, you'll have seen MOPED in action already. The development of Majordomo in <a href="http://zguide.zeromq.org/page:all#reliable-request-reply">Chapter 4 - Reliable Request-Reply Patterns</a> is a near-perfect case. But cute names are worth a thousand words.</p>
<p>The goal of MOPED is to define a process by which we can take a rough use case for a new distributed application, and go from "Hello World" to fully-working prototype in any language in under a week.</p>
<p>Using MOPED, you grow, more than build, a working ZeroMQ architecture from the ground-up with minimal risk of failure. By focusing on the contracts rather than the implementations, you avoid the risk of premature optimization. By driving the design process through ultra-short test-based cycles, you can be more certain that what you have works before you add more.</p>
<p>We can turn this into five real steps:</p>
<ul>
<li>Step 1: internalize the ZeroMQ semantics.</li>
<li>Step 2: draw a rough architecture.</li>
<li>Step 3: decide on the contracts.</li>
<li>Step 4: make a minimal end-to-end solution.</li>
<li>Step 5: solve one problem and repeat.</li>
</ul>
<p><a name="Step-Internalize-the-Semantics"></a><a name="header-192"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc191"><span><a href="http://zguide.zeromq.org/page:all#Step-Internalize-the-Semantics">Step 1: Internalize the Semantics</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-191">prev</a> <a href="http://zguide.zeromq.org/page:all#header-193">next</a></td>
</tr>
</tbody></table>
<p>You must learn and digest ZeroMQ's "language", that is, the socket patterns and how they work. The only way to learn a language is to use it. There's no way to avoid this investment, no tapes you can play while you sleep, no chips you can plug in to magically become smarter. Read this book from the start, work through the code examples in whatever language you prefer, understand what's going on, and (most importantly) write some examples yourself and then throw them away.</p>
<p>At a certain point, you'll feel a clicking noise in your brain. Maybe you'll have a weird chili-induced dream where little ZeroMQ tasks run around trying to eat you alive. Maybe you'll just think "aaahh, so <em>that's</em> what it means!" If we did our work right, it should take two to three days. However long it takes, until you start thinking in terms of ZeroMQ sockets and patterns, you're not ready for step 2.</p>
<p><a name="Step-Draw-a-Rough-Architecture"></a><a name="header-193"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc192"><span><a href="http://zguide.zeromq.org/page:all#Step-Draw-a-Rough-Architecture">Step 2: Draw a Rough Architecture</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-192">prev</a> <a href="http://zguide.zeromq.org/page:all#header-194">next</a></td>
</tr>
</tbody></table>
<p>From my experience, it's essential to be able to draw the core of your architecture. It helps others understand what you are thinking, and it also helps you think through your ideas. There is really no better way to design a good architecture than to explain your ideas to your colleagues, using a whiteboard.</p>
<p>You don't need to get it right, and you don't need to make it complete. What you do need to do is break your architecture into pieces that make sense. The nice thing about software architecture (as compared to constructing bridges) is that your really can replace entire layers cheaply if you've isolated them.</p>
<p>Start by choosing the core problem that you are going to solve. Ignore anything that's not essential to that problem: you will add it in later. The problem should be an end-to-end problem: the rope across the gorge.</p>
<p>For example, a client asked us to make a supercomputing cluster with ZeroMQ. Clients create bundles of work, which are sent to a broker that distributes them to workers (running on fast graphics processors), collects the results back, and returns them to the client.</p>
<p>The rope across the gorge is one client talking to a broker talking to one worker. We draw three boxes: client, broker, worker. We draw arrows from box to box showing the request flowing one way and the response flowing back. It's just like the many diagrams we saw in earlier chapters.</p>
<p>Be minimalistic. Your goal is not to define a <em>real</em> architecture, but to throw a rope across the gorge to bootstrap your process. We make the architecture successfully more complete and realistic over time: e.g., adding multiple workers, adding client and worker APIs, handling failures, and so on.</p>
<p><a name="Step-Decide-on-the-Contracts"></a><a name="header-194"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc193"><span><a href="http://zguide.zeromq.org/page:all#Step-Decide-on-the-Contracts">Step 3: Decide on the Contracts</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-193">prev</a> <a href="http://zguide.zeromq.org/page:all#header-195">next</a></td>
</tr>
</tbody></table>
<p>A good software architecture depends on contracts, and the more explicit they are, the better things scale. You don't care <em>how</em> things happen; you only care about the results. If I send an email, I don't care how it arrives at its destination, as long as the contract is respected. The email contract is: it arrives within a few minutes, no-one modifies it, and it doesn't get lost.</p>
<p>And to build a large system that works well, you must focus on the contracts before the implementations. It may sound obvious but all too often, people forget or ignore this, or are just too shy to impose themselves. I wish I could say ZeroMQ had done this properly, but for years our public contracts were second-rate afterthoughts instead of primary in-your-face pieces of work.</p>
<p>So what is a contract in a distributed system? There are, in my experience, two types of contract:</p>
<ul>
<li>The APIs to client applications. Remember the Psychological Elements. The APIs need to be as absolutely <em>simple</em>, <em>consistent</em>, and <em>familiar</em> as possible. Yes, you can generate API documentation from code, but you must first design it, and designing an API is often hard.</li>
</ul>
<ul>
<li>The protocols that connect the pieces. It sounds like rocket science, but it's really just a simple trick, and one that ZeroMQ makes particularly easy. In fact they're so simple to write, and need so little bureaucracy that I call them <em>unprotocols</em>.</li>
</ul>
<p>You write minimal contracts that are mostly just place markers. Most messages and most API methods will be missing or empty. You also want to write down any known technical requirements in terms of throughput, latency, reliability, and so on. These are the criteria on which you will accept or reject any particular piece of work.</p>
<p><a name="Step-Write-a-Minimal-End-to-End-Solution"></a><a name="header-195"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc194"><span><a href="http://zguide.zeromq.org/page:all#Step-Write-a-Minimal-End-to-End-Solution">Step 4: Write a Minimal End-to-End Solution</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-194">prev</a> <a href="http://zguide.zeromq.org/page:all#header-196">next</a></td>
</tr>
</tbody></table>
<p>The goal is to test out the overall architecture as rapidly as possible. Make skeleton applications that call the APIs, and skeleton stacks that implement both sides of every protocol. You want to get a working end-to-end "Hello World" as soon as you can. You want to be able to test code as you write it, so that you can weed out the broken assumptions and inevitable errors you make. Do not go off and spend six months writing a test suite! Instead, make a minimal bare-bones application that uses our still-hypothetical API.</p>
<p>If you design an API wearing the hat of the person who implements it, you'll start to think of performance, features, options, and so on. You'll make it more complex, more irregular, and more surprising than it should be. But, and here's the trick (it's a cheap one, was big in Japan): if you design an API while wearing the hat of the person who has to actually write apps that use it, you use all that laziness and fear to your advantage.</p>
<p>Write down the protocols on a wiki or shared document in such a way that you can explain every command clearly without too much detail. Strip off any real functionality, because it will only create inertia that makes it harder to move stuff around. You can always add weight. Don't spend effort defining formal message structures: pass the minimum around in the simplest possible fashion using ZeroMQ's multipart framing.</p>
<p>Our goal is to get the simplest test case working, without any avoidable functionality. Everything you can chop off the list of things to do, you chop. Ignore the groans from colleagues and bosses. I'll repeat this once again: you can <em>always</em> add functionality, that's relatively easy. But aim to keep the overall weight to a minimum.</p>
<p><a name="Step-Solve-One-Problem-and-Repeat"></a><a name="header-196"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc195"><span><a href="http://zguide.zeromq.org/page:all#Step-Solve-One-Problem-and-Repeat">Step 5: Solve One Problem and Repeat</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-195">prev</a> <a href="http://zguide.zeromq.org/page:all#header-197">next</a></td>
</tr>
</tbody></table>
<p>You're now in the happy cycle of issue-driven development where you can start to solve tangible problems instead of adding features. Write issues that each state a clear problem, and propose a solution. As you design the API, keep in mind your standards for names, consistency, and behavior. Writing these down in prose often helps keep them sane.</p>
<p>From here, every single change you make to the architecture and code can be proven by running the test case, watching it not work, making the change, and then watching it work.</p>
<p>Now you go through the whole cycle (extending the test case, fixing the API, updating the protocol, and extending the code, as needed), taking problems one at a time and testing the solutions individually. It should take about 10-30 minutes for each cycle, with the occasional spike due to random confusion.</p>
<p><a name="Unprotocols"></a><a name="header-197"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc196"><span><a href="http://zguide.zeromq.org/page:all#Unprotocols">Unprotocols</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-196">prev</a> <a href="http://zguide.zeromq.org/page:all#header-198">next</a></td>
</tr>
</tbody></table>
<p><a name="Protocols-Without-The-Goats"></a><a name="header-198"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc197"><span><a href="http://zguide.zeromq.org/page:all#Protocols-Without-The-Goats">Protocols Without The Goats</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-197">prev</a> <a href="http://zguide.zeromq.org/page:all#header-199">next</a></td>
</tr>
</tbody></table>
<p>When this man thinks of protocols, this man thinks of massive documents written by committees, over years. This man thinks of the IETF, W3C, ISO, Oasis, regulatory capture, FRAND patent license disputes, and soon after, this man thinks of retirement to a nice little farm in northern Bolivia up in the mountains where the only other needlessly stubborn beings are the goats chewing up the coffee plants.</p>
<p>Now, I've nothing personal against committees. The useless folk need a place to sit out their lives with minimal risk of reproducing; after all, that only seems fair. But most committee protocols tend towards complexity (the ones that work), or trash (the ones we don't talk about). There's a few reasons for this. One is the amount of money at stake. More money means more people who want their particular prejudices and assumptions expressed in prose. But two is the lack of good abstractions on which to build. People have tried to build reusable protocol abstractions, like BEEP. Most did not stick, and those that did, like SOAP and XMPP, are on the complex side of things.</p>
<p>It used to be, decades ago, when the Internet was a young modest thing, that protocols were short and sweet. They weren't even "standards", but "requests for comments", which is as modest as you can get. It's been one of my goals since we started iMatix in 1995 to find a way for ordinary people like me to write small, accurate protocols without the overhead of the committees.</p>
<p>Now, ZeroMQ does appear to provide a living, successful protocol abstraction layer with its "we'll carry multipart messages over random transports" way of working. Because ZeroMQ deals silently with framing, connections, and routing, it's surprisingly easy to write full protocol specs on top of ZeroMQ, and in <a href="http://zguide.zeromq.org/page:all#reliable-request-reply">Chapter 4 - Reliable Request-Reply Patterns</a> and <a href="http://zguide.zeromq.org/page:all#advanced-pub-sub">Chapter 5 - Advanced Pub-Sub Patterns</a> I showed how to do this.</p>
<p>Somewhere around mid-2007, I kicked off the Digital Standards Organization to define new simpler ways of producing little standards, protocols, and specifications. In my defense, it was a quiet summer. At the time, I wrote that a new specification should take <a href="http://www.digistan.org/spec:1">"minutes to explain, hours to design, days to write, weeks to prove, months to become mature, and years to replace."</a></p>
<p>In 2010, we started calling such little specifications <em>unprotocols</em>, which some people might mistake for a dastardly plan for world domination by a shadowy international organization, but which really just means "protocols without the goats".</p>
<p><a name="Contracts-Are-Hard"></a><a name="header-199"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc198"><span><a href="http://zguide.zeromq.org/page:all#Contracts-Are-Hard">Contracts Are Hard</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-198">prev</a> <a href="http://zguide.zeromq.org/page:all#header-200">next</a></td>
</tr>
</tbody></table>
<p>Writing contracts is perhaps the most difficult part of large-scale architecture. With unprotocols, we remove as much of the unnecessary friction as possible. What remains is still a hard set of problems to solve. A good contract (be it an API, a protocol, or a rental agreement) has to be simple, unambiguous, technically sound, and easy to enforce.</p>
<p>Like any technical skill, it's something you have to learn and practice. There are a series of specifications on the<br>
<a href="http://rfc.zeromq.org/">ZeroMQ RFC site</a>, which are worth reading and using them as a basis for your own specifications when you find yourself in need.</p>
<p>I'll try to summarize my experience as a protocol writer:</p>
<ul>
<li>Start simple, and develop your specifications step-by-step. Don't solve problems you don't have in front of you.</li>
</ul>
<ul>
<li>Use very clear and consistent language. A protocol may often break down into commands and fields; use clear short names for these entities.</li>
</ul>
<ul>
<li>Try to avoid inventing concepts. Reuse anything you can from existing specifications. Use terminology that is obvious and clear to your audience.</li>
</ul>
<ul>
<li>Make <em>nothing</em> for which you cannot demonstrate an immediate need. Your specification solves problems; it does not provide features. Make the simplest plausible solution for each problem that you identify.</li>
</ul>
<ul>
<li>Implement your protocol <em>as you build it</em>, so that you are aware of the technical consequences of each choice. Use a language that makes it hard (like C) and not one that makes it easy (like Python).</li>
</ul>
<ul>
<li>Test your specification <em>as you build it</em> on other people. Your best feedback on a specification is when someone else tries to implement it without the assumptions and knowledge that you have in your head.</li>
</ul>
<ul>
<li>Cross-test rapidly and consistently, throwing others' clients against your servers and vice versa.</li>
</ul>
<ul>
<li>Be prepared to throw it out and start again as often as needed. Plan for this, by layering your architecture so that e.g., you can keep an API but change the underlying protocols.</li>
</ul>
<ul>
<li>Only use constructs that are independent of programming language and operating system.</li>
</ul>
<ul>
<li>Solve a large problem in layers, making each layer an independent specification. Beware of creating monolithic protocols. Think about how reusable each layer is. Think about how different teams could build competing specifications at each layer.</li>
</ul>
<p>And above all, <em>write it down</em>. Code is not a specification. The point about a written specification is that no matter how weak it is, it can be systematically improved. By writing down a specification, you will also spot inconsistencies and gray areas that are impossible to see in code.</p>
<p>If this sounds hard, don't worry too much. One of the less obvious benefits of using ZeroMQ is that it cuts the effort necessary to write a protocol spec by perhaps 90% or more because it already handles framing, routing, queuing, and so on. This means that you can experiment rapidly, make mistakes cheaply, and thus learn rapidly.</p>
<p><a name="How-to-Write-Unprotocols"></a><a name="header-200"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc199"><span><a href="http://zguide.zeromq.org/page:all#How-to-Write-Unprotocols">How to Write Unprotocols</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-199">prev</a> <a href="http://zguide.zeromq.org/page:all#header-201">next</a></td>
</tr>
</tbody></table>
<p>When you start to write an unprotocol specification document, stick to a consistent structure so that your readers know what to expect. Here is the structure I use:</p>
<ul>
<li>Cover section: with a 1-line summary, URL to the spec, formal name, version, who to blame.</li>
<li>License for the text: absolutely needed for public specifications.</li>
<li>The change process: i.e., how can I as a reader fix problems in the specification?</li>
<li>Use of language: MUST, MAY, SHOULD, and so on, with a reference to RFC 2119.</li>
<li>Maturity indicator: is this an experimental, draft, stable, legacy, or retired?</li>
<li>Goals of the protocol: what problems is it trying to solve?</li>
<li>Formal grammar: prevents arguments due to different interpretations of the text.</li>
<li>Technical explanation: semantics of each message, error handling, and so on.</li>
<li>Security discussion: explicitly, how secure the protocol is.</li>
<li>References: to other documents, protocols, and so on.</li>
</ul>
<p>Writing clear, expressive text is hard. Do avoid trying to describe implementations of the protocol. Remember that you're writing a contract. You describe in clear language the obligations and expectations of each party, the level of obligation, and the penalties for breaking the rules. You do not try to define <em>how</em> each party honors its part of the deal.</p>
<p>Here are some key points about unprotocols:</p>
<ul>
<li>As long as your process is open, then you don't need a committee: just make clean minimal designs and make sure anyone is free to improve them.</li>
</ul>
<ul>
<li>If use an existing license, then you don't have legal worries afterwards. I use GPLv3 for my public specifications and advise you to do the same. For in-house work, standard copyright is perfect.</li>
</ul>
<ul>
<li>Formality is valuable. That is, learn to write a formal grammar such as ABNF (Augmented Backus-Naur Form) and use this to fully document your messages.</li>
</ul>
<ul>
<li>Use a market-driven life cycle process like <a href="http://www.digistan.org/spec:1">Digistan's COSS</a> so that people place the right weight on your specs as they mature (or don't).</li>
</ul>
<p><a name="Why-use-the-GPLv-for-Public-Specifications"></a><a name="header-201"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc200"><span><a href="http://zguide.zeromq.org/page:all#Why-use-the-GPLv-for-Public-Specifications">Why use the GPLv3 for Public Specifications?</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-200">prev</a> <a href="http://zguide.zeromq.org/page:all#header-202">next</a></td>
</tr>
</tbody></table>
<p>The license you choose is particularly crucial for public specifications. Traditionally, protocols are published under custom licenses, where the authors own the text and derived works are forbidden. This sounds great (after all, who wants to see a protocol forked?), but it's in fact highly risky. A protocol committee is vulnerable to capture, and if the protocol is important and valuable, the incentive for capture grows.</p>
<p>Once captured, like some wild animals, an important protocol will often die. The real problem is that there's no way to <em>free</em> a captive protocol published under a conventional license. The word "free" isn't just an adjective to describe speech or air, it's also a verb, and the right to fork a work <em>against the wishes of the owner</em> is essential to avoiding capture.</p>
<p>Let me explain this in shorter words. Imagine that iMatix writes a protocol today that's really amazing and popular. We publish the spec and many people implement it. Those implementations are fast and awesome, and free as in beer. They start to threaten an existing business. Their expensive commercial product is slower and can't compete. So one day they come to our iMatix office in Maetang-Dong, South Korea, and offer to buy our firm. Because we're spending vast amounts on sushi and beer, we accept gratefully. With evil laughter, the new owners of the protocol stop improving the public version, close the specification, and add patented extensions. Their new products support this new protocol version, but the open source versions are legally blocked from doing so. The company takes over the whole market, and competition ends.</p>
<p>When you contribute to an open source project, you really want to know your hard work won't be used against you by a closed source competitor. This is why the GPL beats the "more permissive" BSD/MIT/X11 licenses for most contributors. These licenses give permission to cheat. This applies just as much to protocols as to source code.</p>
<p>When you implement a GPLv3 specification, your applications are of course yours, and licensed any way you like. But you can be certain of two things. One, that specification will <em>never</em> be embraced and extended into proprietary forms. Any derived forms of the specification must also be GPLv3. Two, no one who ever implements or uses the protocol will ever launch a patent attack on anything it covers, nor can they add their patented technology to it without granting the world a free license.</p>
<p><a name="Using-ABNF"></a><a name="header-202"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc201"><span><a href="http://zguide.zeromq.org/page:all#Using-ABNF">Using ABNF</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-201">prev</a> <a href="http://zguide.zeromq.org/page:all#header-203">next</a></td>
</tr>
</tbody></table>
<p>My advice when writing protocol specs is to learn and use a formal grammar. It's just less hassle than allowing others to interpret what you mean, and then recover from the inevitable false assumptions. The target of your grammar is other people, engineers, not compilers.</p>
<p>My favorite grammar is ABNF, as defined by <a href="http://www.ietf.org/rfc/rfc2234.txt">RFC 2234</a>, because it is probably the simplest and most widely used formal language for defining bidirectional communications protocols. Most IETF (Internet Engineering Task Force) specifications use ABNF, which is good company to be in.</p>
<p>I'll give a 30-second crash course in writing ABNF. It may remind you of regular expressions. You write the grammar as rules. Each rule takes the form "name = elements". An element can be another rule (which you define below as another rule) or a pre-defined <em>terminal</em> like <tt>CRLF</tt>, <tt>OCTET</tt>, or a number. <a href="http://www.ietf.org/rfc/rfc2234.txt">The RFC</a> lists all the terminals. To define alternative elements, separate with a slash. To define repetition, use an asterisk. To group elements, use parentheses. Read the RFC because it's not intuitive.</p>
<p>I'm not sure if this extension is proper, but I then prefix elements with "C:" and "S:" to indicate whether they come from the client or server.</p>
<p>Here's a piece of ABNF for an unprotocol called NOM that we'll come back to later in this chapter:</p>
<div class="code">
<pre><code>nom-protocol    = open-peering *use-peering

open-peering    = C:OHAI ( S:OHAI-OK / S:WTF )

use-peering     = C:ICANHAZ
                / S:CHEEZBURGER
                / C:HUGZ S:HUGZ-OK
                / S:HUGZ C:HUGZ-OK</code>
</pre></div>
<p>I've actually used these keywords (<tt>OHAI</tt>, <tt>WTF</tt>) in commercial projects. They make developers giggly and happy. They confuse management. They're good in first drafts that you want to throw away later.</p>
<p><a name="The-Cheap-or-Nasty-Pattern"></a><a name="header-203"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc202"><span><a href="http://zguide.zeromq.org/page:all#The-Cheap-or-Nasty-Pattern">The Cheap or Nasty Pattern</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-202">prev</a> <a href="http://zguide.zeromq.org/page:all#header-204">next</a></td>
</tr>
</tbody></table>
<p>There is a general lesson I've learned over a couple of decades of writing protocols small and large. I call this the <em>Cheap or Nasty</em> pattern: you can often split your work into two aspects or layers and solve these separately—one using a "cheap" approach, the other using a "nasty" approach.</p>
<p>The key insight to making Cheap or Nasty work is to realize that many protocols mix a low-volume chatty part for control, and a high-volume asynchronous part for data. For instance, HTTP has a chatty dialog to authenticate and get pages, and an asynchronous dialog to stream data. FTP actually splits this over two ports; one port for control and one port for data.</p>
<p>Protocol designers who don't separate control from data tend to make horrid protocols, because the trade-offs in the two cases are almost totally opposed. What is perfect for control is bad for data, and what's ideal for data just doesn't work for control. It's especially true when we want high performance at the same time as extensibility and good error checking.</p>
<p>Let's break this down using a classic client/server use case. The client connects to the server and authenticates. It then asks for some resource. The server chats back, then starts to send data back to the client. Eventually, the client disconnects or the server finishes, and the conversation is over.</p>
<p>Now, before starting to design these messages, stop and think, and let's compare the control dialog and the data flow:</p>
<ul>
<li>The control dialog lasts a short time and involves very few messages. The data flow could last for hours or days, and involve billions of messages.</li>
</ul>
<ul>
<li>The control dialog is where all the "normal" errors happen, e.g., not authenticated, not found, payment required, censored, and so on. In contrast, any errors that happen during the data flow are exceptional (disk full, server crashed).</li>
</ul>
<ul>
<li>The control dialog is where things will change over time as we add more options, parameters, and so on. The data flow should barely change over time because the semantics of a resource are fairly constant over time.</li>
</ul>
<ul>
<li>The control dialog is essentially a synchronous request/reply dialog. The data flow is essentially a one-way asynchronous flow.</li>
</ul>
<p>These differences are critical. When we talk about performance, it applies <em>only</em> to data flows. It's pathological to design a one-time control dialog to be fast. Thus when we talk about the cost of serialization, this only applies to the data flow. The cost of encoding/decoding the control flow could be huge, and for many cases it would not change a thing. So we encode control using Cheap, and we encode data flows using Nasty.</p>
<p>Cheap is essentially synchronous, verbose, descriptive, and flexible. A Cheap message is full of rich information that can change for each application. Your goal as designer is to make this information easy to encode and parse, trivial to extend for experimentation or growth, and highly robust against change both forwards and backwards. The Cheap part of a protocol looks like this:</p>
<ul>
<li>It uses a simple self-describing structured encoding for data, be it XML, JSON, HTTP-style headers, or some other. Any encoding is fine as long as there are standard simple parsers for it in your target languages.</li>
</ul>
<ul>
<li>It uses a straight request-reply model where each request has a success/failure reply. This makes it trivial to write correct clients and servers for a Cheap dialog.</li>
</ul>
<ul>
<li>It doesn't try, even marginally, to be fast. Performance doesn't matter when you do something only once or a few times per session.</li>
</ul>
<p>A Cheap parser is something you take off the shelf and throw data at. It shouldn't crash, shouldn't leak memory, should be highly tolerant, and should be relatively simple to work with. That's it.</p>
<p>Nasty however is essentially asynchronous, terse, silent, and inflexible. A Nasty message carries minimal information that practically never changes. Your goal as designer is to make this information ultrafast to parse, and possibly even impossible to extend and experiment with. The ideal Nasty pattern looks like this:</p>
<ul>
<li>It uses a hand-optimized binary layout for data, where every bit is precisely crafted.</li>
</ul>
<ul>
<li>It uses a pure asynchronous model where one or both peers send data without acknowledgments (or if they do, they use sneaky asynchronous techniques like credit-based flow control).</li>
</ul>
<ul>
<li>It doesn't try, even marginally, to be friendly. Performance is all that matters when you are doing something several million times per second.</li>
</ul>
<p>A Nasty parser is something you write by hand, which writes or reads bits, bytes, words, and integers individually and precisely. It rejects anything it doesn't like, does no memory allocations at all, and never crashes.</p>
<p>Cheap or Nasty isn't a universal pattern; not all protocols have this dichotomy. Also, how you use Cheap or Nasty will depend on the situation. In some cases, it can be two parts of a single protocol. In other cases, it can be two protocols, one layered on top of the other.</p>
<p><a name="Error-Handling"></a><a name="header-204"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc203"><span><a href="http://zguide.zeromq.org/page:all#Error-Handling">Error Handling</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-203">prev</a> <a href="http://zguide.zeromq.org/page:all#header-205">next</a></td>
</tr>
</tbody></table>
<p>Using Cheap or Nasty makes error handling rather simpler. You have two kinds of commands and two ways to signal errors:</p>
<ul>
<li>Synchronous control commands: errors are normal: every request has a response that is either OK or an error response.</li>
<li>Asynchronous data commands: errors are exceptional: bad commands are either discarded silently, or cause the whole connection to be closed.</li>
</ul>
<p>It's usually good to distinguish a few kinds of errors, but as always keep it minimal and add only what you need.</p>
<p><a name="Serializing-Your-Data"></a><a name="header-205"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc204"><span><a href="http://zguide.zeromq.org/page:all#Serializing-Your-Data">Serializing Your Data</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-204">prev</a> <a href="http://zguide.zeromq.org/page:all#header-206">next</a></td>
</tr>
</tbody></table>
<p>When we start to design a protocol, one of the first questions we face is how we encode data on the wire. There is no universal answer. There are a half-dozen different ways to serialize data, each with pros and cons. We'll explore some of these.</p>
<p><a name="Abstraction-Level"></a><a name="header-206"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc205"><span><a href="http://zguide.zeromq.org/page:all#Abstraction-Level">Abstraction Level</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-205">prev</a> <a href="http://zguide.zeromq.org/page:all#header-207">next</a></td>
</tr>
</tbody></table>
<p>Before looking at how to put data onto the wire, it's worth asking what data we actually want to exchange between applications. If we don't use any abstraction, we literally serialize and deserialize our internal state. That is, the objects and structures we use to implement our functionality.</p>
<p>Putting internal state onto the wire is however a really bad idea. It's like exposing internal state in an API. When you do this, you are hard-coding your implementation decisions into your protocols. You are also going to produce protocols that are significantly more complex than they need to be.</p>
<p>It's perhaps the main reason so many older protocols and APIs are so complex: their designers did not think about how to abstract them into simpler concepts. There is of course no guarantee than an abstraction will be <em>simpler</em>; that's where the hard work comes in.</p>
<p>A good protocol or API abstraction encapsulates natural patterns of use, and gives them name and properties that are predictable and regular. It chooses sensible defaults so that the main use cases can be specified minimally. It aims to be simple for the simple cases, and expressive for the rarer complex cases. It does not make any statements or assumptions about the internal implementation unless that is absolutely needed for interoperability.</p>
<p><a name="ZeroMQ-Framing"></a><a name="header-207"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc206"><span><a href="http://zguide.zeromq.org/page:all#ZeroMQ-Framing">ZeroMQ Framing</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-206">prev</a> <a href="http://zguide.zeromq.org/page:all#header-208">next</a></td>
</tr>
</tbody></table>
<p>The simplest and most widely used serialization format for ZeroMQ applications is ZeroMQ's own multipart framing. For example, here is how the <a href="http://rfc.zeromq.org/spec:7">Majordomo Protocol</a> defines a request:</p>
<div class="code">
<pre><code>Frame 0: Empty frame
Frame 1: "MDPW01" (six bytes, representing MDP/Worker v0.1)
Frame 2: 0x02 (one byte, representing REQUEST)
Frame 3: Client address (envelope stack)
Frame 4: Empty (zero bytes, envelope delimiter)
Frames 5+: Request body (opaque binary)</code>
</pre></div>
<p>To read and write this in code is easy, but this is a classic example of a control flow (the whole of MDP is really, as it's a chatty request-reply protocol). When we came to improve MDP for the second version, we had to change this framing. Excellent, we broke all existing implementations!</p>
<p>Backwards compatibility is hard, but using ZeroMQ framing for control flows <em>does not help</em>. Here's how I should have designed this protocol if I'd followed my own advice (and I'll fix this in the next version). It's split into a Cheap part and a Nasty part, and uses the ZeroMQ framing to separate these:</p>
<div class="code">
<pre><code>Frame 0: "MDP/2.0" for protocol name and version
Frame 1: command header
Frame 2: command body</code>
</pre></div>
<p>Where we'd expect to parse the command header in the various intermediaries (client API, broker, and worker API), and pass the command body untouched from application to application.</p>
<p><a name="Serialization-Languages"></a><a name="header-208"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc207"><span><a href="http://zguide.zeromq.org/page:all#Serialization-Languages">Serialization Languages</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-207">prev</a> <a href="http://zguide.zeromq.org/page:all#header-209">next</a></td>
</tr>
</tbody></table>
<p>Serialization languages have their fashions. XML used to be big as in popular, then it got big as in over-engineered, and then it fell into the hands of "Enterprise Information Architects" and it's not been seen alive since. Today's XML is the epitome of "somewhere in that mess is small, elegant language trying to escape".</p>
<p>Still XML was way, way better than its predecessors, which included such monsters as the Standard Generalized Markup Language (SGML), which in turn was a cool breeze compared to mind-torturing beasts like EDIFACT. So the history of serialization languages seems to be of gradually emerging sanity, hidden by waves of revolting EIAs doing their best to hold onto their jobs.</p>
<p>JSON popped out of the JavaScript world as a quick-and-dirty "I'd rather resign than use XML here" way to throw data onto the wire and get it back again. JSON is just minimal XML expressed, sneakily, as JavaScript source code.</p>
<p>Here's a simple example of using JSON in a Cheap protocol:</p>
<div class="code">
<pre><code>"protocol": {
    "name": "MTL",
    "version": 1
},
"virtual-host": "test-env"</code>
</pre></div>
<p>The same data in XML would be (XML forces us to invent a single top-level entity):</p>
<div class="code">
<pre><code>&lt;command&gt;
    &lt;protocol name = "MTL" version = "1" /&gt;
    &lt;virtual-host&gt;test-env&lt;/virtual-host&gt;
&lt;/command&gt;</code>
</pre></div>
<p>And here it is using plain-old HTTP-style headers:</p>
<div class="code">
<pre><code>Protocol: MTL/1.0
Virtual-host: test-env</code>
</pre></div>
<p>These are all pretty equivalent as long as you don't go overboard with validating parsers, schemas, and other "trust us, this is all for your own good" nonsense. A Cheap serialization language gives you space for experimentation for free ("ignore any elements/attributes/headers that you don't recognize"), and it's simple to write generic parsers that, for example, thunk a command into a hash table, or vice versa.</p>
<p>However, it's not all roses. While modern scripting languages support JSON and XML easily enough, older languages do not. If you use XML or JSON, you create nontrivial dependencies. It's also somewhat of a pain to work with tree-structured data in a language like C.</p>
<p>So you can drive your choice according to the languages for which you're aiming. If your universe is a scripting language, then go for JSON. If you are aiming to build protocols for wider system use, keep things simple for C developers and stick to HTTP-style headers.</p>
<p><a name="Serialization-Libraries"></a><a name="header-209"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc208"><span><a href="http://zguide.zeromq.org/page:all#Serialization-Libraries">Serialization Libraries</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-208">prev</a> <a href="http://zguide.zeromq.org/page:all#header-210">next</a></td>
</tr>
</tbody></table>
<p>The <tt>msgpack.org</tt> site says:</p>
<p>I'm going to make the perhaps unpopular claim that "fast and small" are features that solve non-problems. The only real problem that serialization libraries solve is, as far as I can tell, the need to document the message contracts and actually serialize data to and from the wire.</p>
<p>Let's start by debunking "fast and small". It's based on a two-part argument. First, that making your messages smaller and reducing CPU cost for encoding and decoding will make a significant difference to your application's performance. Second, that this equally valid across-the-board to all messages.</p>
<p>But most real applications tend to fall into one of two categories. Either the speed of serialization and size of encoding is marginal compared to other costs, such as database access or application code performance. Or, network performance really is critical, and then all significant costs occur in a few specific message types.</p>
<p>Thus, aiming for "fast and small" across the board is a false optimization. You neither get the easy flexibility of Cheap for your infrequent control flows, nor do you get the brutal efficiency of Nasty for your high-volume data flows. Worse, the assumption that all messages are equal in some way can corrupt your protocol design. Cheap or Nasty isn't only about serialization strategies, it's also about synchronous versus asynchronous, error handling and the cost of change.</p>
<p>My experience is that most performance problems in message-based applications can be solved by (a) improving the application itself and (b) hand-optimizing the high-volume data flows. And to hand-optimize your most critical data flows, you need to cheat; to learn exploit facts about your data, something general purpose serializers cannot do.</p>
<p>Now let's address documentation and the need to write our contracts explicitly and formally, rather than only in code. This is a valid problem to solve, indeed one of the main ones if we're to build a long-lasting, large-scale message-based architecture.</p>
<p>Here is how we describe a typical message using the MessagePack interface definition language (IDL):</p>
<div class="code">
<pre><code>message Person {
  1: string surname
  2: string firstname
  3: optional string email
}</code>
</pre></div>
<p>Now, the same message using the Google protocol buffers IDL:</p>
<div class="code">
<pre><code>message Person {
  required string surname = 1;
  required string firstname = 2;
  optional string email = 3;
}</code>
</pre></div>
<p>It works, but in most practical cases wins you little over a serialization language backed by decent specifications written by hand or produced mechanically (we'll come to this). The price you'll pay is an extra dependency and quite probably, worse overall performance than if you used Cheap or Nasty.</p>
<p><a name="Handwritten-Binary-Serialization"></a><a name="header-210"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc209"><span><a href="http://zguide.zeromq.org/page:all#Handwritten-Binary-Serialization">Handwritten Binary Serialization</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-209">prev</a> <a href="http://zguide.zeromq.org/page:all#header-211">next</a></td>
</tr>
</tbody></table>
<p>As you'll gather from this book, my preferred language for systems programming is C (upgraded to C99, with a constructor/destructor API model and generic containers). There are two reasons I like this modernized C language. First, I'm too weak-minded to learn a big language like C++. Life just seems filled with more interesting things to understand. Second, I find that this specific level of manual control lets me produce better results, faster.</p>
<p>The point here isn't C versus C++, but the value of manual control for high-end professional users. It's no accident that the best cars, cameras, and espresso machines in the world have manual controls. That level of on-the-spot fine tuning often makes the difference between world class success, and being second best.</p>
<p>When you are really, truly concerned about the speed of serialization and/or the size of the result (often these contradict each other), you need handwritten binary serialization. In other words, let's hear it for Mr. Nasty!</p>
<p>Your basic process for writing an efficient Nasty encoder/decoder (codec) is:</p>
<ul>
<li>Build representative data sets and test applications that can stress test your codec.</li>
<li>Write a first dumb version of the codec.</li>
<li>Test, measure, improve, and repeat until you run out of time and/or money.</li>
</ul>
<p>Here are some of the techniques we use to make our codecs better:</p>
<ul>
<li><em>Use a profiler.</em> There's simply no way to know what your code is doing until you've profiled it for function counts and for CPU cost per function. When you find your hot spots, fix them.</li>
</ul>
<ul>
<li><em>Eliminate memory allocations.</em> The heap is very fast on a modern Linux kernel, but it's still the bottleneck in most naive codecs. On older kernels, the heap can be tragically slow. Use local variables (the stack) instead of the heap where you can.</li>
</ul>
<ul>
<li><em>Test on different platforms and with different compilers and compiler options.</em> Apart from the heap, there are many other differences. You need to learn the main ones, and allow for them.</li>
</ul>
<ul>
<li><em>Use state to compress better.</em> If you are concerned about codec performance, you are almost definitely sending the same kinds of data many times. There will be redundancy between instances of data. You can detect these and use that to compress (e.g., a short value that means "same as last time").</li>
</ul>
<ul>
<li><em>Know your data.</em> The best compression techniques (in terms of CPU cost for compactness) require knowing about the data. For example, the techniques used to compress a word list, a video, and a stream of stock market data are all different.</li>
</ul>
<ul>
<li><em>Be ready to break the rules.</em> Do you really need to encode integers in big-endian network byte order? x86 and ARM account for almost all modern CPUs, yet use little-endian (ARM is actually bi-endian but Android, like Windows and iOS, is little-endian).</li>
</ul>
<p><a name="Code-Generation"></a><a name="header-211"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h4 id="toc210"><span><a href="http://zguide.zeromq.org/page:all#Code-Generation">Code Generation</a></span></h4>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-210">prev</a> <a href="http://zguide.zeromq.org/page:all#header-212">next</a></td>
</tr>
</tbody></table>
<p>Reading the previous two sections, you might have wondered, "could I write my own IDL generator that was better than a general purpose one?" If this thought wandered into your mind, it probably left pretty soon after, chased by dark calculations about how much work that actually involved.</p>
<p>What if I told you of a way to build custom IDL generators cheaply and quickly? You can have a way to get perfectly documented contracts, code that is as evil and domain-specific as you need it to be, and all you need to do is sign away your soul (<em>who ever really used that, am I right?</em>) just here…</p>
<p>At iMatix, until a few years ago, we used code generation to build ever larger and more ambitious systems until we decided the technology (GSL) was too dangerous for common use, and we sealed the archive and locked it with heavy chains in a deep dungeon. We actually posted it on GitHub. If you want to try the examples that are coming up, grab <a href="https://github.com/imatix/gsl">the repository</a> and build yourself a <tt>gsl</tt> command. Typing "make" in the src subdirectory should do it (and if you're that guy who loves Windows, I'm sure you'll send a patch with project files).</p>
<p>This section isn't really about GSL at all, but about a useful and little-known trick that's useful for ambitious architects who want to scale themselves, as well as their work. Once you learn the trick, you can whip up your own code generators in a short time. The code generators most software engineers know about come with a single hard-coded model. For instance, Ragel "compiles executable finite state machines from regular languages", i.e., Ragel's model is a regular language. This certainly works for a good set of problems, but it's far from universal. How do you describe an API in Ragel? Or a project makefile? Or even a finite-state machine like the one we used to design the Binary Star pattern in <a href="http://zguide.zeromq.org/page:all#reliable-request-reply">Chapter 4 - Reliable Request-Reply Patterns</a>?</p>
<p>All these would benefit from code generation, but there's no universal model. So the trick is to design your own models as you need them, and then make code generators as cheap compilers for that model. You need some experience in how to make good models, and you need a technology that makes it cheap to build custom code generators. A scripting language, like Perl and Python, is a good option. However, we actually built GSL specifically for this, and that's what I prefer.</p>
<p>Let's take a simple example that ties into what we already know. We'll see more extensive examples later, because I really do believe that code generation is crucial knowledge for large-scale work. In <a href="http://zguide.zeromq.org/page:all#reliable-request-reply">Chapter 4 - Reliable Request-Reply Patterns</a>, we developed the <a href="http://rfc.zeromq.org/spec:7">Majordomo Protocol (MDP)</a>, and wrote clients, brokers, and workers for that. Now could we generate those pieces mechanically, by building our own interface description language and code generators?</p>
<p>When we write a GSL model, we can use <em>any</em> semantics we like, in other words we can invent domain-specific languages on the spot. I'll invent a couple—see if you can guess what they represent:</p>
<div class="code">
<pre><code>slideshow
    name = Cookery level 3
    page
        title = French Cuisine
        item = Overview
        item = The historical cuisine
        item = The nouvelle cuisine
        item = Why the French live longer
    page
        title = Overview
        item = Soups and salads
        item = Le plat principal
        item = Béchamel and other sauces
        item = Pastries, cakes, and quiches
        item = Soufflé: cheese to strawberry</code>
</pre></div>
<p>How about this one:</p>
<div class="code">
<pre><code>table
    name = person
    column
        name = firstname
        type = string
    column
        name = lastname
        type = string
    column
        name = rating
        type = integer</code>
</pre></div>
<p>We could compile the first into a presentation. The second, we could compile into SQL to create and work with a database table. So for this exercise, our domain language, our <em>model</em>, consists of "classes" that contain "messages" that contain "fields" of various types. It's deliberately familiar. Here is the MDP client protocol:</p>
<div class="code">
<pre><code>&lt;class name = "mdp_client"&gt;
    MDP/Client
    &lt;header&gt;
        &lt;field name = "empty" type = "string" value = ""
            &gt;Empty frame&lt;/field&gt;
        &lt;field name = "protocol" type = "string" value = "MDPC01"
            &gt;Protocol identifier&lt;/field&gt;
    &lt;/header&gt;
    &lt;message name = "request"&gt;
        Client request to broker
        &lt;field name = "service" type = "string"&gt;Service name&lt;/field&gt;
        &lt;field name = "body" type = "frame"&gt;Request body&lt;/field&gt;
    &lt;/message&gt;
    &lt;message name = "reply"&gt;
        Response back to client
        &lt;field name = "service" type = "string"&gt;Service name&lt;/field&gt;
        &lt;field name = "body" type = "frame"&gt;Response body&lt;/field&gt;
    &lt;/message&gt;
&lt;/class&gt;</code>
</pre></div>
<p>And here is the MDP worker protocol:</p>
<div class="code">
<pre><code>&lt;class name = "mdp_worker"&gt;
    MDP/Worker
    &lt;header&gt;
        &lt;field name = "empty" type = "string" value = ""
            &gt;Empty frame&lt;/field&gt;
        &lt;field name = "protocol" type = "string" value = "MDPW01"
            &gt;Protocol identifier&lt;/field&gt;
        &lt;field name = "id" type = "octet"&gt;Message identifier&lt;/field&gt;
    &lt;/header&gt;
    &lt;message name = "ready" id = "1"&gt;
        Worker tells broker it is ready
        &lt;field name = "service" type = "string"&gt;Service name&lt;/field&gt;
    &lt;/message&gt;
    &lt;message name = "request" id = "2"&gt;
        Client request to broker
        &lt;field name = "client" type = "frame"&gt;Client address&lt;/field&gt;
        &lt;field name = "body" type = "frame"&gt;Request body&lt;/field&gt;
    &lt;/message&gt;
    &lt;message name = "reply" id = "3"&gt;
        Worker returns reply to broker
        &lt;field name = "client" type = "frame"&gt;Client address&lt;/field&gt;
        &lt;field name = "body" type = "frame"&gt;Request body&lt;/field&gt;
    &lt;/message&gt;
    &lt;message name = "hearbeat" id = "4"&gt;
        Either peer tells the other it's still alive
    &lt;/message&gt;
    &lt;message name = "disconnect" id = "5"&gt;
        Either peer tells other the party is over
    &lt;/message&gt;
&lt;/class&gt;</code>
</pre></div>
<p>GSL uses XML as its modeling language. XML has a poor reputation, having been dragged through too many enterprise sewers to smell sweet, but it has some strong positives, as long as you keep it simple. Any way to write a self-describing hierarchy of items and attributes would work.</p>
<p>Now here is a short IDL generator written in GSL that turns our protocol models into documentation:</p>
<div class="code">
<pre><code>.#  Trivial IDL generator (specs.gsl)
.#
.output "$(class.name).md"
## The $(string.trim (class.?''):left) Protocol
.for message
.   frames = count (class-&gt;header.field) + count (field)

A $(message.NAME) command consists of a multipart message of $(frames)
frames:

.   for class-&gt;header.field
.       if name = "id"
* Frame $(item ()): 0x$(message.id:%02x) (1 byte, $(message.NAME))
.       else
* Frame $(item ()): "$(value:)" ($(string.length ("$(value)")) \
bytes, $(field.:))
.       endif
.   endfor
.   index = count (class-&gt;header.field) + 1
.   for field
* Frame $(index): $(field.?'') \
.       if type = "string"
(printable string)
.       elsif type = "frame"
(opaque binary)
.           index += 1
.       else
.           echo "E: unknown field type: $(type)"
.       endif
.       index += 1
.   endfor
.endfor</code>
</pre></div>
<p>The XML models and this script are in the subdirectory examples/models. To do the code generation, I give this command:</p>
<div class="code">
<pre><code>gsl -script:specs mdp_client.xml mdp_worker.xml</code>
</pre></div>
<p>Here is the Markdown text we get for the worker protocol:</p>
<div class="code">
<pre><code>## The MDP/Worker Protocol

A READY command consists of a multipart message of 4 frames:

* Frame 1: "" (0 bytes, Empty frame)
* Frame 2: "MDPW01" (6 bytes, Protocol identifier)
* Frame 3: 0x01 (1 byte, READY)
* Frame 4: Service name (printable string)

A REQUEST command consists of a multipart message of 5 frames:

* Frame 1: "" (0 bytes, Empty frame)
* Frame 2: "MDPW01" (6 bytes, Protocol identifier)
* Frame 3: 0x02 (1 byte, REQUEST)
* Frame 4: Client address (opaque binary)
* Frame 6: Request body (opaque binary)

A REPLY command consists of a multipart message of 5 frames:

* Frame 1: "" (0 bytes, Empty frame)
* Frame 2: "MDPW01" (6 bytes, Protocol identifier)
* Frame 3: 0x03 (1 byte, REPLY)
* Frame 4: Client address (opaque binary)
* Frame 6: Request body (opaque binary)

A HEARBEAT command consists of a multipart message of 3 frames:

* Frame 1: "" (0 bytes, Empty frame)
* Frame 2: "MDPW01" (6 bytes, Protocol identifier)
* Frame 3: 0x04 (1 byte, HEARBEAT)

A DISCONNECT command consists of a multipart message of 3 frames:

* Frame 1: "" (0 bytes, Empty frame)
* Frame 2: "MDPW01" (6 bytes, Protocol identifier)
* Frame 3: 0x05 (1 byte, DISCONNECT)</code>
</pre></div>
<p>This, as you can see, is close to what I wrote by hand in the original spec. Now, if you have cloned the <tt>zguide</tt> repository and you are looking at the code in <tt>examples/models</tt>, you can generate the MDP client and worker codecs. We pass the same two models to a different code generator:</p>
<div class="code">
<pre><code>gsl -script:codec_c mdp_client.xml mdp_worker.xml</code>
</pre></div>
<p>Which gives us <tt>mdp_client</tt> and <tt>mdp_worker</tt> classes. Actually MDP is so simple that it's barely worth the effort of writing the code generator. The profit comes when we want to change the protocol (which we did for the standalone Majordomo project). You modify the protocol, run the command, and out pops more perfect code.</p>
<p>The <tt>codec_c.gsl</tt> code generator is not short, but the resulting codecs are much better than the handwritten code I originally put together for Majordomo. For instance, the handwritten code had no error checking and would die if you passed it bogus messages.</p>
<p>I'm now going to explain the pros and cons of GSL-powered model-oriented code generation. Power does not come for free and one of the greatest traps in our business is the ability to invent concepts out of thin air. GSL makes this particularly easy, so it can be an equally dangerous tool.</p>
<p><em>Do not invent concepts</em>. The job of a designer is to remove problems, not add features.</p>
<p>Firstly, I will lay out the advantages of model-oriented code generation:</p>
<ul>
<li>You can create near-perfect abstractions that map to your real world. So, our protocol model maps 100% to the "real world" of Majordomo. This would be impossible without the freedom to tune and change the model in any way.</li>
<li>You can develop these perfect models quickly and cheaply.</li>
<li>You can generate <em>any</em> text output. From a single model, you can create documentation, code in any language, test tools—literally any output you can think of.</li>
<li>You can generate (and I mean this literally) <em>perfect</em> output because it's cheap to improve your code generators to any level you want.</li>
<li>You get a single source that combines specifications and semantics.</li>
<li>You can leverage a small team to a massive size. At iMatix, we produced the million-line OpenAMQ messaging product out of perhaps 85K lines of input models, including the code generation scripts themselves.</li>
</ul>
<p>Now let's look at the disadvantages:</p>
<ul>
<li>You add tool dependencies to your project.</li>
<li>You may get carried away and create models for the pure joy of creating them.</li>
<li>You may alienate newcomers, who will see "strange stuff", from your work.</li>
<li>You may give people a strong excuse not to invest in your project.</li>
</ul>
<p>Cynically, model-oriented abuse works great in environments where you want to produce huge amounts of perfect code that you can maintain with little effort and which <em>no one can ever take away from you.</em> Personally, I like to cross my rivers and move on. But if long-term job security is your thing, this is almost perfect.</p>
<p>So if you do use GSL and want to create open communities around your work, here is my advice:</p>
<ul>
<li>Use it only where you would otherwise be writing tiresome code by hand.</li>
<li>Design natural models that are what people would expect to see.</li>
<li>Write the code by hand first so you know what to generate.</li>
<li>Do not overuse. Keep it simple! <em>Do not get too meta!!</em></li>
<li>Introduce gradually into a project.</li>
<li>Put the generated code into your repositories.</li>
</ul>
<p>We're already using GSL in some projects around ZeroMQ. For example, the high-level C binding, CZMQ, uses GSL to generate the socket options class (<tt>zsockopt</tt>). A 300-line code generator turns 78 lines of XML model into 1,500 lines of perfect, but really boring code. That's a good win.</p>
<p><a name="Transferring-Files"></a><a name="header-212"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc211"><span><a href="http://zguide.zeromq.org/page:all#Transferring-Files">Transferring Files</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-211">prev</a> <a href="http://zguide.zeromq.org/page:all#header-213">next</a></td>
</tr>
</tbody></table>
<p>Let's take a break from the lecturing and get back to our first love and the reason for doing all of this: code.</p>
<p>"How do I send a file?" is a common question on the ZeroMQ mailing lists. This should not be surprising, because file transfer is perhaps the oldest and most obvious type of messaging. Sending files around networks has lots of use cases apart from annoying the copyright cartels. ZeroMQ is very good out of the box at sending events and tasks, but less good at sending files.</p>
<p>I've promised, for a year or two, to write a proper explanation. Here's a gratuitous piece of information to brighten your morning: the word "proper" comes from the archaic French <em>propre</em>, which means "clean". The dark age English common folk, not being familiar with hot water and soap, changed the word to mean "foreign" or "upper-class", as in "that's proper food!", but later the word came to mean just "real", as in "that's a proper mess you've gotten us into!"</p>
<p>So, file transfer. There are several reasons you can't just pick up a random file, blindfold it, and shove it whole into a message. The most obvious reason being that despite decades of determined growth in RAM sizes (and who among us old-timers doesn't fondly remember saving up for that 1024-byte memory extension card?!), disk sizes obstinately remain much larger. Even if we could send a file with one instruction (say, using a system call like sendfile), we'd hit the reality that networks are not infinitely fast nor perfectly reliable. After trying to upload a large file several times on a slow flaky network (WiFi, anyone?), you'll realize that a proper file transfer protocol needs a way to recover from failures. That is, it needs a way to send only the part of a file that wasn't yet received.</p>
<p>Finally, after all this, if you build a proper file server, you'll notice that simply sending massive amounts of data to lots of clients creates that situation we like to call, in the technical parlance, "server went belly-up due to all available heap memory being eaten by a poorly designed application". A proper file transfer protocol needs to pay attention to memory use.</p>
<p>We'll solve these problems properly, one-by-one, which should hopefully get us to a good and proper file transfer protocol running over ZeroMQ. First, let's generate a 1GB test file with random data (real power-of-two-giga-like-Von-Neumman-intended, not the fake silicon ones the memory industry likes to sell):</p>
<div class="code">
<pre><code>dd if=/dev/urandom of=testdata bs=1M count=1024</code>
</pre></div>
<p>This is large enough to be troublesome when we have lots of clients asking for the same file at once, and on many machines, 1GB is going to be too large to allocate in memory anyhow. As a base reference, let's measure how long it takes to copy this file from disk back to disk. This will tell us how much our file transfer protocol adds on top (including network costs):</p>
<div class="code">
<pre><code>$ time cp testdata testdata2

real    0m7.143s
user    0m0.012s
sys     0m1.188s</code>
</pre></div>
<p>The 4-figure precision is misleading; expect variations of 25% either way. This is just an "order of magnitude" measurement.</p>
<p>Here's our first cut at the code, where the client asks for the test data and the server just sends it, without stopping for breath, as a series of messages, where each message holds one <em>chunk</em>:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">fileio1:&nbsp;File&nbsp;transfer&nbsp;test,&nbsp;model&nbsp;1&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">fileio1:&nbsp;File&nbsp;transfer&nbsp;test,&nbsp;model&nbsp;1&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#BC7A00"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>File Transfer model #1<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt><br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>In which the server sends the entire file to the client in<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>large chunks with no attempt at flow control.</span></p>
<p>#include &lt;czmq.h&gt;<br>
#define CHUNK_SIZE<tt><span style="white-space: pre-wrap;">  </span></tt>250000</p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<span style="color:#0000FF">client_thread</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>args, zctx_t <span style="color:#666666">*</span>ctx, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>pipe)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>dealer <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_DEALER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect (dealer, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>127.0.0.1:6000"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zstr_send (dealer, <span style="color:#BA2121">"fetch"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">size_t</span> total <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<tt><span style="white-space: pre-wrap;">       </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Total bytes received</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">size_t</span> chunks <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<tt><span style="white-space: pre-wrap;">      </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Total chunks received</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_t <span style="color:#666666">*</span>frame <span style="color:#666666">=</span> zframe_recv (dealer);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>frame)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Shutting down, quit</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>chunks<span style="color:#666666">++</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">size_t</span> size <span style="color:#666666">=</span> zframe_size (frame);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_destroy (<span style="color:#666666">&amp;</span>frame);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>total <span style="color:#666666">+=</span> size;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (size <span style="color:#666666">==</span> <span style="color:#666666">0</span>)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Whole file received</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"%zd chunks received, %zd bytes</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, chunks, total);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zstr_send (pipe, <span style="color:#BA2121">"OK"</span>);<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The server thread reads the file from disk in chunks, and sends<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>each chunk to the client as a separate message. We only have one<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>test file, so open that once and then serve it out as needed:</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<span style="color:#0000FF">server_thread</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>args, zctx_t <span style="color:#666666">*</span>ctx, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>pipe)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">FILE</span> <span style="color:#666666">*</span>file <span style="color:#666666">=</span> fopen (<span style="color:#BA2121">"testdata"</span>, <span style="color:#BA2121">"r"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (file);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>router <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_ROUTER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Default HWM is 1000, which will drop messages here</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>because we send more than 1,000 chunks of test data,</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>so set an infinite HWM as a simple, stupid solution:</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_set_hwm (router, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (router, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:6000"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>First frame in each message is the sender identity</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_t <span style="color:#666666">*</span>identity <span style="color:#666666">=</span> zframe_recv (router);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>identity)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Shutting down, quit</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Second frame is "fetch" command</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>command <span style="color:#666666">=</span> zstr_recv (router);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>assert (streq (command, <span style="color:#BA2121">"fetch"</span>));<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (command);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>byte <span style="color:#666666">*</span>data <span style="color:#666666">=</span> malloc (CHUNK_SIZE);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>assert (data);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#B00040">size_t</span> size <span style="color:#666666">=</span> fread (data, <span style="color:#666666">1</span>, CHUNK_SIZE, file);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_t <span style="color:#666666">*</span>chunk <span style="color:#666666">=</span> zframe_new (data, size);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_send (<span style="color:#666666">&amp;</span>identity, router, ZFRAME_REUSE <span style="color:#666666">+</span> ZFRAME_MORE);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zframe_send (<span style="color:#666666">&amp;</span>chunk, router, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>if</strong></span> (size <span style="color:#666666">==</span> <span style="color:#666666">0</span>)<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">          </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Always end with a zero-size frame</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_destroy (<span style="color:#666666">&amp;</span>identity);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>fclose (file);<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The main task starts the client and server threads; it's easier<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>to test this as a single process with threads, than as multiple<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>processes:</span></span></p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Start child threads</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_t <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zthread_fork (ctx, server_thread, <span style="color:#008000">NULL</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>client <span style="color:#666666">=</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zthread_fork (ctx, client_thread, <span style="color:#008000">NULL</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Loop until client tells us it's done</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>string <span style="color:#666666">=</span> zstr_recv (client);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>free (string);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Kill server thread</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/py:fileio1" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | C# | Clojure | CL | Delphi | Erlang | F# | Felix | Go | Haskell | Haxe | Java | Lua | Node.js | Objective-C | ooc | Perl | PHP | Q | Racket | Ruby | Scala | Tcl</a></span>
<p>It's pretty simple, but we already run into a problem: if we send too much data to the ROUTER socket, we can easily overflow it. The simple but stupid solution is to put an infinite high-water mark on the socket. It's stupid because we now have no protection against exhausting the server's memory. Yet without an infinite HWM, we risk losing chunks of large files.</p>
<p>Try this: set the HWM to 1,000 (in ZeroMQ v3.x this is the default) and then reduce the chunk size to 100K so we send 10K chunks in one go. Run the test, and you'll see it never finishes. As the <tt><a href="http://api.zeromq.org/3-2:zmq_socket">zmq_socket()</a></tt> man page says with cheerful brutality, for the ROUTER socket: "ZMQ_HWM option action: Drop".</p>
<p>We have to control the amount of data the server sends up-front. There's no point in it sending more than the network can handle. Let's try sending one chunk at a time. In this version of the protocol, the client will explicitly say, "Give me chunk N", and the server will fetch that specific chunk from disk and send it.</p>
<p>Here's the improved second model, where the client asks for one chunk at a time, and the server only sends one chunk for each request it gets from the client:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">fileio2:&nbsp;File&nbsp;transfer&nbsp;test,&nbsp;model&nbsp;2&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">fileio2:&nbsp;File&nbsp;transfer&nbsp;test,&nbsp;model&nbsp;2&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>File Transfer model #2<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt><br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>In which the client requests each chunk individually, thus<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>eliminating server queue overflows, but at a cost in speed.</span></span></p>
<p><span style="color:#BC7A00">#include &lt;czmq.h&gt;<br>
#define CHUNK_SIZE<tt><span style="white-space: pre-wrap;">  </span></tt>250000</span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<span style="color:#0000FF">client_thread</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>args, <span style="color:#B00040">zctx_t</span> <span style="color:#666666">*</span>ctx, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>pipe)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>dealer <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_DEALER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_set_hwm (dealer, <span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect (dealer, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>127.0.0.1:6000"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">size_t</span> total <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<tt><span style="white-space: pre-wrap;">       </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Total bytes received</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">size_t</span> chunks <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<tt><span style="white-space: pre-wrap;">      </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Total chunks received</em></span></p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Ask for next chunk</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zstr_sendm (dealer, <span style="color:#BA2121">"fetch"</span>);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zstr_sendfm (dealer, <span style="color:#BA2121">"%ld"</span>, total);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zstr_sendf (dealer, <span style="color:#BA2121">"%d"</span>, CHUNK_SIZE);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">zframe_t</span> <span style="color:#666666">*</span>chunk <span style="color:#666666">=</span> zframe_recv (dealer);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>chunk)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Shutting down, quit</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>chunks<span style="color:#666666">++</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">size_t</span> size <span style="color:#666666">=</span> zframe_size (chunk);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_destroy (<span style="color:#666666">&amp;</span>chunk);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>total <span style="color:#666666">+=</span> size;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (size <span style="color:#666666">&lt;</span> CHUNK_SIZE)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Last chunk received; exit</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"%zd chunks received, %zd bytes</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, chunks, total);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zstr_send (pipe, <span style="color:#BA2121">"OK"</span>);<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The server thread waits for a chunk request from a client,<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>reads that chunk, and sends it back to the client:</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<span style="color:#0000FF">server_thread</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>args, <span style="color:#B00040">zctx_t</span> <span style="color:#666666">*</span>ctx, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>pipe)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">FILE</span> <span style="color:#666666">*</span>file <span style="color:#666666">=</span> fopen (<span style="color:#BA2121">"testdata"</span>, <span style="color:#BA2121">"r"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (file);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>router <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_ROUTER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_set_hwm (router, <span style="color:#666666">1</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (router, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:6000"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>First frame in each message is the sender identity</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">zframe_t</span> <span style="color:#666666">*</span>identity <span style="color:#666666">=</span> zframe_recv (router);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>identity)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Shutting down, quit</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Second frame is "fetch" command</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>command <span style="color:#666666">=</span> zstr_recv (router);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>assert (streq (command, <span style="color:#BA2121">"fetch"</span>));<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (command);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Third frame is chunk offset in file</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>offset_str <span style="color:#666666">=</span> zstr_recv (router);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">size_t</span> offset <span style="color:#666666">=</span> atoi (offset_str);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (offset_str);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Fourth frame is maximum chunk size</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>chunksz_str <span style="color:#666666">=</span> zstr_recv (router);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">size_t</span> chunksz <span style="color:#666666">=</span> atoi (chunksz_str);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (chunksz_str);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Read chunk of data from file</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>fseek (file, offset, SEEK_SET);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>byte <span style="color:#666666">*</span>data <span style="color:#666666">=</span> malloc (chunksz);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>assert (data);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send resulting chunk to client</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">size_t</span> size <span style="color:#666666">=</span> fread (data, <span style="color:#666666">1</span>, chunksz, file);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">zframe_t</span> <span style="color:#666666">*</span>chunk <span style="color:#666666">=</span> zframe_new (data, size);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_send (<span style="color:#666666">&amp;</span>identity, router, ZFRAME_MORE);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_send (<span style="color:#666666">&amp;</span>chunk, router, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>fclose (file);<br>
}</p>
<p><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The main task is just the same as in the first model.</em></span></p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Start child threads</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">zctx_t</span> <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zthread_fork (ctx, server_thread, <span style="color:#008000">NULL</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>client <span style="color:#666666">=</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zthread_fork (ctx, client_thread, <span style="color:#008000">NULL</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Loop until client tells us it's done</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>string <span style="color:#666666">=</span> zstr_recv (client);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>free (string);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Kill server thread</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/py:fileio2" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | C# | Clojure | CL | Delphi | Erlang | F# | Felix | Go | Haskell | Haxe | Java | Lua | Node.js | Objective-C | ooc | Perl | PHP | Q | Racket | Ruby | Scala | Tcl</a></span>
<p>It is much slower now, because of the to-and-fro chatting between client and server. We pay about 300 microseconds for each request-reply round-trip, on a local loop connection (client and server on the same box). It doesn't sound like much but it adds up quickly:</p>
<div class="code">
<pre><code>$ time ./fileio1
4296 chunks received, 1073741824 bytes

real    0m0.669s
user    0m0.056s
sys     0m1.048s

$ time ./fileio2
4295 chunks received, 1073741824 bytes

real    0m2.389s
user    0m0.312s
sys     0m2.136s</code>
</pre></div>
<p>There are two valuable lessons here. First, while request-reply is easy, it's also too slow for high-volume data flows. Paying that 300 microseconds once would be fine. Paying it for every single chunk isn't acceptable, particularly on real networks with latencies of perhaps 1,000 times higher.</p>
<p>The second point is something I've said before but will repeat: it's incredibly easy to experiment, measure, and improve a protocol over ZeroMQ. And when the cost of something comes way down, you can afford a lot more of it. Do learn to develop and prove your protocols in isolation: I've seen teams waste time trying to improve poorly designed protocols that are too deeply embedded in applications to be easily testable or fixable.</p>
<p>Our model two file transfer protocol isn't so bad, apart from performance:</p>
<ul>
<li>It completely eliminates any risk of memory exhaustion. To prove that, we set the high-water mark to 1 in both sender and receiver.</li>
<li>It lets the client choose the chunk size, which is useful because if there's any tuning of the chunk size to be done, for network conditions, for file types, or to reduce memory consumption further, it's the client that should be doing this.</li>
<li>It gives us fully restartable file transfers.</li>
<li>It allows the client to cancel the file transfer at any point in time.</li>
</ul>
<p>If we just didn't have to do a request for each chunk, it'd be a usable protocol. What we need is a way for the server to send multiple chunks without waiting for the client to request or acknowledge each one. What are our choices?</p>
<ul>
<li>The server could send 10 chunks at once, then wait for a single acknowledgment. That's exactly like multiplying the chunk size by 10, so it's pointless. And yes, it's just as pointless for all values of 10.</li>
</ul>
<ul>
<li>The server could send chunks without any chatter from the client but with a slight delay between each send, so that it would send chunks only as fast as the network could handle them. This would require the server to know what's happening at the network layer, which sounds like hard work. It also breaks layering horribly. And what happens if the network is really fast, but the client itself is slow? Where are chunks queued then?</li>
</ul>
<ul>
<li>The server could try to spy on the sending queue, i.e., see how full it is, and send only when the queue isn't full. Well, ZeroMQ doesn't allow that because it doesn't work, for the same reason as throttling doesn't work. The server and network may be more than fast enough, but the client may be a slow little device.</li>
</ul>
<ul>
<li>We could modify <tt>libzmq</tt> to take some other action on reaching HWM. Perhaps it could block? That would mean that a single slow client would block the whole server, so no thank you. Maybe it could return an error to the caller? Then the server could do something smart like… well, there isn't really anything it could do that's any better than dropping the message.</li>
</ul>
<p>Apart from being complex and variously unpleasant, none of these options would even work. What we need is a way for the client to tell the server, asynchronously and in the background, that it's ready for more. We need some kind of asynchronous flow control. If we do this right, data should flow without interruption from the server to the client, but only as long as the client is reading it. Let's review our three protocols. This was the first one:</p>
<div class="code">
<pre><code>C: fetch
S: chunk 1
S: chunk 2
S: chunk 3
....</code>
</pre></div>
<p>And the second introduced a request for each chunk:</p>
<div class="code">
<pre><code>C: fetch chunk 1
S: send chunk 1
C: fetch chunk 2
S: send chunk 2
C: fetch chunk 3
S: send chunk 3
C: fetch chunk 4
....</code>
</pre></div>
<p>Now—waves hands mysteriously—here's a changed protocol that fixes the performance problem:</p>
<div class="code">
<pre><code>C: fetch chunk 1
C: fetch chunk 2
C: fetch chunk 3
S: send chunk 1
C: fetch chunk 4
S: send chunk 2
S: send chunk 3
....</code>
</pre></div>
<p>It looks suspiciously similar. In fact, it's identical except that we send multiple requests without waiting for a reply for each one. This is a technique called "pipelining" and it works because our DEALER and ROUTER sockets are fully asynchronous.</p>
<p>Here's the third model of our file transfer test-bench, with pipelining. The client sends a number of requests ahead (the "credit") and then each time it processes an incoming chunk, it sends one more credit. The server will never send more chunks than the client has asked for:</p>
<div class="collapsible-block">
<div class="collapsible-block-folded"><a class="collapsible-block-link" href="javascript:;">fileio3:&nbsp;File&nbsp;transfer&nbsp;test,&nbsp;model&nbsp;3&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-unfolded" style="display:none">
<div class="collapsible-block-unfolded-link"><a class="collapsible-block-link" href="javascript:;">fileio3:&nbsp;File&nbsp;transfer&nbsp;test,&nbsp;model&nbsp;3&nbsp;in&nbsp;C</a></div>
<div class="collapsible-block-content">
<div class="code">
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>File Transfer model #3<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt><br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>In which the client requests each chunk individually, using<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>command pipelining to give us a credit-based flow control.</span></span></p>
<p><span style="color:#BC7A00">#include &lt;czmq.h&gt;<br>
#define CHUNK_SIZE<tt><span style="white-space: pre-wrap;">  </span></tt>250000<br>
#define PIPELINE<tt><span style="white-space: pre-wrap;">    </span></tt>10</span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<span style="color:#0000FF">client_thread</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>args, <span style="color:#B00040">zctx_t</span> <span style="color:#666666">*</span>ctx, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>pipe)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>dealer <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_DEALER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_connect (dealer, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>127.0.0.1:6000"</span>);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Up to this many chunks in transit</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">size_t</span> credit <span style="color:#666666">=</span> PIPELINE;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">size_t</span> total <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<tt><span style="white-space: pre-wrap;">       </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Total bytes received</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">size_t</span> chunks <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<tt><span style="white-space: pre-wrap;">      </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Total chunks received</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">size_t</span> offset <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<tt><span style="white-space: pre-wrap;">      </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Offset of next chunk request</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>while</strong></span> (credit) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Ask for next chunk</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zstr_sendm<tt><span style="white-space: pre-wrap;">  </span></tt>(dealer, <span style="color:#BA2121">"fetch"</span>);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zstr_sendfm (dealer, <span style="color:#BA2121">"%ld"</span>, offset);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zstr_sendf<tt><span style="white-space: pre-wrap;">  </span></tt>(dealer, <span style="color:#BA2121">"%ld"</span>, (<span style="color:#B00040">long</span>) CHUNK_SIZE);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>offset <span style="color:#666666">+=</span> CHUNK_SIZE;<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>credit<span style="color:#666666"><span style="white-space: pre-wrap;">--</span></span>;<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">zframe_t</span> <span style="color:#666666">*</span>chunk <span style="color:#666666">=</span> zframe_recv (dealer);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>chunk)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Shutting down, quit</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>chunks<span style="color:#666666">++</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>credit<span style="color:#666666">++</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">size_t</span> size <span style="color:#666666">=</span> zframe_size (chunk);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_destroy (<span style="color:#666666">&amp;</span>chunk);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>total <span style="color:#666666">+=</span> size;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (size <span style="color:#666666">&lt;</span> CHUNK_SIZE)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Last chunk received; exit</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"%zd chunks received, %zd bytes</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>, chunks, total);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zstr_send (pipe, <span style="color:#BA2121">"OK"</span>);<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The rest of the code is exactly the same as in model 2, except<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>that we set the HWM on the server's ROUTER socket to PIPELINE<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>to act as a sanity check.</span></span></p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The server thread waits for a chunk request from a client,<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>reads that chunk and sends it back to the client:</span></span></p>
<p><span style="color:#008000"><strong>static</strong></span> <span style="color:#B00040">void</span><br>
<span style="color:#0000FF">server_thread</span> (<span style="color:#B00040">void</span> <span style="color:#666666">*</span>args, <span style="color:#B00040">zctx_t</span> <span style="color:#666666">*</span>ctx, <span style="color:#B00040">void</span> <span style="color:#666666">*</span>pipe)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">FILE</span> <span style="color:#666666">*</span>file <span style="color:#666666">=</span> fopen (<span style="color:#BA2121">"testdata"</span>, <span style="color:#BA2121">"r"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>assert (file);</p>
<p><tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>router <span style="color:#666666">=</span> zsocket_new (ctx, ZMQ_ROUTER);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>We have two parts per message so HWM is PIPELINE * 2</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_set_hwm (router, PIPELINE <span style="color:#666666">*</span> <span style="color:#666666">2</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zsocket_bind (router, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:6000"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (<span style="color:#008000">true</span>) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>First frame in each message is the sender identity</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">zframe_t</span> <span style="color:#666666">*</span>identity <span style="color:#666666">=</span> zframe_recv (router);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (<span style="color:#666666">!</span>identity)<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>break</strong></span>;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Shutting down, quit</em></span><br>
<tt><span style="white-space: pre-wrap;">            </span></tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Second frame is "fetch" command</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>command <span style="color:#666666">=</span> zstr_recv (router);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>assert (streq (command, <span style="color:#BA2121">"fetch"</span>));<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (command);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Third frame is chunk offset in file</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>offset_str <span style="color:#666666">=</span> zstr_recv (router);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">size_t</span> offset <span style="color:#666666">=</span> atoi (offset_str);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (offset_str);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Fourth frame is maximum chunk size</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>chunksz_str <span style="color:#666666">=</span> zstr_recv (router);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">size_t</span> chunksz <span style="color:#666666">=</span> atoi (chunksz_str);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>free (chunksz_str);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Read chunk of data from file</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt>fseek (file, offset, SEEK_SET);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>byte <span style="color:#666666">*</span>data <span style="color:#666666">=</span> malloc (chunksz);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>assert (data);</p>
<p><tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Send resulting chunk to client</em></span><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">size_t</span> size <span style="color:#666666">=</span> fread (data, <span style="color:#666666">1</span>, chunksz, file);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#B00040">zframe_t</span> <span style="color:#666666">*</span>chunk <span style="color:#666666">=</span> zframe_new (data, size);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_send (<span style="color:#666666">&amp;</span>identity, router, ZFRAME_MORE);<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>zframe_send (<span style="color:#666666">&amp;</span>chunk, router, <span style="color:#666666">0</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>fclose (file);<br>
}</p>
<p><span style="color:#408080"><span style="font-style:italic"><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>The main task starts the client and server threads; it's easier<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>to test this as a single process with threads, than as multiple<br>
<span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>processes:</span></span></p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">void</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Start child threads</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">zctx_t</span> <span style="color:#666666">*</span>ctx <span style="color:#666666">=</span> zctx_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zthread_fork (ctx, server_thread, <span style="color:#008000">NULL</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">void</span> <span style="color:#666666">*</span>client <span style="color:#666666">=</span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zthread_fork (ctx, client_thread, <span style="color:#008000">NULL</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Loop until client tells us it's done</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#B00040">char</span> <span style="color:#666666">*</span>string <span style="color:#666666">=</span> zstr_recv (client);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>free (string);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Kill server thread</em></span><br>
<tt><span style="white-space: pre-wrap;">    </span></tt>zctx_destroy (<span style="color:#666666">&amp;</span>ctx);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
</div>
</div>
</div>
<br>
<span style="font-size:smaller;"><a href="http://zguide.zeromq.org/py:fileio3" target="_blank">Python</a> | <a href="http://zguide.zeromq.org/main:translate">Ada | Basic | C++ | C# | Clojure | CL | Delphi | Erlang | F# | Felix | Go | Haskell | Haxe | Java | Lua | Node.js | Objective-C | ooc | Perl | PHP | Q | Racket | Ruby | Scala | Tcl</a></span>
<p>That tweak gives us full control over the end-to-end pipeline including all network buffers and ZeroMQ queues at sender and receiver. We ensure the pipeline is always filled with data while never growing beyond a predefined limit. More than that, the client decides exactly when to send "credit" to the sender. It could be when it receives a chunk, or when it has fully processed a chunk. And this happens asynchronously, with no significant performance cost.</p>
<p>In the third model, I chose a pipeline size of 10 messages (each message is a chunk). This will cost a maximum of 2.5MB memory per client. So with 1GB of memory we can handle at least 400 clients. We can try to calculate the ideal pipeline size. It takes about 0.7 seconds to send the 1GB file, which is about 160 microseconds for a chunk. A round trip is 300 microseconds, so the pipeline needs to be at least 3-5 chunks to keep the server busy. In practice, I still got performance spikes with a pipeline of 5 chunks, probably because the credit messages sometimes get delayed by outgoing data. So at 10 chunks, it works consistently.</p>
<div class="code">
<pre><code>$ time ./fileio3
4291 chunks received, 1072741824 bytes

real    0m0.777s
user    0m0.096s
sys     0m1.120s</code>
</pre></div>
<p>Do measure rigorously. Your calculations may be good, but the real world tends to have its own opinions.</p>
<p>What we've made is clearly not yet a real file transfer protocol, but it proves the pattern and I think it is the simplest plausible design. For a real working protocol, we might want to add some or all of:</p>
<ul>
<li>Authentication and access controls, even without encryption: the point isn't to protect sensitive data, but to catch errors like sending test data to production servers.</li>
</ul>
<ul>
<li>A Cheap-style request including file path, optional compression, and other stuff we've learned is useful from HTTP (such as If-Modified-Since).</li>
</ul>
<ul>
<li>A Cheap-style response, at least for the first chunk, that provides meta data such as file size (so the client can pre-allocate, and avoid unpleasant disk-full situations).</li>
</ul>
<ul>
<li>The ability to fetch a set of files in one go, otherwise the protocol becomes inefficient for large sets of small files.</li>
</ul>
<ul>
<li>Confirmation from the client when it's fully received a file, to recover from chunks that might be lost if the client disconnects unexpectedly.</li>
</ul>
<p>So far, our semantic has been "fetch"; that is, the recipient knows (somehow) that they need a specific file, so they ask for it. The knowledge of which files exist and where they are is then passed out-of-band (e.g., in HTTP, by links in the HTML page).</p>
<p>How about a "push" semantic? There are two plausible use cases for this. First, if we adopt a centralized architecture with files on a main "server" (not something I'm advocating, but people do sometimes like this), then it's very useful to allow clients to upload files to the server. Second, it lets us do a kind of pub-sub for files, where the client asks for all new files of some type; as the server gets these, it forwards them to the client.</p>
<p>A fetch semantic is synchronous, while a push semantic is asynchronous. Asynchronous is less chatty, so faster. Also, you can do cute things like "subscribe to this path" thus creating a pub-sub file transfer architecture. That is so obviously awesome that I shouldn't need to explain what problem it solves.</p>
<p>Still, here is the problem with the fetch semantic: that out-of-band route to tell clients what files exist. No matter how you do this, it ends up being complex. Either clients have to poll, or you need a separate pub-sub channel to keep clients up-to-date, or you need user interaction.</p>
<p>Thinking this through a little more, though, we can see that fetch is just a special case of pub-sub. So we can get the best of both worlds. Here is the general design:</p>
<ul>
<li>Fetch this path</li>
<li>Here is credit (repeat)</li>
</ul>
<p>To make this work (and we will, my dear readers), we need to be a little more explicit about how we send credit to the server. The cute trick of treating a pipelined "fetch chunk" request as credit won't fly because the client doesn't know any longer what files actually exist, how large they are, anything. If the client says, "I'm good for 250,000 bytes of data", this should work equally for 1 file of 250K bytes, or 100 files of 2,500 bytes.</p>
<p>And this gives us "credit-based flow control", which effectively removes the need for high-water marks, and any risk of memory overflow.</p>
<p><a name="State-Machines"></a><a name="header-213"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc212"><span><a href="http://zguide.zeromq.org/page:all#State-Machines">State Machines</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-212">prev</a> <a href="http://zguide.zeromq.org/page:all#header-214">next</a></td>
</tr>
</tbody></table>
<p>Software engineers tend to think of (finite) state machines as a kind of intermediary interpreter. That is, you take a regular language and compile that into a state machine, then execute the state machine. The state machine itself is rarely visible to the developer: it's an internal representation—optimized, compressed, and bizarre.</p>
<p>However, it turns out that state machines are also valuable as a first-class modeling languages for protocol handlers, e.g., ZeroMQ clients and servers. ZeroMQ makes it rather easy to design protocols, but we've never defined a good pattern for writing those clients and servers properly.</p>
<p>A protocol has at least two levels:</p>
<ul>
<li>How we represent individual messages on the wire.</li>
<li>How messages flow between peers, and the significance of each message.</li>
</ul>
<p>We've seen in this chapter how to produce codecs that handle serialization. That's a good start. But if we leave the second job to developers, that gives them a lot of room to interpret. As we make more ambitious protocols (file transfer + heartbeating + credit + authentication), it becomes less and less sane to try to implement clients and servers by hand.</p>
<p>Yes, people do this almost systematically. But the costs are high, and they're avoidable. I'll explain how to model protocols using state machines, and how to generate neat and solid code from those models.</p>
<p>My experience with using state machines as a software construction tool dates to 1985 and my first real job making tools for application developers. In 1991, I turned that knowledge into a free software tool called Libero, which spat out executable state machines from a simple text model.</p>
<p>The thing about Libero's model was that it was readable. That is, you described your program logic as named states, each accepting a set of events, each doing some real work. The resulting state machine hooked into your application code, driving it like a boss.</p>
<p>Libero was charmingly good at its job, fluent in many languages, and modestly popular given the enigmatic nature of state machines. We used Libero in anger in dozens of large distributed applications, one of which was finally switched off in 2011 after 20 years of operation. State-machine driven code construction worked so well that it's somewhat impressive that this approach never hit the mainstream of software engineering.</p>
<p>So in this section I'm going to explain Libero's model, and demonstrate how to use it to generate ZeroMQ clients and servers. We'll use GSL again, but like I said, the principles are general and you can put together code generators using any scripting language.</p>
<p>As a worked example, let's see how to carry-on a stateful dialog with a peer on a ROUTER socket. We'll develop the server using a state machine (and the client by hand). We have a simple protocol that I'll call "NOM". I'm using the oh-so-very-serious <a href="http://unprotocols.org/blog:2">keywords for unprotocols</a> proposal:</p>
<div class="code">
<pre><code>nom-protocol    = open-peering *use-peering

open-peering    = C:OHAI ( S:OHAI-OK / S:WTF )

use-peering     = C:ICANHAZ
                / S:CHEEZBURGER
                / C:HUGZ S:HUGZ-OK
                / S:HUGZ C:HUGZ-OK</code>
</pre></div>
<p>I've not found a quick way to explain the true nature of state machine programming. In my experience, it invariably takes a few days of practice. After three or four days' exposure to the idea, there is a near-audible "click!" as something in the brain connects all the pieces together. We'll make it concrete by looking at the state machine for our NOM server.</p>
<p>A useful thing about state machines is that you can read them state by state. Each state has a unique descriptive name and one or more <em>events</em>, which we list in any order. For each event, we perform zero or more <em>actions</em> and we then move to a <em>next state</em> (or stay in the same state).</p>
<p>In a ZeroMQ protocol server, we have a state machine instance <em>per client</em>. That sounds complex but it isn't, as we'll see. We describe our first state, <tt>Start</tt>, as having one valid event: <tt>OHAI</tt>. We check the user's credentials and then arrive in the Authenticated state.</p>
<p><strong>Figure 64 - The Start State</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig64.png" alt="fig64.png" class="image"></div>
<p>The <tt>Check Credentials</tt> action produces either an <tt>ok</tt> or an <tt>error</tt> event. It's in the Authenticated state that we handle these two possible events by sending an appropriate reply back to the client. If authentication failed, we return to the <tt>Start</tt> state where the client can try again.</p>
<p><strong>Figure 65 - The Authenticated State</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig65.png" alt="fig65.png" class="image"></div>
<p>When authentication has succeeded, we arrive in the Ready state. Here we have three possible events: an ICANHAZ or HUGZ message from the client, or a heartbeat timer event.</p>
<p><strong>Figure 66 - The Ready State</strong></p>
<div class="image-container aligncenter"><img src="./ØMQ - The Guide - ØMQ - The Guide_files/fig66.png" alt="fig66.png" class="image"></div>
<p>There are a few more things about this state machine model that are worth knowing:</p>
<ul>
<li>Events in upper case (like "HUGZ") are <em>external events</em> that come from the client as messages.</li>
<li>Events in lower case (like "heartbeat") are <em>internal events</em>, produced by code in the server.</li>
<li>The "Send SOMETHING" actions are shorthand for sending a specific reply back to the client.</li>
<li>Events that aren't defined in a particular state are silently ignored.</li>
</ul>
<p>Now, the original source for these pretty pictures is an XML model:</p>
<div class="code">
<pre><code>&lt;class name = "nom_server" script = "server_c"&gt;

&lt;state name = "start"&gt;
    &lt;event name = "OHAI" next = "authenticated"&gt;
        &lt;action name = "check credentials" /&gt;
    &lt;/event&gt;
&lt;/state&gt;

&lt;state name = "authenticated"&gt;
    &lt;event name = "ok" next = "ready"&gt;
        &lt;action name = "send" message ="OHAI-OK" /&gt;
    &lt;/event&gt;
    &lt;event name = "error" next = "start"&gt;
        &lt;action name = "send" message = "WTF" /&gt;
    &lt;/event&gt;
&lt;/state&gt;

&lt;state name = "ready"&gt;
    &lt;event name = "ICANHAZ"&gt;
        &lt;action name = "send" message = "CHEEZBURGER" /&gt;
    &lt;/event&gt;
    &lt;event name = "HUGZ"&gt;
        &lt;action name = "send" message = "HUGZ-OK" /&gt;
    &lt;/event&gt;
    &lt;event name = "heartbeat"&gt;
        &lt;action name = "send" message = "HUGZ" /&gt;
    &lt;/event&gt;
&lt;/state&gt;
&lt;/class&gt;</code>
</pre></div>
<p>The code generator is in <tt>examples/models/server_c.gsl</tt>. It is a fairly complete tool that I'll use and expand for more serious work later. It generates:</p>
<ul>
<li>A server class in C (<tt>nom_server.c</tt>, <tt>nom_server.h</tt>) that implements the whole protocol flow.</li>
<li>A selftest method that runs the selftest steps listed in the XML file.</li>
<li>Documentation in the form of graphics (the pretty pictures).</li>
</ul>
<p>Here's a simple main program that starts the generated NOM server:</p>
<div class="code">
<p><span style="color:#BC7A00">#include "czmq.h"<br>
#include "nom_server.h"</span></p>
<p><span style="color:#B00040">int</span> <span style="color:#0000FF">main</span> (<span style="color:#B00040">int</span> argc, <span style="color:#B00040">char</span> <span style="color:#666666">*</span>argv <span style="white-space: pre-wrap;">[]</span>)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>printf (<span style="color:#BA2121">"Starting NOM protocol server on port 5670…</span><span style="color:#BB6622"><strong>\n</strong></span><span style="color:#BA2121">"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>nom_server_t <span style="color:#666666">*</span>server <span style="color:#666666">=</span> nom_server_new ();<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>nom_server_bind (server, <span style="color:#BA2121">"tcp:<span style="white-space: pre-wrap;">//</span>*:5670"</span>);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>nom_server_wait (server);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>nom_server_destroy (<span style="color:#666666">&amp;</span>server);<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>return</strong></span> <span style="color:#666666">0</span>;<br>
}</p>
</div>
<p>The generated nom_server class is a fairly classic model. It accepts client messages on a ROUTER socket, so the first frame on every request is the client's connection identity. The server manages a set of clients, each with state. As messages arrive, it feeds these as <em>events</em> to the state machine. Here's the core of the state machine, as a mix of GSL commands and the C code we intend to generate:</p>
<div class="code">
<p>client_execute (client_t <span style="color:#666666">*</span>self, <span style="color:#B00040">int</span> event)<br>
{<br>
<tt><span style="white-space: pre-wrap;">    </span></tt>self<span style="color:#666666">-&gt;</span>next_event <span style="color:#666666">=</span> event;<br>
<tt><span style="white-space: pre-wrap;">    </span></tt><span style="color:#008000"><strong>while</strong></span> (self<span style="color:#666666">-&gt;</span>next_event) {<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>self<span style="color:#666666">-&gt;</span>event <span style="color:#666666">=</span> self<span style="color:#666666">-&gt;</span>next_event;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt>self<span style="color:#666666">-&gt;</span>next_event <span style="color:#666666">=</span> <span style="color:#666666">0</span>;<br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>switch</strong></span> (self<span style="color:#666666">-&gt;</span>state) {<br>
.<span style="color:#008000"><strong>for</strong></span> class.state<br>
<tt><span style="white-space: pre-wrap;">            </span></tt><span style="color:#008000"><strong>case</strong></span> $(name:c)_state<span style="color:#666666">:</span><br>
.<tt><span style="white-space: pre-wrap;">   </span></tt><span style="color:#008000"><strong>for</strong></span> event<br>
.<tt><span style="white-space: pre-wrap;">       </span></tt><span style="color:#008000"><strong>if</strong></span> index () <span style="color:#666666">&gt;</span> <span style="color:#666666">1</span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>else</strong></span><br>
.<tt><span style="white-space: pre-wrap;">       </span></tt>endif<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>if</strong></span> (self<span style="color:#666666">-&gt;</span>event <span style="color:#666666">==</span> $(name<span style="color:#666666">:</span>c)_event) {<br>
.<tt><span style="white-space: pre-wrap;">       </span></tt><span style="color:#008000"><strong>for</strong></span> action<br>
.<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#008000"><strong>if</strong></span> name <span style="color:#666666">=</span> <span style="color:#BA2121">"send"</span><br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>zmsg_addstr (self<span style="color:#666666">-&gt;</span>reply, <span style="color:#BA2121">"$(message:)"</span>);<br>
.<tt><span style="white-space: pre-wrap;">           </span></tt><span style="color:#008000"><strong>else</strong></span><br>
<tt><span style="white-space: pre-wrap;">                </span></tt>$(name<span style="color:#666666">:</span>c)_action (self);<br>
.<tt><span style="white-space: pre-wrap;">           </span></tt>endif<br>
.<tt><span style="white-space: pre-wrap;">       </span></tt>endfor<br>
.<tt><span style="white-space: pre-wrap;">       </span></tt><span style="color:#008000"><strong>if</strong></span> defined (event.next)<br>
<tt><span style="white-space: pre-wrap;">                    </span></tt>self<span style="color:#666666">-&gt;</span>state <span style="color:#666666">=</span> $(next<span style="color:#666666">:</span>c)_state;<br>
.<tt><span style="white-space: pre-wrap;">       </span></tt>endif<br>
<tt><span style="white-space: pre-wrap;">                </span>}</tt><br>
.<tt><span style="white-space: pre-wrap;">   </span></tt>endfor<br>
<tt><span style="white-space: pre-wrap;">                </span></tt><span style="color:#008000"><strong>break</strong></span>;<br>
.endfor<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">        </span></tt><span style="color:#008000"><strong>if</strong></span> (zmsg_size (self<span style="color:#666666">-&gt;</span>reply) <span style="color:#666666">&gt;</span> <span style="color:#666666">1</span>) {<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_send (<span style="color:#666666">&amp;</span>self<span style="color:#666666">-&gt;</span>reply, self<span style="color:#666666">-&gt;</span>router);<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>self<span style="color:#666666">-&gt;</span>reply <span style="color:#666666">=</span> zmsg_new ();<br>
<tt><span style="white-space: pre-wrap;">            </span></tt>zmsg_add (self<span style="color:#666666">-&gt;</span>reply, zframe_dup (self<span style="color:#666666">-&gt;</span>address));<br>
<tt><span style="white-space: pre-wrap;">        </span>}</tt><br>
<tt><span style="white-space: pre-wrap;">    </span>}</tt><br>
}</p>
</div>
<p>Each client is held as an object with various properties, including the variables we need to represent a state machine instance:</p>
<div class="code">
<p>event_t next_event;<tt><span style="white-space: pre-wrap;">         </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Next event</em></span><br>
state_t state;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Current state</em></span><br>
event_t event;<tt><span style="white-space: pre-wrap;">              </span></tt><span style="color:#408080"><em><span style="white-space: pre-wrap;">//</span><tt><span style="white-space: pre-wrap;">  </span></tt>Current event</em></span></p>
</div>
<p>You will see by now that we are generating technically-perfect code that has the precise design and shape we want. The only clue that the <tt>nom_server</tt> class isn't handwritten is that the code is <em>too good</em>. People who complain that code generators produce poor code are accustomed to poor code generators. It is trivial to extend our model as we need it. For example, here's how we generate the selftest code.</p>
<p>First, we add a "selftest" item to the state machine and write our tests. We're not using any XML grammar or validation so it really is just a matter of opening the editor and adding half-a-dozen lines of text:</p>
<div class="code">
<pre><code>&lt;selftest&gt;
    &lt;step send = "OHAI" body = "Sleepy" recv = "WTF" /&gt;
    &lt;step send = "OHAI" body = "Joe" recv = "OHAI-OK" /&gt;
    &lt;step send = "ICANHAZ" recv = "CHEEZBURGER" /&gt;
    &lt;step send = "HUGZ" recv = "HUGZ-OK" /&gt;
    &lt;step recv = "HUGZ" /&gt;
&lt;/selftest&gt;</code>
</pre></div>
<p>Designing on the fly, I decided that "send" and "recv" were a nice way to express "send this request, then expect this reply". Here's the GSL code that turns this model into real code:</p>
<div class="code">
<pre><code>.for class-&gt;selftest.step
.   if defined (send)
    msg = zmsg_new ();
    zmsg_addstr (msg, "$(send:)");
.       if defined (body)
    zmsg_addstr (msg, "$(body:)");
.       endif
    zmsg_send (&amp;msg, dealer);

.   endif
.   if defined (recv)
    msg = zmsg_recv (dealer);
    assert (msg);
    command = zmsg_popstr (msg);
    assert (streq (command, "$(recv:)"));
    free (command);
    zmsg_destroy (&amp;msg);

.   endif
.endfor</code>
</pre></div>
<p>Finally, one of the more tricky but absolutely essential parts of any state machine generator is <em>how do I plug this into my own code?</em> As a minimal example for this exercise I wanted to implement the "check credentials" action by accepting all OHAIs from my friend Joe (Hi Joe!) and reject everyone else's OHAIs. After some thought, I decided to grab code directly from the state machine model, i.e., embed action bodies in the XML file. So in <tt>nom_server.xml</tt>, you'll see this:</p>
<div class="code">
<pre><code>&lt;action name = "check credentials"&gt;
    char *body = zmsg_popstr (self-&gt;request);
    if (body &amp;&amp; streq (body, "Joe"))
        self-&gt;next_event = ok_event;
    else
        self-&gt;next_event = error_event;
    free (body);
&lt;/action&gt;</code>
</pre></div>
<p>And the code generator grabs that C code and inserts it into the generated <tt>nom_server.c</tt> file:</p>
<div class="code">
<pre><code>.for class.action
static void
$(name:c)_action (client_t *self) {
$(string.trim (.):)
}
.endfor</code>
</pre></div>
<p>And now we have something quite elegant: a single source file that describes my server state machine and also contains the native implementations for my actions. A nice mix of high-level and low-level that is about 90% smaller than the C code.</p>
<p>Beware, as your head spins with notions of all the amazing things you could produce with such leverage. While this approach gives you real power, it also moves you away from your peers, and if you go too far, you'll find yourself working alone.</p>
<p>By the way, this simple little state machine design exposes just three variables to our custom code:</p>
<ul>
<li><tt>self-&gt;next_event</tt></li>
<li><tt>self-&gt;request</tt></li>
<li><tt>self-&gt;reply</tt></li>
</ul>
<p>In the Libero state machine model, there are a few more concepts that we've not used here, but which we will need when we write larger state machines:</p>
<ul>
<li>Exceptions, which lets us write terser state machines. When an action raises an exception, further processing on the event stops. The state machine can then define how to handle exception events.</li>
<li>The <tt>Defaults</tt> state, where we can define default handling for events (especially useful for exception events).</li>
</ul>
<p><a name="Authentication-Using-SASL"></a><a name="header-214"></a></p>
<table style="width:100%">
<tbody><tr>
<td>
<h3 id="toc213"><span><a href="http://zguide.zeromq.org/page:all#Authentication-Using-SASL">Authentication Using SASL</a></span></h3>
</td>
<td style="text-align:right; font-size:80%;"><a href="http://zguide.zeromq.org/page:all#top">top</a> <a href="http://zguide.zeromq.org/page:all#header-213">prev</a> <a href="http://zguide.zeromq.org/page:all#header-215">next</a></td>
</tr>
</tbody></table>
<p>When we designed AMQP in 2007, we chose the <a href="http://en.wikipedia.org/wiki/Simple_Authentication_and_Security_Layer">Simple Authentication and Security Layer</a> (SASL) for the authentication layer, one of the ideas we took from the <a href="http://www.rfc-editor.org/rfc/rfc3080.txt">BEEP protocol framework</a>. SASL looks complex at first, but it's actually simple and fits neatly into a ZeroMQ-based protocol. What I especially like about SASL is that it's scalable. You can start with anonymous access or plain text authentication and no security, and grow to more secure mechanisms over time without changing your protocol.</p>
<p>I'm not going to give a deep explanation now because we'll see SASL in action somewhat later. But I'll explain the principle so you're already somewhat prepared.</p>
<p>In the NOM protocol, the client started with an OHAI command, which the server either accepted ("Hi Joe!") or rejected. This is simple but not scalable because server and client have to agree up-front on the type of authentication they're going to do.</p>
<p>What SASL introduced, which is genius, is a fully abstracted and negotiable security layer that's still easy to implement at the protocol level. It works as follows:</p>
<ul>
<li>The client connects.</li>
<li>The server challenges the client, passing a list of security "mechanisms" that it knows about.</li>
<li>The client chooses a security mechanism that it knows about, and answers the server's challenge with a blob of opaque data that (and here's the neat trick) some generic security library calculates and gives to the client.</li>
<li>The server takes the security mechanism the client chose, and that blob of data, and passes it to its own security library.</li>
<li>The library either accepts the client's answer, or the server challenges again.</li>
</ul>
<p>There are a number of free SASL libraries. When we come to real code, we'll implement just two mechanisms, ANONYMOUS and PLAIN, which don't need any special libraries.</p>
<p>To support SASL, we have to add an optional challenge/response step to our "open-peering" flow. Here is what the resulting protocol grammar looks like (I'm modifying NOM to do this):</p>
<div class="code">
<pre><code>secure-nom      = open-peering *use-peering

open-peering    = C:OHAI *( S:ORLY C:YARLY ) ( S:OHAI-OK / S:WTF )

ORLY            = 1*mechanism challenge
mechanism       = string
challenge       = *OCTET

YARLY           = mechanism response
response        = *OCTET</code>
</pre></div>
<p>Where ORLY and YARLY contain a string (a list of mechanisms in ORLY, one mechanism in YARLY) and a blob of opaque data. Depending on the mechanism, the initial challenge from the server may be empty. We don't care: we just pass this to the security library to deal with.</p>
<p>The SASL <a href="http://tools.ietf.org/html/rfc4422">RFC</a> goes into detail about other features (that we don't need), the</p></div></div></div></div></div></div></div></body></html>